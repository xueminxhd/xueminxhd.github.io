<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第零章：一个方法解决三道区间问题</title>
      <link href="/2021/02/27/di-ling-zhang-yi-ge-fang-fa-jie-jue-san-dao-qu-jian-wen-ti/"/>
      <url>/2021/02/27/di-ling-zhang-yi-ge-fang-fa-jie-jue-san-dao-qu-jian-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://www.cnblogs.com/labuladong/p/13975851.html" target="_blank" rel="noopener">一个方法解决三道区间问题</a><br>删除被覆盖区间、区间合并、区间交集</p><ol><li><p>排序。按照区间起点升序排序，或者先按照起点升序排序，若起点相同，则按照终点降序排序</p></li><li><p>观察规律并画图。找到区间相对位置的不同情况，并进行分析</p></li></ol><h1 id="1288-删除被覆盖区间"><a href="#1288-删除被覆盖区间" class="headerlink" title="1288. 删除被覆盖区间"></a><a href="https://leetcode-cn.com/problems/remove-covered-intervals/" target="_blank" rel="noopener">1288. 删除被覆盖区间</a></h1><ul><li>先按照起点升序排序。若起点相同，则按照终点降序排序，这样能保证下面的区间被上面的区间覆盖掉。<code>intervals=sorted(intervals,key=lambda x: (x[0], -x[1]))</code></li><li>分3种情况讨论<ul><li>完全覆盖，则计数-1</li><li>部分区间相交，则扩大右区间</li><li>完全不相交，则把区间更新到当前线段中</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeCoveredIntervals</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> intervals<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 按起点升序、终点降序的方式排列。排列后，必然是前面的区间覆盖后面的区间</span>        intervals<span class="token operator">=</span>sorted<span class="token punctuation">(</span>intervals<span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span>        left<span class="token punctuation">,</span> right <span class="token operator">=</span> intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 以第0个线段为基准，初始化合并区间的起点和终点</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> left <span class="token operator">&lt;=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> right <span class="token operator">>=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 情况1：完全覆盖</span>                res <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> right <span class="token operator">>=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> right <span class="token operator">&lt;=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 情况2：区间相交，需要合并</span>                right <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 扩大右区间</span>            <span class="token keyword">if</span> right <span class="token operator">&lt;</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 情况3：完全不相交，把区间跳转到当前线段中</span>                left <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                right <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></h1><ul><li><p>按照区间的start，排序 <code>intervals = sorted(intervals, key=lambda x: x[0])</code></p></li><li><p>如果当前的头没超过之前的尾，则取当前/ 之间尾的最大值。否则若超过了，res把当前区间添加进去。然后开始新一轮更新</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 输入: [[1,3],[2,6],[8,10],[15,18]]</span><span class="token comment" spellcheck="true"># 输出: [[1,6],[8,10],[15,18]]</span><span class="token comment" spellcheck="true"># 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> intervals<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token triple-quoted-string string">"""      :type intervals: List[List[int]]      :rtype: List[List[int]]      """</span>      <span class="token keyword">if</span> <span class="token operator">not</span> intervals<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>      intervals <span class="token operator">=</span> sorted<span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>      res <span class="token operator">=</span> <span class="token punctuation">[</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">if</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> res<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>              <span class="token comment" spellcheck="true">#更新并维护当前最大区间</span>              res<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>          <span class="token keyword">else</span><span class="token punctuation">:</span>              <span class="token comment" spellcheck="true"># 添加到结果，并重新更新</span>              res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="986-区间列表的交集"><a href="#986-区间列表的交集" class="headerlink" title="986. 区间列表的交集"></a><a href="https://leetcode-cn.com/problems/interval-list-intersections/" target="_blank" rel="noopener">986. 区间列表的交集</a></h1><ul><li>找到有交集的条件，然后取公共部分</li><li>可能存在多个区间，注意更新指针的条件</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">intervalIntersection</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type A: List[List[int]]        :type B: List[List[int]]        :rtype: List[List[int]]        """</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        i<span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        <span class="token keyword">while</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">and</span> j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>            a1<span class="token punctuation">,</span>a2<span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            b1<span class="token punctuation">,</span>b2<span class="token operator">=</span>B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> b2<span class="token operator">>=</span>a1 <span class="token operator">and</span> a2<span class="token operator">>=</span>b1<span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 有交集的情况</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>max<span class="token punctuation">(</span>a1<span class="token punctuation">,</span>b1<span class="token punctuation">)</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>a2<span class="token punctuation">,</span>b2<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 取公共部分</span>            <span class="token comment" spellcheck="true"># 跳指针</span>            <span class="token keyword">if</span> b2<span class="token operator">&lt;</span>a2<span class="token punctuation">:</span> j<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> i<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读“被讨厌的勇气”</title>
      <link href="/2021/02/26/growth/du-bei-tao-yan-de-yong-qi/"/>
      <url>/2021/02/26/growth/du-bei-tao-yan-de-yong-qi/</url>
      
        <content type="html"><![CDATA[<p>世界很简单，人生也一样</p><p><a href="https://www.youtube.com/watch?v=grmM-Rn5nyg" target="_blank" rel="noopener">为什么说爱抱怨、喜欢找借口的人往往一事无成？解读《被讨厌的勇气》学习阿德勒的人生哲学！</a></p><p><a href="https://www.youtube.com/watch?v=5cZxZCbcOQw" target="_blank" rel="noopener">过去可以被改变的真正原因，被讨厌的勇气 | 老高与小茉 Mr &amp; Mrs Gao</a></p><hr><blockquote><ul><li>建立获得幸福的勇气</li><li>不要抱怨过去，也不要抱怨当下，现在的状况都是从过去的每一次次选择中得到的。现在的结果决定了你过往经历的态度。不要放大过去的痛苦</li><li>人应该是向前看，往前走的。不要去惯着自己，别那么脆弱。聪明的人一眼就能看穿你的任何理由和借口。承认自己的不足是需要勇气的，但这才是进步的开始。</li></ul></blockquote><blockquote><p>反常识的方面：</p><ul><li>否定原因论，否定精神创伤，<strong>采取目的论</strong></li><li>认为人的烦恼<strong>全都是关于人际关系的烦恼</strong></li><li>不寻求认可或者<strong>课题分离</strong></li></ul></blockquote><blockquote><p>首先应该课题分离，然后应该在接收双方差异的同时建立平等的横向关系。“鼓励”则是这种基础之上的一种方法。</p></blockquote><blockquote><p><strong>不再从属于纵向关系</strong>，<strong>不畏惧惹人讨厌地自由前行</strong>就可以。</p></blockquote><blockquote><p><strong>人生是连续的刹那，根本不存在过去和未来。你是想要通过关注过去或未来为自己寻找免罪符。过去发生了什么与你的“此时此刻”没有任何关系，未来会如何也不是“此时此刻”要考虑的问题。假如认真地活在“此时此刻”，既看不见后面也看不到前面，才是很自然的事情。</strong></p><p><strong>人生最大的谎言就是不活在“此时此刻”。纠结过去，关注未来，把微弱而模糊的光打向人生整体，自认为看到些什么。你之前就一直忽略“此时此刻”，只关注根本就不存在的过去和未来。对自己的人生和无可替代的刹那撒了一个大大的谎言。</strong></p></blockquote><hr><h1 id="自卑感"><a href="#自卑感" class="headerlink" title="自卑感"></a>自卑感</h1><p>我们应该摒弃自卑感，进一步向前；不满足于现状，不断进步；要更加幸福。如果是这样的自卑感，那就没有任何问题。</p><p>但是，有些人无法认清<strong>“情况可以通过现实的努力而改变”</strong>这一事实，根本就没有向前迈进的勇气。他们什么都不做就断定自己不行或是现实无法改变。</p><p>自卑情结是指把自己的自卑感当做某种借口使用的状态。</p><h1 id="虚假廉价的优越感"><a href="#虚假廉价的优越感" class="headerlink" title="虚假廉价的优越感"></a>虚假廉价的优越感</h1><p>没有勇气通过努力或成长之类的健全手段去进行改变，所以想用更简便的方式进行补偿：虚假优越感。</p><p>“我”原本并不优秀或者并不特别，而通过把”我“和权势相结合，似乎显得“我”很优秀，这也就是虚假优越感。其根源在于怀有强烈的自卑感。不过，借助权势的力量来抬高自己的人终究活在他人的价值观和人生中。</p><p>在我们的文化中，弱势其实非常强大而且具有特权。</p><h1 id="目的论"><a href="#目的论" class="headerlink" title="目的论"></a>目的论</h1><p>既然时光不会倒流，那么，赋予过去的事情什么样的价值，这是“现在的你”所面临的课题。</p><p>从目的论的角度来说，你下定了“不改变”的决心，并从过去的经历或未来的想象中寻找免罪符。然而，过去和现在并不存在，存在的只是“此时此刻”。</p><blockquote><p>认为”因为有那样的上司，所以无法好好工作“，这完全是原因论。请不要这样想，而是要反过来这样看：”因为不想工作，所以才制造出一个讨厌的上司。“或者认为：”因为不愿意接受无能的自己，所以才制造出一个无能的上司“这就成了目的论式的想法</p></blockquote><h1 id="人际关系的距离和深度"><a href="#人际关系的距离和深度" class="headerlink" title="人际关系的距离和深度"></a>人际关系的距离和深度</h1><p>交友课题，工作课题，爱的课题</p><p><strong>只要你变了，周围也会改变。</strong>不能等着别人发生变化，也不要等着状况有所改变，而是<strong>由你自己勇敢迈出第一步。</strong></p><p>爱的课题：</p><ul><li><strong>当人能够感觉到“与这个人在一起可以无拘无束”的时候，才能够体会到爱。既没有自卑感也不必炫耀优越性，能够保持一种平静而自然的状态。真正的爱应该是这样的。</strong></li><li>另一方面，束缚是想要支配对方的表现，也是一种基于不信任感的想法。与一个不信任自己的人处在同一个空间里，那就根本不可能保持一种自然状态。</li><li>如果想要和谐地生活在一起，那就必须把对方当成平等的人。</li></ul><h1 id="“人生谎言”导致逃避"><a href="#“人生谎言”导致逃避" class="headerlink" title="“人生谎言”导致逃避"></a>“人生谎言”导致逃避</h1><p>企图设立种种借口来回避人生课题的情况叫做“人生谎言”。对于自己目前所处的状态，把责任转嫁给别人，通过归咎于他人或者环境来回避人生课题。</p><p><strong>决定你的生活方式（人生状态）的不是其他人，而是你自己这一事实。我们是自己选择自己的生活方式，责任就在自己。</strong></p><h1 id="勇气的心理学，使用的心理学"><a href="#勇气的心理学，使用的心理学" class="headerlink" title="勇气的心理学，使用的心理学"></a>勇气的心理学，使用的心理学</h1><p>不在于被给予了什么东西，而在于如何去使用被给予的定西。起决定作用的是你自己。</p><h1 id="为自己而活"><a href="#为自己而活" class="headerlink" title="为自己而活"></a>为自己而活</h1><p>你就活在自己的人生中。如果一味寻求别人的认可，在意别人的评价，那最终就会活在别人的人生中，而舍弃真正的自我。而且，假如说<strong>你“不是为了满足他人的期待而活”，那他人也不是为了满足你的期待而活。当别人的行为不符合自己的想法的时候也不可以发怒。</strong></p><h1 id="把自己和别人的人生课题分开来"><a href="#把自己和别人的人生课题分开来" class="headerlink" title="把自己和别人的人生课题分开来"></a>把自己和别人的人生课题分开来</h1><p>从“这是谁的课题”这一观点吃法，不干涉他人的课题。</p><p>辨别究竟是谁的课题很简单，只需考虑一下“某种选择所带来的的结果最终要谁承担？”</p><p>比如，接收心理咨询辅导后，被辅导者下什么样的决心，是否改变生活方式，这都是被辅导者本人的课题，辅导顾问不能干涉。</p><p><strong>能够改变自己的只有自己。</strong></p><p>自己通过某件东西学到了什么，明白了什么，有没有从中改变，和这个东西没关系，而是自己的事，自己的课题。</p><p>信任这一行为也需要进行课题分离。信任别人，这是你的课题。但是，如何对待你的信任，那就是对方的课题了。如果不分清界限而是把自己的希望强加给别人的话，那就变成粗暴的干涉了。</p><p><strong>关于自己的人生你能够做的就只有“选择自己认为最好的道路”。另一方面，别人如何评价你的选择，那是别人的课题，你根本无法左右。</strong></p><p>人为什么会在意别人的想法呢？答案非常简单，那就是因为你还不会进行课题分离，把原本应该是别人的课题也看成自己的课题。</p><p><strong>首先要思考”这是谁的课题“。然后进行课题分离-哪些是自己的课题，哪些是别人的课题，要冷静地划清界限。而且，不去干涉别人的课题也不让别人干涉自己的课题。</strong>这就是阿德勒心理学给出的具体而且有可能彻底改变人际关系烦恼的具有划时代的观点。</p><h1 id="砍断“格尔迪奥斯绳结”"><a href="#砍断“格尔迪奥斯绳结”" class="headerlink" title="砍断“格尔迪奥斯绳结”"></a>砍断“格尔迪奥斯绳结”</h1><blockquote><p>传说谁能解开绳结谁就当王。亚历山大大帝一看绳结非常牢固，于是便立即取出短剑将其一刀两断，说：”命运不是靠传说决定而是靠自己的剑开拓出来。我不需要传说的力量而是靠自己的剑去开创命运。“</p></blockquote><p>人际关系需要保持适当的距离，即便是亲子关系（不远不近）。<strong>伸伸手即可触及，但又不踏入对方领域，保持这种适度距离非常重要。</strong></p><p><strong>不要用“回报思想”束缚自己。如果有回报思想存在，就会产生“因为我为你做了什么，你就应该给予回报。”这是与课题分离相悖的想法思想。我们既不可以寻求回报，也不可以受其束缚。</strong></p><p>不要干涉孩子的课题。没有学会直面困难的孩子最终会想要逃避一切困难。</p><h1 id="要有自由的勇气，有被讨厌的勇气"><a href="#要有自由的勇气，有被讨厌的勇气" class="headerlink" title="要有自由的勇气，有被讨厌的勇气"></a>要有自由的勇气，有被讨厌的勇气</h1><p>要想有良好的人际关系，需要保持一定距离：太过亲密就无法正面对话。但是，距离也不可以太远。<strong>“课题分离”不是为了疏远他人，而是为了解开错综复杂的人际关系之线。</strong></p><p>人际关系并不止于课题分离，相反，<strong>分离课题是人际关系的出发点。</strong></p><p><strong>不能进行“课题分离”、一味拘泥于认可欲求的人也是极其以自我为中心的人。</strong>你正因为不想被他人认为自己不好，所以才在意他人的视线。这不是对他人关心，而是对向己的执著。</p><h1 id="直面人生课题"><a href="#直面人生课题" class="headerlink" title="直面人生课题"></a>直面人生课题</h1><p><strong>不回避人际关系课题，要积极主动地面对</strong>。如果你认为自己就是世界中心，那丝毫不会主动融入共同体中，因为一切他人都是“为我服务的人”，根本没必要由自己采取行动。</p><p>当我们在人际关系中遇到困难或者看不到出口的时候，首先应该考虑的是“倾听更大共同体的声音”这一原则。</p><h1 id="否定纵向关系，提倡横向关系"><a href="#否定纵向关系，提倡横向关系" class="headerlink" title="否定纵向关系，提倡横向关系"></a>否定纵向关系，提倡横向关系</h1><p>阿德勒心理学之所以强烈否定赏罚教育，就因为它是为了操纵孩子，是一种纵向关系。</p><p>希望被表扬或者表扬别人，这是一种把人际关系都理解为“纵向关系”的证明。阿德勒心理学<strong>反对一切纵向关系，提倡把所有的人际关系都看做“横向关系”。</strong></p><p>自卑感原本就是纵向关系中产生的一种意识。<strong>只有能够对所有人都建立起“虽不同但平等”的横向关系，那就根本不会产生自卑情结。</strong></p><h1 id="有鼓励才有勇气"><a href="#有鼓励才有勇气" class="headerlink" title="有鼓励才有勇气"></a>有鼓励才有勇气</h1><p>干涉别人实际是种纵向关系，希望通过干涉行为把对方导向自己希望的方向。这是坚信自己正确而对方错误。</p><h1 id="做一些不是“干涉”的“援助”。"><a href="#做一些不是“干涉”的“援助”。" class="headerlink" title="做一些不是“干涉”的“援助”。"></a><strong>做一些不是“干涉”的“援助”。</strong></h1><p>援助的大前提是<strong>课题分离和横向关系</strong>。以学习为例，不去居高临下地命令其学习，而是努力<strong>帮助</strong>他本人<strong>建立“自己能够学习”</strong>的自信以及提高其<strong>独立应对课题</strong>的能力。</p><p>在课题分离的前提下帮助他用<strong>他自己</strong>的力量去解决，也就是“把马带到水边，但不能强迫其喝水。”<strong>直面课题的是其本人，下定决心的也是其本人。</strong></p><p><strong>既不表扬也不批评，阿德勒心理学把这种基于横向关系的援助称为“鼓励”</strong></p><p>人害怕面对课题并不是因为没有能力。阿德勒心理学认为这不是能力问题，纯粹是“缺乏直面课题的勇气”。如果是这样的话，首先应该找回受挫的勇气。</p><p>人只有在能够感觉自己有价值的时候才可以获得勇气。</p><hr><h1 id="自我接纳"><a href="#自我接纳" class="headerlink" title="自我接纳"></a>自我接纳</h1><p>自我肯定是明明做不到但还是暗示自己说“我能行”或者“我很强”，也可以说是一种容易导致优越情结的想法，是对自己撒谎的生活方式。<strong>而另一方面，自我接纳是指加入做不到就诚实接受这个“做不到的自己”，然后尽量朝着能够做大的方向去努力。</strong></p><blockquote><p>对得了60分的自己说“这次只是运气不好，真正的自己能得100分”，这就是自我肯定；与此相对，在诚实地接收60分的自己的基础上努力思考“如何才能接近100分”，这就是自我接纳</p></blockquote><p>要分清能够改变的和不能改变的。我们无法改变“被给予了什么”，但是关于“如何去利用被给予的东西”，我们却可以用自己的力量去改变。这就是不去关注“无法改变的”，而是去关注“可以改变的”，这就是自我接纳。</p><h1 id="不构建信用关系，构建他者信赖关系"><a href="#不构建信用关系，构建他者信赖关系" class="headerlink" title="不构建信用关系，构建他者信赖关系"></a>不构建信用关系，构建他者信赖关系</h1><p>信用关系基于抵押或条件。</p><p>只有我们毫不怀疑人际关系基础，选择了无条件的他者信赖，才可以构筑更加深厚的关系。</p><p><strong>你现在一味担心“被背叛”，也只关注因此受到的伤痛。但是，如果不敢去信赖别人，那最终就会与任何人都建立不了深厚的关系。</strong></p><p>如果关系浅，破裂时的痛苦就会小，但这种关系在生活中产生的喜悦也小。只有拿出通过“他者信赖”进一步加深关系的勇气之后，人际关系的喜悦才会增加，人生的喜悦也会随之增加。</p><p>要在共同体中找到归属感，就必须把他人看做伙伴，而要做到视他人为伙伴就<strong>需要自我接纳和他者信赖。</strong></p><h1 id="他者贡献"><a href="#他者贡献" class="headerlink" title="他者贡献"></a>他者贡献</h1><p>正因为对他人给予无条件的信赖并能够视他人为自己的伙伴，才能给做到“他者贡献”；同时，正因为对他人有所贡献，才能够体会到“我对他人有用”进而接受真实的自己，做到“自我接纳”。</p><h1 id="人生和谐"><a href="#人生和谐" class="headerlink" title="人生和谐"></a>人生和谐</h1><blockquote><p>10个人中，1个人批判你，2个人能后成为与你互相接纳一切的好朋友，剩下的7个则两者都不是。缺乏人生和谐的人就会只关注讨厌自己的那个人来判断”世界“。</p></blockquote><p>人际关系不顺利既不是因为口吃也不是因为脸红恐惧症，真正的问题在于无法做到自我接纳、他者信赖和他者贡献，却将焦点聚集到微不足道的一个方面并企图以此来评价整个世界。这就是缺乏人生和谐的错误生活方式。</p><p>“工作狂”也缺乏人生和谐。口吃者是只看事物的一部分便来判断其整体。与此相对，工作狂则是只关注人生特定的侧面。也许他们会辩解：”工作忙，无暇顾及家庭。“但是，这其实是人生的谎言。只不过以工作为借口来逃避其他责任。本来家务、育儿、交友或兴趣应该全部都给予关系，阿德勒不认可任何一方面突出的生活方式。某种意义上说，这是一种不敢正视人生课题的生活方式。</p><hr><h1 id="人生是“现在”这一刹那的连续。我们只能活在“此时此刻”"><a href="#人生是“现在”这一刹那的连续。我们只能活在“此时此刻”" class="headerlink" title="人生是“现在”这一刹那的连续。我们只能活在“此时此刻”"></a>人生是“现在”这一刹那的连续。我们只能活在“此时此刻”</h1><p>如果人生是一条线，那么人生规划就有可能。但是，<strong>我们的人生不是线，只是点的连续。</strong>计划式的人生不是有没有必要，而是根本不可能。</p><p>设定目标并为此努力的人，这些人在人生的<strong>每个瞬间都活在“此时此刻”</strong>。也就是说，不是活在“在路上”的人生之中，而是时常活在“此时此刻”。</p><p>最重要的是此时此刻。否定原因论的时候也否定了关注过去，过去并不存在，过去没有意义。</p><p>自己站在人生剧场舞台上，如果感觉能够看得到过去也能预测到未来，那就证明你没有认真地活在“此时此刻”，而是生活在模糊而微弱的光中。</p><p><strong>人生是连续的刹那，根本不存在过去和未来。你是想要通过关注过去或未来为自己寻找免罪符。过去发生了什么与你的“此时此刻”没有任何关系，未来会如何也不是“此时此刻”要考虑的问题。假如认真地活在“此时此刻”，既看不见后面也看不到前面，才是很自然的事情。</strong></p><p>人生不是因果律的长故事。的确，把人生当做故事是很有趣的事情。但是，在故事的前面部分就能看到“模糊的将来”；并且，人们还会想要按照这个故事去生活。我的人生就是这样，所以我只能照此生活，错不在我而在于过去和环境。这里搬出来的过去无非是一种免罪符，是人生的谎言。</p><p>但是，人生是点的连续、是连续的刹那。如果能够理解这一点，那就不再需要故事。</p><p><strong>生活方式说的是“此时此刻”，是可以按照自己的意志改变的事情。</strong>像直线一样的过去的生活只不过是在你反复下定决心“不做改变”的基础上才貌似成了直线而已。并且，<strong>将来的人生也完全是一张白纸，并未铺好行进的轨道。这里没有故事。聚焦“此时此刻”是认真而谨慎地做好现在能做的事情。</strong></p><h1 id="对决“人生最大的谎言”"><a href="#对决“人生最大的谎言”" class="headerlink" title="对决“人生最大的谎言”"></a>对决“人生最大的谎言”</h1><blockquote><p><strong>虽然想上大学但却不想学习，这就是没有认真过好”此时此刻“的态度。</strong>当然，考试也许是很久以后的事情，也不知道该学到什么程度，所以也许会感到麻烦。但是，<strong>每天进步一点点也可以，</strong>解开一个算式或者记住一个单词都可以。<strong>也就是要不停地跳舞。如此一来，势必会有”今天能够做到的事情。“今天这一天就为此存在，而不是为遥远的将来的考试而存在。</strong></p></blockquote><p>为遥远的将来设定一个目标，并认为现在是其准备阶段。一直想着“真正想做的是这样的事情，等时机到了就去做”，是一种拖延人生的生活方式。只要在拖延人生，我们就会无所进展，只能每天过着枯燥乏味的单调生活。因为在这种情况下，人们就会认为“此时此刻”只是准备阶段和忍耐阶段。但是，<strong>为了遥远将来的考试而努力学习的“此时此刻”却是真实的存在。</strong></p><p>过好此时此刻，不去设定根本不存在的线。</p><p>站在现实性角度的时候，人生总是处于完结状态。</p><p><strong>人生最大的谎言就是不活在“此时此刻”。纠结过去，关注未来，把微弱而模糊的光打向人生整体，自认为看到些什么。你之前就一直忽略“此时此刻”，只关注根本就不存在的过去和未来。对自己的人生和无可替代的刹那撒了一个大大的谎言。</strong></p><p>甩开人生的谎言，毫不畏惧地把强烈的聚光灯打向“此时此刻”。<strong>因为过去和未来根本不存在，所以才要谈现在。起决定作用的</strong>既不是昨天也不是明天，而<strong>是“此时此刻”。</strong></p><h1 id="人生的意义，由你自己决定"><a href="#人生的意义，由你自己决定" class="headerlink" title="人生的意义，由你自己决定"></a>人生的意义，由你自己决定</h1><blockquote><p>把你已经带到了水边，是否喝水就看你的决心了。</p></blockquote><p>放弃”不做改变“的决心，选择新的生活方式。</p><p>并不存在可以作为常识来讲的普遍性的人生意义，人生意义是自己赋予自己的。</p><p><strong>如果“我”改变，“世界”就会改变。</strong>世界不是靠他人改变而只能靠“我”来改变，我之外的任何人都不会为我改变世界。</p><p>必须有人开始。即使别人不合作，那也与你无关。我的意见就是这样。<strong>应该由你开始，不去考虑别人是否合作。</strong></p><p><strong>“此时此刻”</strong>正散发着耀眼的光芒，那种光强烈到根本看不到明天之类的事情。</p><hr><h1 id="书摘"><a href="#书摘" class="headerlink" title="书摘"></a>书摘</h1><ul><li><p>人并不是住在客观的世界，而是住在自己营造的主观世界里。</p></li><li><p>任何经历本身并不是成功或者失败的原因。我们并非因为自身经历中的刺激——所谓的心理创伤——而痛苦，事实上我们会从经历中发现符合自己目的的因素。决定我们自身的不是过去的经历，而是我们自己赋予经历的意义。</p></li><li><p>我们给过去的经历“赋予了什么样的意义”，这直接决定了我们的生活。人生不是由别人赋予的，而是由自己选择的，是自己选择自己如何生活。</p></li><li><p>如果你成了原因论的信徒，那就会在过去的束缚之下永远无法获得幸福。</p></li><li><p>问题不在于“发生了什么”，而在于“如何诠释”</p></li><li><p>人并不受过去的原因所左右，而是朝着自己定下的目标前进，这就是哲人的主张。</p></li><li><p>但是，这并不是说你要一直这样下去。如果不能感到幸福的话，就不可以“一直这样”，不可以止步不前，必须不断向前迈进。</p></li><li><p>重要的不是被给予了什么，而是如何去利用被给子的东西。</p></li><li><p>问题不在于过去而在于现在。现在你了解了生活方式。如果是这样的话，接下来的行为就是你自己的责任了。无论是继续选择与之前一样的生活方式还是重新选择新的生活方式，那都在于你自己。</p></li><li><p>人无论在何时也无论处于何种环境中都可以改变。你之所以无法改变，是因为自己下了“不改变”的决心。</p></li><li><p>阿德勒心理学就是勇气心理学。你之所以不幸并不是因为过去或者环境，更不是因为能力不足，你只不过是缺乏“勇气”，可以说是缺乏“获得幸福的勇气”。</p></li><li><p>应该去做——这一简单的课题摆在面前，但却不断地扯出各种“不能做的理由”，你难道不认为这是一种很痛苦的生活方式吗？梦想着做小说家的他，正是“自己”把人生变得复杂继而难以获得幸福。</p></li><li><p>阿德勒的目的论是说：“无论之前的人生发生过什么，都对今后的人生如何度过没有影响。”决定自己人生的是活在“此时此刻”的你自己。</p></li><li><p>你由于太惧怕人际关系所以才会变得讨厌自己，你是在通过自我厌弃来逃避人际关系。</p></li><li><p>我们无法改变客观事实，但可以任意改变主观解释。并且，我们都活在主观世界中。</p></li><li><p>我们应该摈弃自卑感，进一步向前；不满足于现状，不断进步；要更加幸福。如果是这样的自卑感，那就没有任何问题。　但是，有些人无法认清“情况可以通过现实的努力而改变”这一事实，根本没有向前迈进的勇气。他们什么都不做就断定自己不行或是现实无法改变。</p></li><li><p>哲人：虽然苦于强烈的自卑感，但却没有勇气通过努力或成长之类的健全手段去进行改变。即便如此，又没法忍受“因为有A所以才做不到B”之类的自卑情结，无法接受“无能的自己”。如此一来，人就会想要用更加简便的方法来进行补偿。　青年：怎么做呢？　哲人：表现得好像自己很优秀，继而沉浸在一种虚假的优越感之中。　青年：虚假的优越感？　哲人：一个很常见的例子就是“权势张扬”。　青年：那是什么呢？　哲人：例如大力宣扬自己是权力者——可以是班组领导，也可以是知名人士，其实就是在通过此种方式来显示自己是一种特别的存在。虚报履历或者过度追逐名牌服饰等也属于一种权势张扬、具有优越情结的特点。这些情况都属于“我”原本并不优秀或者并不特别。而通过把“我”和权势相结合，似乎显得“我”很优秀。这也就是“虚假优越感”。　青年：其根源在于怀有强烈的自卑感吧？</p></li><li><p>刚开始提到的那些闭门不出者就常常沉浸在以不幸为武器的优越感中。阿德勒甚至指出：“在我们的文化中，弱势其实非常强大而且具有特权。”</p></li><li><p>如果从距离和深度这一观点来考虑的话，工作上的人际关系可以说门槛最低。工作上的人际关系因为有着成果这一简单易懂的共通目标，即使有些不投缘也可以合作或者说必须合作；而且，因”工作“这一点结成的关系，在下班或者转行后就又可以变回他人关系。</p></li><li><p>很多人认为朋友越多越好，但果真如此吗？朋友或熟人的数量没有任何价值。这是与爱之主题有关的话题，我们应该考虑的是关系的距离和深度。</p></li><li><p>只要你变了，周围也会改变。必须要有所改变。阿德勒心理学不是改变他人的心理学，而是追求自我改变的心理学。不能等着别人发生变化，也不要等着状况有所改变，而是由你自己勇敢迈出第一步。</p></li><li><p>当人能够感觉到”与这个人在一起可以无拘无束“的时候，才能够体会到爱。既没有自卑感也不必炫耀优越性，能够保持一种平静而自然的状态。真正的爱应该是这样的。</p></li><li><p>当人能够感觉到”与这个人在一起可以无拘无束“的时候，才能够体会到爱。既没有自卑感也不必炫耀优越性，能够保持一种平静而自然的状态。真正的爱应该是这样的。　另一方面，束缚是想要支配对方的表现，也是一种基于不信任感的想法。与一个不信任自己的人处在同一个空间里，那就根本不可能保持一种自然状态。</p></li><li><p>阿德勒把这种企图设立种种借口来回避人生课题的情况叫作”人生谎言‘。　青年：……　哲人：这词很犀利吧。对于自己目前所处的状态，把责任转嫁给别人，通过归咎于他人或者环境来回避人生课题。</p></li><li><p>决定你的生活方式（人生状态）的不是其他任何人，而是你自己这一事实。</p></li><li><p>我们人类并不是会受原因论所说的精神创伤所摆弄的脆弱存在。从目的论的角度来讲，我们是用自己的手来选择自己的人生和生活方式。我们有这种力量。</p></li><li><p>根本没必要被别人认可，也不要去寻求认可。这一点必须事先强调一下。</p></li><li><p>如果做了恰当的事情就能够得到表扬，而如果做了不恰当的事情就会受到惩罚。阿德勒严厉批判这种赏罚式的教育。在赏罚式教育之下会产生这样一种错误的生活方式，那就是“如果没人表扬，我就不去做好事”或者是“如果没人惩罚，我也做坏事”。是先有了希望获得表扬这个目的，所以才去捡垃圾。并且，如果不能够得到任何人的表扬，那就会很愤慨或者是下决心再也不做这样的事情。很明显，这是一种不正常的想法。</p></li><li><p>如果一味寻求别人的认可、在意别人的评价，那最终就会活在别人的人生中。</p></li><li><p>“倘若自己都不为自己活出自己的人生，那还有谁会为自己而活呢？”你就活在自己的人生中。要说为谁活着，那当然是为你自己。假如你不为自己而活的话，那谁会为你而活呢？我们最终还是为自己活着。没理由不可以这样想。</p></li><li><p>于希望得到别人的认可，就会按照别人的期待去生活。也就是舍弃真正的自我，活在别人的人生之中。而且，请你记住，假如说你“不是为了满足他人的期待而活”，那他人也“不是为了满足你的期待而活”。当别人的行为不符合自己的想法的时候也不可以发怒。这也是理所当然的事情。</p></li><li><p>过于希望得到别人的认可，就会按照别人的期待去生活。也就是舍弃真正的自我，活在别人的人生之中。而且，请你记住，假如说你“不是为了满足他人的期待而活”，那他人也“不是为了满足你的期待而活”。当别人的行为不符合自己的想法的时候也不可以发怒。这也是理所当然的事情。</p></li><li><p>事实上，来接受心理咨询辅导的人几乎没有任性者。反而很多人是苦恼于要满足别人的期待、满足父母或老师的期待，无法按照自己的想法去生活。</p></li><li><p>在了解孩子干什各的基础上对其加以守护。如果就学习而言，告诉孩子这是他自己的课题，在他想学习的时候父母要随时准备给予帮助，但绝不对孩子的课题妄加干涉。在孩子没有向你求助的时候不可以指手画脚。</p></li><li><p>辅导顾问要竭尽全力地加以援助，但不可以妄加干涉。某个国家有这么一句谚语：可以把马带到水边，但不能强迫其喝水。阿德勒心理学中的心理咨询辅导以及对别人的一切援助都遵循这个要求。倘若无视本人的意愿而强迫其“改变”，那结果只会是日后产生更加强烈的反作用。</p></li><li><p>干涉甚至担负起别人的课题这会让自己的人生沉重而痛苦。如果你正在为自己的人生而苦恼——这种苦恼源于人际关系——那首先请弄清楚“这不是自己的课题”这一界限；然后，请丢开别人的课题。这是减轻人生负担，使其变得简单的第一步。</p></li><li><p>信任这一行为也需要进行课题分离。信任别人，这是你的课题。但是，如何对待你的信任，那就是对方的课题了。如果不分清界限而是把自己的希望强加给别人的话，那就变成粗暴的“干涉”了。</p></li><li><p>关于自己的人生你能够做的就只有“选择自己认为最好的道路”。另一方面，别人如何评价你的选择，那是别人的课题，你根本无法左右。</p></li><li><p>人为什么会如此在意别人的视线呢？阿德勒心理学给出的答案非常简单，那就是因为你还不会进行课题分离。把原本应该是别人的课题也看成是自己的课题。</p></li><li><p>如果生气的话，就根本无法冷静思考。认为“因为有那样一个上司，所以无法好好工作”，这完全是原因论。请不要这样想，而是要反过来这样看：“因为不想工作，所以才制造出一个讨厌的上司。”或者认为：“因为不愿意接受无能的自己，所以才制造出一个无能的上司。”这就成了目的论式的想法。</p></li><li><p>那么，假如你会进行课题分离又会如何呢？也就是说，无论上司怎么蛮不讲理地乱发脾气，那都不是“我”的课题。毫不讲理这件事情是上司自己应该处理的课题，既没必要去讨好，也没必要委曲求全，我应该做的就是诚实面对自己的人生、正确处理自己的课题。如果你能够这样去理解，事情就会截然不同了。</p></li><li><p>首先要思考一下“这是谁的课题”。然后进行课题分离——哪些是自己的课题，哪些是别人的课题，要冷静地划清界限。而且，不去干涉别人的课题也不让别人干涉自己的课题这就是阿德勒心理学给出的具体而且有可能彻底改变人际关系烦恼的具有划时代意义的观点。</p></li><li><p>如果距离太近，贴在一起，那就无法与对方正面对话。　虽说如此，但距离也不可以太远。父母如果一味训斥孩子，心就会疏远。如果这样的话，孩子甚至都不愿与父母商量，父母也不能提供适当的援助。伸伸手即可触及，但又不踏入对方领域，保持这种适度距离非常重要。</p></li><li><p>如果人际关系中有“回报思想”存在，那就会产生“因为我为你做了这些，所以你就应该给予相应回报”这样的想法。当然，这是一种与课题分离相悖的思想。我们既不可以寻求回报，也不可以受其束缚。</p></li><li><p>而且，反复干涉的结果会是孩子什么也学不到，最终还会失去面对人生课题的勇气。阿德勒说：“没有学会直面困难的孩子最终会想要逃避一切困难。”</p></li><li><p>阿德勒心理学中有反常识的方面：否定原因论、否定精神创伤、采取目的论；认为人的烦恼全都是关于人际关系的烦恼；此外，不寻求认可或者课题分离也全都是反常识的理论。</p></li><li><p>为了满足别人的期望而活以及把自己的人生托付给别人，这是一种对自己撒谎也不断对周围人撒谎的生活方式。</p></li><li><p>选择了不自由生活方式的大人看着自由活在当下的年轻人就会批判其“享乐主义”。当然，这其实是为了让自己接受不自由生活而捏造出的一种人生谎言。选择了真正自由的大人就不会说这样的话，相反还会鼓励年轻人要勇于争取自由。</p></li><li><p>真正的自由是一种把滚落下来的自己从下面向上推的态度。</p></li><li><p>石块无力。一旦开始从斜坡上滚落，就一直会按照重力或惯性等自然法则不停滚动。但是，我们并不是石块，是能够抵抗倾向性的存在，可以让滚落的自己停下来并重新爬上斜坡。也许认可欲求是自然性的欲望。那么，难道为了获得别人的认可就要一直从斜坡上滚落下去吗？难道要像滚落的石头一样不断磨损自己，直至失去形状变成浑圆吗？这样产生的球体能叫“真正的自我”吗？根本不可能！</p></li><li><p>“自由就是被别人讨厌”</p></li><li><p>是你被某人讨厌。这是你行使自由以及活得自由的证据，也是你按照自我方针生活的表现。</p></li><li><p>哲人：也就是说“自由就是被别人讨厌”。　青年：什、什么？！　哲人：是你被某人讨厌。这是你行使自由以及活得自由的证据，也是你按照自我方针生活的表现。　青年：哎、哎呀，但是　哲人：的确，招人讨厌是件痛苦的事情。如果可能的话，我们都想毫不讨人嫌地活着，想要尽力满足自己的认可欲求。但是，八面玲珑地讨好所有人的生活方式是一种极其不自由的生活方式，同时也是不可能实现的事情。　如果想要行使自由，那就需要付出代价。而在人际关系中，自由的代价就是被别人讨厌。</p></li><li><p>毫不在意别人的评价、不害怕被别人讨厌、不追求被他人认可，如果不付出以上这些代价，那就无法贯彻自己的生活方式，也就是不能获得自由。</p></li><li><p>哲人：我是说不要害怕被人讨厌。　青年：但是，那……　哲人：并不是说要去故意惹人讨厌或者是去作恶。这一点请不要误解。</p></li><li><p>不畏惧被人讨厌而是勇往直前，不随波逐流而是激流勇进，这才是对人而言的自由。如果在我面前有“被所有人喜欢的人生”和“有人讨厌自己的人生”这两个选择让我选的话，我一定会毫不犹豫地选择后者。比起别人如何看自己，我更关心自己过得如何。也就是想要自由地生活。</p></li><li><p>获得幸福的勇气也包括“被讨厌的勇气”。一旦拥有了这种勇气，你的人际关系也会一下子变得轻松起来。</p></li><li><p>我改变了，发生变化的只是“我”。作为结果，对方会怎样我不知道，也无法左右，这也是课题分离。当然，随着我的变化——不是通过我的变化——对方也会发生改变。也许很多情况下对方不得不改变，但那不是目的，而且也可能不会发生。总之，把改变自己当成操纵他人的手段是一种极其错误的想法。</p></li><li><p>只做“把马带到水边”的努力，是否喝水是那个人的课题。</p></li><li><p>要想缔结良好的人际关系，需要保持一定距离：太过亲密就无法正面对话。但是，距离也不可以太远。“课题分离不是为了疏远他人，而是为了解开错综复杂的人际关系之线。</p></li><li><p>人际关系并不止于课题分离。相反，分离课题是人际关系的出发点。</p></li><li><p>不能进行“课题分离”、一味拘泥于认可欲求的人也是极其以自我为中心的人。</p></li><li><p>请你考虑一下认可欲求的实质——他人如何关注自己、如何评价自己？又在多大程度上满足自己的欲求？受这种认可欲求束缚的人看似在看着他人，但实际上眼里却只有自己。失去了对他人的关心而只关心“我”，也就是以自我为中心。</p></li><li><p>就是直面”人生课题“。也就是不回避工作、交友、爱之类的人际关系课题，要积极主动地去面对。如果你认为自己就是世界的中心，那就丝毫不会主动融入共同体中，因为一切他人都是”为我服务的人“，根本没必要由自己采取行动。</p></li><li><p>当我们在人际关系中遇到困难或者看不到出口的时候，首先应该考虑的是”倾听更大共同体的声音“这一原则。</p></li><li><p>不可以批评也不可以表扬，这就是阿德勒心理学的立场。</p></li><li><p>阿德勒心理学之所以强烈否定赏罚教育，就因为它是为了操纵孩子。</p></li><li><p>自卑感原本就是从纵向关系中产生的一种意识。　只要能够对所有人都建立起”虽不同但平等“的横向关系，那就根本不会产生自卑情结。</p></li><li><p>人为什么会去干涉别人呢？其背后实际上也是一种纵向关系。正因为把人际关系看成纵向关系、把对方看得比自己低，所以才会　去干涉。希望通过干涉行为把对方导向自己希望的方向。这是坚信自己正确而对方错误。</p></li><li><p>如果眼前有一个非常苦恼的人，那总不能置之不理吧？这种情况也可以说一句”我若插手那就是干涉“而什么也不做吗？　哲人：不可以置之不问。需要做一些不是干涉的”援助“。</p></li><li><p>援助的大前提是课题分离和横向关系。在理解了学习是孩子的课题这个基础上再去考虑能做的事情，具体就是不去居高临下地命令其学习，而是努力地帮助他本人建立”自己能够学习“的自信以及提高其独立应对课题的能力。</p></li><li><p>而是在课题分离的前提下帮助他用自己的力量去解决，也就是”可以把马带到水边，但不能强迫其喝水“。直面课题的是其本人，下定决心的也是其本人。</p></li><li><p>既不表扬也不批评。阿德勒心理学把这种基于横向关系的援助称为”鼓励“。</p></li><li><p>人害怕面对课题并不是因为没有能力。阿德勒心理学认为这不是能力问题，纯粹是”缺乏直面课题的‘勇气’“。如果是这样的话，那就首先应该找回受挫的勇气。</p></li><li><p>首先应该进行课题分离，然后应该在接受双方差异的同时建立平等的横向关系。”鼓励“则是这种基础之上的一种方法。</p></li><li><p>最重要的是不”评价“他人，评价性的语言是基于纵向关系的语言。如果能够建立起横向关系，那自然就会说出一些更加真诚地表示感谢、尊敬或者喜悦的话。</p></li><li><p>人只有在能够感觉自己有价值的时候才可以获得勇气。</p></li><li><p>通过为共同体也就是他人服务能够体会到”我对别人有用“，不是被别人评价说”很好“，而是主观上就能够认为”我能够对他人做出贡献“，只有这样我们才能够真正体会到自己的价值。</p></li><li><p>不能够表扬，也不可以批评。评价别人的话全都出于”纵向关系“，而我们必须建立起”横向关系“。还有，我们只有能够感觉自己对别人有用的时候才能体会到自己的价值……</p></li><li><p>自我肯定是明明做不到但还是暗示自己说”我能行“或者”我很强“，也可以说是一种容易导致优越情结的想法，是对自己撒谎的生活方式。　而另一方面，自我接纳是指假如做不到就诚实地接受这个”做不到的自己“，然后尽量朝着能够做到的方向去努力，不对自己撒谎。</p></li><li><p>我们无法改变”被给予了什么“。但是，关于”如何去利用被给予的东西“，我们却可以用自己的力量去改变。这就是不去关注”无法改变的“，而是去关注”可以改变的‘这就是我所说的自我接纳。</p></li><li><p>只有我们选择了无条件的信赖，才可以构筑更加深厚的关系。</p></li><li><p>现在认为“无条件地信赖别人只会遭到背叛”。但是，决定背不背叛的不是你，那是他人的课题。你只需要考虑“我该怎么做”。“如果对方讲信用我也给予信任”，这只不过是一种基于抵押或条件的信用关系。</p></li><li><p>如果你并不想与那个人搞好关系的话，也可以用手中的剪刀彻底剪断关系，因为剪断关系是你自己的课题。</p></li><li><p>青年：那么，假设我为了和朋友搞好关系，给予了对方无条件的信赖。为朋友四处奔走，不计回报地慷慨解囊，总之就是费时又费力。即使如此依然会遭到背叛。怎么样呢？如果遭到如此信赖的朋友的背叛，那一定会导致“他者即敌人”的生活方式。不是这样吗？　哲人：你好像还没能理解信赖的目的。例如，假设你在恋爱关系中怀疑“她可能不专一”。并且还积极寻找对方不专一的证据。你认为结果会怎样呢？　青年：哎呀，这种事要看情况而定。　哲人：不，任何情况都会发现像山一样的不专一证据。　青年：啊？为什么？　哲人：对方无意的言行、与别人通电话时的语气、联系不上的时间……如果用怀疑的眼光去看，所有的事情看上去都会成为“不专一的证据”，哪怕事实并非如此。　青年：嗯。　哲人：你现在一味地担心“被背叛”，也只关注因此受到的伤痛。但是，如果不敢去信赖别人，那最终就会与任何人都建立不了深厚的关系。　青年：哎呀，我明白您的意思。建立深厚关系是信赖的重大目标。但是，害怕被别人背叛也是一种无法克服的事实吧？　哲人：如果关系浅，破裂时的痛苦就会小，但这种关系在生活中产生的喜悦也小。只有拿出通过“他者信赖”进一步加深关系的勇气之后，人际关系的喜悦才会增加，人生的喜悦也会随之增加。</p></li><li><p>只要能够接受真实的自己并看清“自己能做到的”和“自己做不到的”，也就可以理解背叛是他人的课题，继而也就不难迈出迈向他者信赖的步伐了。</p></li><li><p>青年：您是说是否背叛是他人的课题，不是自己所能左右的事情？要做到肯定性的达观？先生的主张总是忽视感情！遭到背叛时的怒气和悲伤又该怎么办呢？　哲人：悲伤的时候尽管悲伤就可以。因为，正是想要逃避痛苦或悲伤才不敢付渚行动，以至于与任何人都无法建立起深厚的关系。　请你这样想。我们可以相信也可以怀疑；并且，我们的目标是把别人当作朋友。如此一来，是该选择信任还是怀疑，答案就非常明显了。</p></li><li><p>首先，真诚地接受不能交换的“这个我”，这就是自我接纳。同时，对他人寄予无条件的信赖即他者信赖。</p></li><li><p>要想获得归属感就必须把他人看作伙伴，而要做到视他人为伙伴就需要自我接纳和他者信赖。</p></li><li><p>为了方便起见，前面我一直按照自我接纳、他者信赖、他者贡献这种顺序来进行说明。但是，这三者是缺一不可的整体。　正因为接受了真实的自我——也就是“自我接纳”——才能够不惧背叛地做到“他者信赖”；而且，正因为对他人给予无条件的信赖并能够视他人为自己的伙伴，才能够做到“他者贡献”；同时，正因为对他人有所贡献，才能够体会到“我对他人有用”进而接受真实的自己，做到“自我接纳”</p></li><li><p>可以迷路也可以走偏，只要不再从属于纵向关系，不畏惧惹人讨厌地自由前行就可以。</p></li><li><p>任何情况下都只是攻击我的“那个人”有问题，而绝不是“大家”的错。</p></li><li><p>人际关系不顺利既不是因为口吃也不是因为脸红恐惧症，真正的问题在于无法做到自我接纳、他者信赖和他者贡献，却将焦点聚集到微不足道的一个方面并企图以此来评价整个世界。这就是缺乏人生和谐的错误生活方式。</p></li><li><p>判断你的贡献是否起作用的不是你，那是他人的课题，是你无法干涉的问题。是否真正作出了贡献，从原理上根本无从了解。也就是说，进行他者贡献时候的我们即使作出看不见的贡献，只要能够产生“我对他人有用”的主观感觉即“贡献感”也可以。</p></li><li><p>如果能够真正拥有贡献感，那就不再需要他人的认可。因为即使不特意去寻求他人的认可，也可以体会到“我对他人有用”。也就是说，受认可欲求束缚的人不具有共同体感觉，还不能做到自我接纳、他者信赖和他者贡献。</p></li><li><p>不了解这一点的大人们总是想要强迫年轻人过“线”一样的人生。在他们看来，上好大学、进好企业、拥有稳定的家庭，这样的轨道才是幸福的人生。但是，人生不可能是一条线。</p></li><li><p>如果人生是一条线，那么人生规划就有可能。但是，我们的人生只是点的连续。计划式的人生不是有没有必要，而是根本不可能。</p></li><li><p>哲人：请你想象一下自己站在剧场舞台上的样子。此时，如果整个会场都开着灯，那就可以看到观众席的最里边。但是，如果强烈的聚光灯打向自己，那就连最前排也看不见。　我们的人生也完全一样。正因为把模糊而微弱的光打向人生整体，所以才能够看到过去和未来；不，是感觉能够看得到。但是，如果把强烈的聚光灯对准“此时此刻”，那就会既看不到过去也看不到未来。　青年：强烈的聚光灯？　哲人：是的。我们应该更加认真地过好“此时此刻”。如果感觉能够看得到过去也能预测到未来，那就证明你没有认真地活在“此时此刻”，而是生活在模糊而微弱的光中。　人生是连续的刹那，根本不存在过去和未来。你是想要通过关注过去或未来为自己寻找免罪符。过去发生了什么与你的“此时此刻”没有任何关系，未来会如何也不是“此时此刻”要考虑的问题。假如认真地活在“此时此刻”，那就根木不会说出那样的话。</p></li><li><p>哲人：如果站在弗洛伊德式原因论的立场上，那就会把人生理解为基于因果律的一个长故事。何时何地出生、度过了什么样的童年时代、从什么样的学校毕业、进了什么样的公司，正是这些因素决定了现在的我和将来的我。　的确，把人生当作故事是很有趣的事情。但是，在故事的前面部分就能看到“模糊的将来”；并且，人们还会想要按照这个故事去生活。我的人生就是这样，所以我只能照此生活，错不在我而在于过去和环境。这里搬出来的过去无非是一种免罪符，是人生的谎言。　但是，人生是点的连续、是连续的刹那。如果能够理解这一点，那就不再需要故事。</p></li><li><p>生活方式说的是“此时此刻”，是可以按照自己意志改变的事情。像直线一样的过去的生活只不过是在你反复下定决心“不做改变”的基础上才貌似成了直线而己。并且，将来的人生也完全是一张白纸，并未铺好行进的轨道。这里没有故事。</p></li><li><p>聚焦“此时此刻”是认真而谨慎地做好现在能做的事情。</p></li><li><p>青年：认真而谨慎地生活？　哲人：例如，虽然想上大学但却不想学习，这就是没有认真过好“此时此刻”的态度。当然，考试也许是很久之后的事情，也不知道该学到什么程度，所以也许会感到麻烦。但是，每天进步一点点也可以，解开一个算式或者记住一个单词都可以。也就是要不停地跳舞。如此一来，势必会有“今天能够做到的事情”。今天这一天就为此存在，而不是为遥远的将来的考试而存在。</p></li><li><p>为遥远的将来设定一个目标，并认为现在是其准备阶段。一直想着“真正想做的是这样的事情，等时机到了就去做”，是一种拖延人生的生活方式。只要在拖延人生，我们就会无所进展，只能每天过着枯燥乏味的单调生活。因为在这种情况下，人就会认为“此时此刻”只是准备阶段和忍耐阶段。</p></li><li><p>为遥远的将来设定一个目标，并认为现在是其准备阶段。一直想着“真正想做的是这样的事情，等时机到了就去做”，是一种拖延人生的生活方式。只要在拖延人生，我们就会无所进展，只能每天过着枯燥乏味的单调生活。因为在这种情况下，人就会认为“此时此刻”只是准备阶段和忍耐阶段。　但是，为了遥远将来的考试而努力学习的“此时此刻”却是真实的存在。</p></li><li><p>人生很简单，并不是什么深刻的事情。如果认真过好了每一个刹那，就没有什么必要令其过于深刻。</p></li><li><p>站在现实性角度的时候，人生总是处于完结状态。</p></li><li><p>人生中最大的谎言就是不活在“此时此刻”。纠结过去、关注未来，把微弱而模糊的光打向人生整体，自认为看到了些什么。你之前就一直忽略“此时此刻”，只关注根本不存在的过去和未来。对自己的人生和无可替代的刹那撒了一个大大的谎言。</p></li><li><p>甩开人生的谎言，毫不畏惧地把强烈的聚光灯打向“此时此刻”。</p></li><li><p>因为过去和未来根本不存在，所以才要谈现在。起决定作用的既不是昨天也不是明天，而是“此时此刻”。</p></li><li><p>放弃“不做改变”的决心，选择新的生活方式</p></li><li><p>哲人：所以阿德勒在说了“并不存在普遍性的人生意义”之后还说：“人生意义是自己赋予自己的。”</p></li><li><p>我们要像跳舞一样认真过好作为刹那的“此时此刻”，既不看过去也不看未来，只需要过好每一个完结的刹那。没必要与谁竞争，也不需要目的地，只要跳着，就一定会到达某一个地方。</p></li><li><p>如果“我”改变，“世界”就会改变。世界不是靠他人改变而只能靠“我”来改变。</p></li><li><p>“必须有人开始。即使别人不合作，那也与你无关。我的意见就是这样。应该由你开始，不用去考虑别人是否合作。”</p></li><li><p>耀眼的光芒！”是的，那种光强烈到根本看不到明天之类的事情。</p></li><li><p>“世界很简单，人生也是一样！”</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Growth </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reading List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch学习资料</title>
      <link href="/2021/01/08/python/ml/pytorch-xue-xi-zi-liao/"/>
      <url>/2021/01/08/python/ml/pytorch-xue-xi-zi-liao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://space.bilibili.com/88461692/channel/detail?cid=26587" target="_blank" rel="noopener">3Blue1Brown深度学习专题</a></p><blockquote><p>☆☆☆☆☆<br>讲解深度学习内在过程 </p></blockquote><hr><p><a href="https://www.youtube.com/playlist?list=PLZbbT5o_s2xrfNyHZsM6ufI0iZENK9xgG" target="_blank" rel="noopener">Neural Network Programming - Deep Learning with PyTorch</a></p><blockquote><p>☆☆☆☆☆<br>超棒的教学视频，把底层原理到实现的具体过程讲得通俗易懂</p></blockquote><hr><p><a href="https://github.com/yunjey/pytorch-tutorial" target="_blank" rel="noopener">Pytorch-tutorial</a></p><blockquote><p>一个韩国小哥哥写的<strong>非常精炼</strong>的Pytorch教程，大部分模型用30行代码完成</p></blockquote><hr><p>PyTorch Zero To All</p><ul><li><a href="https://www.youtube.com/watch?v=SKq-pmkekTk" target="_blank" rel="noopener">Youtube视频教程</a></li><li><a href="https://github.com/hunkim/PyTorchZeroToAll" target="_blank" rel="noopener">github配套代码</a></li></ul><blockquote><p>一个韩国小哥哥的教程，教学视频讲得很形象</p></blockquote><hr><p><a href="https://github.com/zergtant/pytorch-handbook" target="_blank" rel="noopener">pytorch-handbook</a></p><blockquote><p> 比较详细的Pytorch中文教程，从官方的60分钟入门简介到神经网络再到应用均进行了介绍</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读“非暴力沟通”</title>
      <link href="/2020/11/26/growth/du-fei-bao-li-gou-tong/"/>
      <url>/2020/11/26/growth/du-fei-bao-li-gou-tong/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=8OkBpX1Tfgo&t=80s" target="_blank" rel="noopener">视频解读1：读《非暴力沟通》</a></p><p><a href="https://www.youtube.com/watch?v=IZ_ibVcClUw" target="_blank" rel="noopener">视频解读2：为什么我们开始拒绝与父母交流？</a></p><p><img src="https://i.loli.net/2021/02/26/inLpFAJSUdX4vxP.png" alt></p><ul><li>描述<strong>事实</strong><ul><li>不带主观评价；不要言过其实；一次只说一件事；不要推测对方意图</li></ul></li><li>表达<strong>感受</strong>和<strong>需要</strong><ul><li>情绪源于自身；第一人称描述（<strong>我感到…,因为我…</strong>）；示弱来解决冲突</li></ul></li><li>提出<strong>请求</strong><ul><li>从正面说；请求要具体</li><li><strong>请求不是命令，若无法满足请求，应了解原因和对方的感受，并给予尊重和理解</strong></li><li>愤怒背后其实是需求，应该根据需求提出我们的请求 愤怒-&gt;需求-&gt;请求 （观察，感受，需要，请求）</li></ul></li><li><strong>爱自己</strong><ul><li><strong>如果我们指责的那个人恰好是我们自己，那么，言下之意是：“我的行为不符合我的需要。”</strong> 如果我们专注于<strong>需要是否得到满足以及得到怎样的满足</strong>，我们就更有可能从自我评价中获益。</li></ul></li><li>充分表达愤怒<ul><li><strong>注意力放在自己的感受和需要上；直接说出我们的需要</strong></li><li>表达愤怒的四个步骤是：（1）停下来，除了呼吸，什么都别做；（2）想一想是什么想法使我们生气了；（3）体会自己的需要；（4）表达感受和尚未满足的需要。有时，<strong>在第3步和第4步之间，我们需要先倾听他人。在得到倾听和理解之后，他们也就可以静下心来体会我们的感受和需要</strong></li><li>给自己充分的时间来学习和运用非暴力沟通</li></ul></li></ul><h1 id="描述事实"><a href="#描述事实" class="headerlink" title="描述事实"></a>描述事实</h1><p>非暴力沟通的第一个要素是<strong>观察</strong>。将观察和评论混为一谈，别人就会倾向于听到批评，并反驳我们。非暴力沟通是动态的语言，不主张绝对化的结论。它提倡在特定的时间和情境中进行观察，并清楚地描述观察结果。</p><p>也可以进行<strong>反向思维</strong>。在与别人沟通时，不管是对方让你说了舒服还是不舒服的话，了解他的<strong>观察、感受、需要和请求</strong>后，我问自己是否愿意满足他的请求。</p><h1 id="表达感受"><a href="#表达感受" class="headerlink" title="表达感受"></a>表达感受</h1><p>为了更好地沟通情感，非暴力沟通主张使用<strong>具体的语言。</strong></p><pre><code>注意区分感受和想法。</code></pre><p>非暴力沟通的第二个要素是<strong>感受</strong>。通过建立表达感受的词汇表，我们可以更清楚地表达感受，从而使沟通更为顺畅。在表达感受时，<strong>示弱有助于解决冲突。</strong></p><h1 id="感受的根源"><a href="#感受的根源" class="headerlink" title="感受的根源"></a>感受的根源</h1><p>听到不中听的话时，我们有四种选择</p><p><del>第一种是认为自己犯了错。例如，有人气愤地说：“我从没见过像你这么自私的人！”这时，我们可能会自责：“哦，我没有考虑别人的感受，真是太自私了！”这会导致我们内疚、惭愧，甚至厌恶自己。</del></p><p><del>第二种是指责对方。这时，我们也许会驳斥对方：“你没有权利这么说！我一直都很在乎你的感受。你才自私！”在争吵时，我们一般会感到恼怒。</del></p><p>第三种是<strong>了解我们的感受和需要</strong>。这时，我们可能会发现我们有些伤心，因为我们看重信任和接纳。</p><p>第四种是<strong>用心体会他人的感受和需要</strong>。这时，我们也许就会想“他伤心可能是因为他需要体贴和支持”。</p><p>通过了解我们的需要、愿望、期待以及想法，我们<strong>不再指责他人，而承认我们的感受源于自身。</strong></p><p>如果我们想利用他人的内疚，我们通常采取的办法是，把自己不愉快的感受归咎于对方。家长也许会和孩子说：“你成绩不好让爸爸妈妈伤透了心！”言下之意是，他们快乐或不快乐是孩子的行为造成的。看到父母的痛苦，孩子可能会感到内疚，并因此调整行为来迎合他们。遗憾的是，<strong>这种调整只是为了避免内疚，而非出自对学习的热爱。</strong></p><p>使用以下表达方式时，我们可能就已经忽视了感受与自身的关系。1）只提及相关的事情。2）只提及他人的行为。3）指责他人。</p><p>我们可以通过     “<strong>我（感到）……因为我……</strong>”     这种表达方式来<strong>认识感受与自身的关系</strong>。</p><p>例如1）“看到公司海报出现拼写错误（事实），我很不高兴（感受）。因为我重视公司的形象（需要）。”2）“你没把饭吃完，妈妈感到失望。因为妈妈希望你能健康成长。”3）“老板说话不算数，我很生气。因为我想有个长假去看弟弟。”</p><blockquote><p>非暴力沟通需要：生命健康成长的要素</p></blockquote><p><strong>批评往往暗含着期待</strong>。对他人的批评实际上间接表达了我们尚未满足的需要。如果我们通过批评来提出主张，人们的反应常常是申辩或反击。反之，如果我们<strong>直接说出需要</strong>，其他人就较有可能作出积极的回应。</p><blockquote><p>从“情感的奴隶”到“生活的主人”</p></blockquote><p>第一阶段：“情感的奴隶”——我们认为自己有义务使他人快乐</p><p>在这个阶段，我们相信自己需要为他人负责——让他人快乐是我们的义务。如果别人不高兴，我们就会感到不安，觉得自己有责任做</p><p>点什么。此时，我们特别容易把亲人看作是负担。</p><p>第二阶段：“面目可憎”——此时，我们拒绝考虑他人的感受和需要</p><p>在这个阶段，我们发现，为他人的情绪负责，牺牲自己迎合他人，代价实在很大。想到日子过得这么憋屈，我们可能会很恼怒。此时，如果遭遇他人的痛苦，我们可能就会无动于衷：“这是你自己的问题！和我有什么关系？！”虽然不再愿意为他人负责，但我们还心存疑虑。因此，我们的态度也就显得生硬。</p><p><strong>第三阶段：“生活的主人”——我们意识到，虽然我们对自己的意愿、感受和行动负有完全的责任，但无法为他人负责。与此同时，我们还认识到，我们无法牺牲他人来满足自己的需要。</strong></p><p>在这个阶段，我们乐于互助。我们帮助他人，是出于爱，而不是出于恐惧、内疚或惭愧。那是自由而快乐的行为。此时，我们意识到，虽然我们对自己的意愿、感受和行动负有完全的责任，但无法为他人负责。我们还发现，人与人相互依存，损人无法真正利己。非暴力沟通正是想帮助我们<strong>既表达自己，又关心他人</strong>。</p><h1 id="请求帮助"><a href="#请求帮助" class="headerlink" title="请求帮助"></a>请求帮助</h1><blockquote><p>提出具体的请求</p></blockquote><p>首先，<strong>清楚地告诉对方，我们希望他们做什么</strong>。如果我们请求他人不做什么，对方也许会感到困惑，不知道我们到底想要什么。而且，这样的请求还容易引起别人的反感。</p><p>我们提出的<strong>请求越具体越好</strong>。如果我们的意思含糊不清，别人就难以了解我们到底想要什么。</p><blockquote><p>明确谈话的目的</p></blockquote><p>如果一个人<strong>提出了明确的请求，却没有提及感受和需要，也有可能导致交流的困难</strong>。例如，如果父母问“为什么还不去理发呢”，孩子一般会把它看作是命令或指责。如果父母想避免误解，那么，他们可以先说出感受和需要：“你的头发这么长，我们担心这会影响你的视线，特别是在骑自行车的时候。去理发好吗？”</p><blockquote><p>请求与命令</p></blockquote><p><strong>如果别人没有满足我们的请求，我们应该了解他们无法做到的原因，理解并尊重他们的感受、需要和立场。（这才是请求，而非命令）</strong></p><p>听到命令时，一个人只能看到两种选择：服从或反抗。不论如何，只要人们认为我们是在强迫他们，他们就不会乐于满足我们的需要。如果我们在过去常常指责他人，那么，我们的请求很可能就会被看作是命令。而一个经常受到指责的人也会倾向于将请求解读为命令。</p><p>如何区分命令和请求：<strong>请求没有得到满足时，提出请求的人如果批评和指责，那就是命令；如果想利用对方的内疚来达到目的，也是命令</strong>。在生活中，如果我们不想勉强人，那么，清楚地表明这一点是重要的——这有助于人们相信我们提出的是请求而非命令。<strong>在人们无法满足我们的愿望时，我们是否尊重他们的感受和需要最能体现我们提出的是请求还是命令</strong>。如果我们愿意去体会是什么使他们无法“是”，那么，根据我的定义，我们提出的就是请求而非命令。</p><p>如果我们有这样的想法，一旦别人没有满足我们的要求，我们难免就会指责他们。有一段时间，当我的小儿子布拉特没有倒垃圾时，我就有类似的想法。我们对家务活进行了分工，他负责倒垃圾。可是，他很不主动。为了让他去倒垃圾，每天我都会提醒他“这是你的任务”或“我们每个人都有自己的任务”。</p><p>后来，有一天晚上，我终于静下心来听他讲为什么他不愿倒垃圾。谈话后，我以《布拉特的心》为题写下了一段话：</p><p>“在印象中，如果我没照你说的去做，你就不会尊重我。如果我知道你并不想使唤我，在你叫我时，我会乐于回应你。如果你高高在上，像个盛气凌人的老板，你将会发现，你一头撞在了墙上。当你反复提醒我，你为我做的各种事情，你最好准备再次碰壁！你可以大声抱怨、责骂，但我仍不会去倒垃圾。即使你现在改变方式，我也需要时间忘记不快。”</p><p>通过这次谈话，布拉特认为我<strong>已经理解并尊重他的立场</strong>。在以后的日子里，他每天都主动倒垃圾。</p><blockquote><p>小结</p></blockquote><p>非暴力沟通的第四个要素是请求。我们告诉人们，为了改善生活，我们希望他们做什么。我们<strong>避免使用抽象的语言，而借助具体的描述</strong>，来提出请求。</p><p>在发言时，我们<strong>将自己想要的回应讲得越清楚，就越有可能得到理想的回应。</strong>由于我们所要表达的意思与别人的理解有可能不一致，有时，我们需要请求他人的反馈。特别是在集体讨论中发言时，我们需要<strong>清楚地表明自己的期待</strong>。否则，讨论可能只是在浪费大家的时间。</p><p>一旦人们认为不答应我们就会受到责罚，他们就会把我们的请求看作是命令。如果我们清楚地表达我们无意强人所难，人们一般会相信，我们提出的是请求而非命令。非暴力沟通的目的不是为了改变他人来迎合我们。相反，非暴力沟通<strong>重视每个人的需要</strong>，它的目的是帮助我们在诚实和倾听的基础上与人联系。</p><ul><li><p>非暴力沟通实例示例—劝好朋友戒烟</p><p>  艾伦和卡特是有30多年交情的老朋友。卡特每天要抽两包烟。多年来，艾伦想尽一切办法来让卡特戒烟，但都没有成功。在过去的几年，卡特咳嗽得越来越厉害。有一天，艾伦终于忍不住和卡特再一次谈到了戒烟。</p><p>  艾伦：“卡特，这个问题我们已经说过无数次了。不过，我还是想告诉你，我很害怕，你这样抽下去，很快就会完蛋！你是我最好的朋友，我不想失去你。请不要认为，我又在指责你。我真的没有。我只是很担心。”（在过去，艾伦在劝卡特戒烟时，常常会指责他。）</p><p>  卡特：“我知道你是在关心我。我们已经是老朋友了……”</p><p>  艾伦：（提出请求）“你愿意戒烟吗？”</p><p>  卡特：“我希望我能做到。”</p><p>  艾伦：（<strong>了解卡特无法做到的原因</strong>）“你不想戒烟，是因为你担心自己做不到吗？”</p><p>  卡特：“是的。你知道我已经戒过很多次了，但都没有成功。我想，别人会觉得我很没用。”</p><p>  艾伦：（猜测卡特会有什么请求）“我没有看轻你。即使你再次戒烟失败，我也不会看不起你。我只是希望你再试一试。”</p><p>  卡特：“谢谢。但又不是只有你一个人……从他们的眼中，我可以看出，他们认为我是个没用的人。”</p><p>  艾伦：（<strong>体会卡特的感受和需要</strong>）“如果不是担心别人的看法，你就会愿意再次戒烟，是吗？”</p><p>  卡特：“我不喜欢自己有烟瘾。我不希望自己听任烟瘾的摆布……”</p><p>  艾伦：（艾伦看着卡特的眼睛，点了点头。艾伦的眼神流露出他对卡特的关心。）</p><p>  卡特：“我的意思是说，我已经不喜欢抽烟了。特别是在公共场合抽烟，我会觉得很不好意思。”</p><p>  艾伦：（<strong>继续体会卡特的感受和需要</strong>）“听起来，你很想戒烟，可又担心会失败——你害怕这会影响到你的形象和信心。”</p><p>  卡特：“是的。我想这就是我的意思……你知道，我以前并没有提到这一点。当人们劝我戒烟时，我就会叫他们走开。我是想戒烟，</p><p>  但我不想任何人给我压力。”</p><p>  卡特：“我真的很感激你的关心。但是，如果我现在还做不到，你会介意吗？”</p><p>  艾伦：“当然不会！我只是希望你的健康状况能变好。”（因为艾伦提出的是真诚的请求，而非要求，不论卡特有怎样的反应，他们</p><p>  的关系都不会受影响。）</p><p>  卡特：“谢谢！也许我会再试一次。但请你先不要告诉别人，好吗？”</p><p>  艾伦：“好的。你放心。我不会和任何人说的。”</p></li></ul><h1 id="爱自己"><a href="#爱自己" class="headerlink" title="爱自己"></a>爱自己</h1><p>经常责备自己、强迫自己将使我们“更像椅子而不像人”。非暴力沟通认为，对他人的指责反映了我们遇到了挫折——他人的行为不符合我们的需要。<strong>如果我们指责的那个人恰好是我们自己，那么，言下之意是：“我的行为不符合我的需要。”</strong>我相信，如果我们专注于<strong>需要是否得到满足以及得到怎样的满足</strong>，我们就更有可能从自我评价中获益。</p><p>一旦发现自己正在做无益的事情，我们的挑战是如何对需要和价值观保持清醒的认识，以使我们的转变：</p><ol><li>符合我们的心愿；</li><li>出于对自己的尊重和爱护，而不是出于自我憎恨、内疚或羞愧。</li></ol><p>非暴力沟通鼓励我们直面人生的苦难：在遇到挫折时，充分体会人生的悲哀和内心的渴望。是的，感到遗憾是难免的。但它能帮助我们从经历中学习，而无须责备自己。我们意识到过去的行为违背了自己的需要及价值观，并允许这种觉察引发的情感充分流淌。<strong>一旦专注于尚未满足的需要，我们就会考虑如何满足它。</strong>反之，如果用苛刻的语言指责自己，我们不仅难以找到解决办法，而且容易陷于自我惩罚的痛苦中。</p><blockquote><p>深入理解我们行为的动机</p></blockquote><p>你在思考“<strong>我选择做<strong><strong>是因为我想</strong></strong></strong>”这个问题时，也许会像我考虑开车送小孩上学时那样，发现自己行为背后的价值取向——你在生活中看重什么。我确信，一旦意识到<strong>我们的行为所服务的需要</strong>，即使工作很艰苦、富有挑战性乃至举步维艰，我们也会从中得到乐趣。</p><p>我们越是投入服务<strong>生命的乐趣中</strong>——服务生命是唯一的目的，我们也就越爱自己。</p><blockquote><p>小结</p></blockquote><p>非暴力沟通最重要的应用也许在于<strong>培育对自己的爱</strong>。当我们的表现不完美时，我们可以通过体会忧伤和自我宽恕，来看清个人成长的方向，以及避免自我惩罚。评价自己的行为时，我们<strong>专注于尚未满足的需要</strong>；这样，我们就不再依赖羞愧、内疚、恼怒或沮丧的心理来寻求改变，而<strong>让爱主导我们的学习和成长</strong>。</p><p>同时，在日常生活中，我们主动根据需要和价值观来选择生活。我们的行为不再是为了履行职责、获得回报、逃避惩罚或避免感到内疚和羞愧。通过<strong>深入理解我们行为的动机，并用“选择做”来取代“不得不”，</strong>我们的生活将变得和谐并充满欢乐。</p><h1 id="充分表达愤怒"><a href="#充分表达愤怒" class="headerlink" title="充分表达愤怒"></a>充分表达愤怒</h1><p>如果真的很生气，我们就需要找到强有力的方式充分表达自己。</p><p>非暴力沟通并<strong>不主张忽视或压抑愤怒</strong>，它认为，通过深入地了解愤怒，我们可以充分表达内心的渴望。</p><blockquote><p>为什么我们会生气？</p></blockquote><p>充分表达愤怒的第一步是我们<strong>不再归咎于他人</strong>。如果我们认为“他让我很生气”，那么，我们难免就会指责他人。然而，实际情况是，<strong>我们心情并不取决于他人的行为。</strong></p><p>假定我们约了个人，时间到了，她却没来。如果彼此的关系处于比较微妙的时期，我们可能会忧心忡忡。如果我们看重的是诚实守信，我们也许会觉得不耐烦。反之，如果我们想休息一会儿，我们可能就不会介意她来晚了。因此，<strong>同一件事情，不同的需要导致不同的感受。</strong>一旦意识到自己的需要——不论是友谊、诚信还是休息，我们<strong>就可以更加体贴自己</strong>。我们可能会有强烈的情绪，但不再生气。可是，如果意识不到自己尚未满足的需要，一心考虑别人的过错，我们难免就会生气。</p><p>除了专注于自身的感受和需要，我们还可以选择去体会对方的感受和需要。此时，我们也不会感到生气。我们无须压抑愤怒，只要我们专注于他人的感受和需要，愤怒也就不再存在。</p><p>愤怒的核心是<strong>尚未满足的需要</strong>。如果我们能够借助它来提醒自己——我们有需要没有得到满足，而我们的思维方式正使它难以得到满足，那愤怒就是有价值的。为了充分表达愤怒，我们有必要明了自己的需要并采取行动。然而，做到这一点并不容易。因为愤怒驱使我们去惩罚他人，而不是去满足需要。为此，我建议，与其沉浸于“合理的愤怒”，不如倾听自己和他人的需要。这也许需要一个过程，但通过不断的实践，我们将会有意识地用“我生气是因为我需要……”来取代“我生气是因为他们……”。</p><p>如果你希望自己在生气的时候也能运用非暴力沟通，我建议你做以下的练习。在前面，我们已经提到，我们生气是因为我们的想法——我们认为人们“应该”或“不应该”做什么，我们还给人贴上各种 标 签 ， 并 说 长 论 短 。 请 留 意 我 们 头 脑 中 “ 我 不 喜 欢 抽 烟 的人……”之类的想法。然后，问自己：“我不喜欢他们……，是因为我什么样的需要没有得到满足？”通过这样的方式，我们就把<strong>注意力放在了尚未得到满足的需要，而不是考虑他人有什么过错。</strong></p><blockquote><p>小结</p></blockquote><p>在生气时，批评和指责他人都无法真正传达我们的心声。如果想充分表达愤怒，我们就不能归咎于他人，而把<strong>注意力放在自己的感受和需要上。</strong>与批评和指责他人相比，<strong>直接说出我们的需要更有可能使我们的愿望得到满足。</strong><br>表达愤怒的四个步骤是：（1）停下来，除了呼吸，什么都别做；（2）想一想是什么想法使我们生气了；（3）体会自己的需要；（4）表达感受和尚未满足的需要。有时，<strong>在第3步和第4步之间，我们需要先倾听他人。在得到倾听和理解之后，他们也就可以静下心来体会我们的感受和需要。</strong><br>我们需要给自己充分的时间来学习和运用非暴力沟通。</p><h1 id="运用强制力避免伤害"><a href="#运用强制力避免伤害" class="headerlink" title="运用强制力避免伤害"></a>运用强制力避免伤害</h1><p>在有些情形中，我们没有机会和他人交流，这时，我们也许需要使用强制力来保护自己和他人。我们这样做，是为了<strong>避免伤害，而不是为了惩罚他人</strong>。如果我们威胁他人或实施惩罚，人们常常会产生敌意和抵触心理。这样，彼此的关系将会疏远。同时，惩罚还可能使人忽视事情本身的意义，而把注意力放在不服从的后果上。如果我们试图通过惩罚来使人们认识自己的需要，那么，我们很可能适得其反。</p><h1 id="重获生活的热情"><a href="#重获生活的热情" class="headerlink" title="重获生活的热情"></a>重获生活的热情</h1><p>如果以苛刻的态度对人对己，我们的心情也好不到哪里去。通过运用非暴力沟通，我们不再试图分析自己或他人有什么毛病，而是用</p><p>心去<strong>了解我们的需要</strong>，这样，我们的内心就会逐渐变得平和。一旦我们发现自己心底深处的<strong>愿望</strong>，并采取<strong>积极的行动</strong>，我们将会重获生活的热情。</p><h1 id="表达感激"><a href="#表达感激" class="headerlink" title="表达感激"></a>表达感激</h1><blockquote><p>非暴力沟通表达感激的方式</p></blockquote><p>非暴力沟通表达感激的方式包含三个部分：</p><ol><li>对方做了什么事情使我们的生活得到了改善；</li><li>我们有哪些需要得到了满足；</li><li>我们的心情怎么样？</li></ol>]]></content>
      
      
      <categories>
          
          <category> Growth </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reading List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Latex和Word写论文</title>
      <link href="/2020/11/21/study/yong-latex-he-word-xie-lun-wen/"/>
      <url>/2020/11/21/study/yong-latex-he-word-xie-lun-wen/</url>
      
        <content type="html"><![CDATA[<h1 id="Latex转Word"><a href="#Latex转Word" class="headerlink" title="Latex转Word"></a><a href="https://medium.com/@zhelinchen91/how-to-convert-from-latex-to-ms-word-with-pandoc-f2045a762293" target="_blank" rel="noopener">Latex转Word</a></h1><ul><li>打开cmd</li><li>cd 到LaTeX文件所在的路径</li><li><code>pandoc Manuscript.tex -o Manuscript.docx</code><ul><li><a href="https://www.jianshu.com/p/dc62b915920e" target="_blank" rel="noopener">若要把bib参考文献也转换：</a><code>pandoc Manuscript.tex --bibliography=indoor_location.bib -o mydoc.docx</code></li><li>或者，<code>pandoc Manuscript.tex --filter pandoc-crossref --bibliography=indoor_location.bib --reference-docx=IEEE_template.doc -o mydoc.docx</code></li></ul></li></ul><p>即可生成docx的文件，只是图片和格式就没有了。但大部分公式能被转换成Word的内嵌公式，图表也能转换成功，标题等级也能保留。</p><h1 id="LaTex"><a href="#LaTex" class="headerlink" title="LaTex"></a>LaTex</h1><h2 id="LaTex下载及安装"><a href="#LaTex下载及安装" class="headerlink" title="LaTex下载及安装"></a>LaTex下载及安装</h2><ul><li><a href="https://liam.page/2014/09/08/latex-introduction/" target="_blank" rel="noopener">LaTex快速入门</a><ul><li>（几乎是）最简洁的 (La)TeX 编辑器——TeXworks——的基本使用方法；</li><li>如何使用 (Xe)LaTeX 进行简单的<strong>中英混排</strong>；</li><li>简单的文章组织结构；</li><li>如何用 (Xe)LaTeX 进行数学公式的排版；</li><li>如何在 (Xe)LaTeX 的文档中插入图片/表格；</li><li>如何进行简单的版面设置；</li><li>几个最常见的带有 TeX 的单词的含义；</li><li>出现问题应当如何处理/怎样聪明地提出你的问题——怎样从这里毕业。</li></ul></li><li><a href="https://liam.page/texlive/" target="_blank" rel="noopener">TeX Live 下载及安装</a><br><del>- <a href="https://blog.csdn.net/RobertChenGuangzhi/article/details/51249112?utm_source=blogxgwz6" target="_blank" rel="noopener">为TexWorks添加拼写检查功能</a></del></li></ul><h2 id="TeXstudio编译器下载"><a href="#TeXstudio编译器下载" class="headerlink" title="TeXstudio编译器下载"></a><a href="https://www.texstudio.org/" target="_blank" rel="noopener">TeXstudio编译器下载</a></h2><ul><li><a href="https://www.youtube.com/watch?v=RNmAkGRwEbA" target="_blank" rel="noopener">添加languagetool拼写检查(需安装java)</a></li></ul><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><h3 id="Word公式和Latex公式互转"><a href="#Word公式和Latex公式互转" class="headerlink" title="Word公式和Latex公式互转"></a>Word公式和Latex公式互转</h3><p>打开mathtype-选项-剪切和复制选项-转换其他文字-Latex2.09 and later-确定 然后复制粘贴公式到Latex中即可</p><h3 id="公式展示"><a href="#公式展示" class="headerlink" title="公式展示"></a>公式展示</h3><ul><li>使用 <code>$ ... $</code> 可以插入行内公式</li><li>使用 <code>\[ ... \]</code> 可以插入行间公式</li><li>如果需要对行间公式进行编号，则可以使用 equation 环境：<pre><code>\begin{equation}...\end{equation}</code></pre></li></ul><h3 id="多行公式，公式组，对齐"><a href="#多行公式，公式组，对齐" class="headerlink" title="多行公式，公式组，对齐"></a><a href="https://liam0205.me/2014/09/08/latex-introduction/" target="_blank" rel="noopener">多行公式，公式组，对齐</a></h3><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p>在文档头部加入</p><pre><code>\usepackage{bm}</code></pre><p>然后在需要加粗的地方写</p><pre><code>\bm{${...}$}</code></pre><h3 id="花体"><a href="#花体" class="headerlink" title="花体"></a>花体</h3><p>在\begindocument之前使用<code>\usepackage{mathrsfs}</code>宏包，然后使用<code>\mathscr{A}</code>命令</p><h3 id="空心体"><a href="#空心体" class="headerlink" title="空心体"></a>空心体</h3><p>使用到的包为</p><pre><code>\usepackage{amsfonts,amssymb}</code></pre><p>代码为</p><pre><code>$\mathbb{S}$$\mathbb{R}$</code></pre><h3 id="公式中一部分斜体变为直体"><a href="#公式中一部分斜体变为直体" class="headerlink" title="公式中一部分斜体变为直体"></a><a href="https://blog.csdn.net/xiaotao_1/article/details/78270672" target="_blank" rel="noopener">公式中一部分斜体变为直体</a></h3><ul><li>全局使用，使公式全部变为直体： <pre><code>\rm sigmod(x) = \frac{1} {1 + e^{-x}} </code></pre></li></ul><ul><li><p>局部使用，使公式一部分变为直体，该部分用{}括起来： </p><pre><code>{\rm sigmod}(x) = \frac{1} {1 + e^{-x}} </code></pre></li></ul><h3 id="公式太长，需要换行（换行，等号对齐）"><a href="#公式太长，需要换行（换行，等号对齐）" class="headerlink" title="公式太长，需要换行（换行，等号对齐）"></a><a href="https://blog.csdn.net/leichaoaizhaojie/article/details/53463598" target="_blank" rel="noopener">公式太长，需要换行（换行，等号对齐）</a></h3><h3 id="添加空格"><a href="#添加空格" class="headerlink" title="添加空格"></a>添加空格</h3><p>  具体的间隔大小为：</p><pre><code>\quad           1em,em代表一个字符宽度\qquad          2em\,              3/18em\:              4/18em\;              5/18em\!             -3/18em（不仅不会增加空格，还会把间距给减小1/6个字符，这个有时可以用到，比如输入模的时候||x||，可以用这个把两个|的间距缩小点，这样更加美观）</code></pre><h3 id="高亮公式区域"><a href="#高亮公式区域" class="headerlink" title="高亮公式区域"></a>高亮公式区域</h3><ul><li><p>方法1</p><pre><code>\begin{mdframed}[hidealllines=true,backgroundcolor=yellow,innerleftmargin=1pt,innerrightmargin=1pt,leftmargin=-1pt,rightmargin=-1pt]公式...\end{mdframed}</code></pre></li><li><p>方法2：<a href="http://www.latexstudio.net/archives/1373" target="_blank" rel="noopener">用tcolorbox高亮显示</a></p></li></ul><h3 id="用mathpix可将截图的公式转化成LaTex公式"><a href="#用mathpix可将截图的公式转化成LaTex公式" class="headerlink" title="用mathpix可将截图的公式转化成LaTex公式"></a><a href="https://mathpix.com/" target="_blank" rel="noopener">用mathpix可将截图的公式转化成LaTex公式</a></h3><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h3 id="并排插入图片"><a href="#并排插入图片" class="headerlink" title="并排插入图片"></a><a href="https://blog.csdn.net/programchangesworld/article/details/51553683" target="_blank" rel="noopener">并排插入图片</a></h3><ul><li><a href="https://www.draw.io/" target="_blank" rel="noopener">附：快速在线作图</a></li><li><a href="http://www.latexstudio.net/archives/8652" target="_blank" rel="noopener">格式化图表标题和子标题</a></li></ul><h3 id="插入图片路径设置"><a href="#插入图片路径设置" class="headerlink" title="插入图片路径设置"></a><a href="https://blog.csdn.net/missingu1314/article/details/30027889" target="_blank" rel="noopener">插入图片路径设置</a></h3><p>在latex里面插入很多图片时，有时候相关的图片会放在同一个文件夹下，这时需要指定图片的路径，如果图片在tex文件所在文件夹下的子文件夹下，只需要把子文件夹的名字写上就行，比如子文件夹名字为fig则图片的路径可表示为</p><pre><code>\begin{figure}[htbp]\begin{center}\includegraphics[angle=0,width=1\textwidth]{fig//1.eps}\caption{示意图}\label{fig:1}\end{center}\end{figure}</code></pre><p>图片的名称中间不要有空格，否则最后一个单词会自动显示在文档中。</p><h3 id="图片标题的字体大小设置"><a href="#图片标题的字体大小设置" class="headerlink" title="图片标题的字体大小设置"></a>图片标题的字体大小设置</h3><pre><code>\begin{figure} \includegraphics{Arac.eps} \caption{\scriptsize{The Architecture}} \label{Arac} \end{figure}</code></pre><p>显示的结果是“FIg.1”的字体大小和后面的“The Architecture”不一样大。</p><p>解决方案：</p><pre><code>\usepackage{caption}\captionsetup{font={scriptsize}}   %% 这一句放在 caption前面这里还可以设置字体大小为：large  small  footnotesize scriptsize等更多信息</code></pre><h3 id="去掉图表标题冒号"><a href="#去掉图表标题冒号" class="headerlink" title="去掉图表标题冒号"></a><a href="http://blog.sina.com.cn/s/blog_5e16f1770100ng8z.html" target="_blank" rel="noopener">去掉图表标题冒号</a></h3><h3 id="双栏文字中插入单栏图片，使图片出现在当前页"><a href="#双栏文字中插入单栏图片，使图片出现在当前页" class="headerlink" title="双栏文字中插入单栏图片，使图片出现在当前页"></a><a href="https://blog.csdn.net/zhuang19951231/article/details/79176298" target="_blank" rel="noopener">双栏文字中插入单栏图片，使图片出现在当前页</a></h3><h3 id="图，表，公式的引用"><a href="#图，表，公式的引用" class="headerlink" title="图，表，公式的引用"></a><a href="https://blog.csdn.net/zhazhazl/article/details/52783172" target="_blank" rel="noopener">图，表，公式的引用</a></h3><ul><li><code>\label</code> 要紧跟在<code>\caption</code> 后面，否则编译后正文出现？。</li></ul><h3 id="jpg等格式转成eps"><a href="#jpg等格式转成eps" class="headerlink" title="jpg等格式转成eps"></a>jpg等格式转成eps</h3><ul><li><a href="https://pan.baidu.com/s/1-eDbjpR81k7mfNZJOGvA1A" target="_blank" rel="noopener">下载该bat文件（提取码1111）</a>，并把该文件放到需要图片转换的文件夹中</li><li>双击该bat，可把图片转成eps格式</li><li>在文件开头加入宏包：<code>\usepackage{graphicx}</code>, <code>\usepackage{epstopdf}</code></li><li>把LaTex中的.jpg等格式改成.eps</li><li>运行文件，同时会生成pdf格式的图片</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul><li><p><a href="https://www.jianshu.com/p/1b7daca5f100" target="_blank" rel="noopener">在线插表格</a></p><ul><li>在<a href="https://www.tablesgenerator.com/latex_tables" target="_blank" rel="noopener">表格在线工具</a>中，若绘制三线表，则表格类型选择   Booktabs table style。并可以同时结合 <a href="http://www.tablesgenerator.com/help/latex-tables/borders-editing" target="_blank" rel="noopener">Activate/Deactivate (手形状按钮)</a> 绘制更复杂的表格线</li><li>若表格内要换行，则直接在网页表格中需要换行的地方打回车即可。 <a href="https://blog.csdn.net/yihaizhiyan/article/details/48293069" target="_blank" rel="noopener"><del>单元格内强制换行</del></a></li></ul></li><li><p>改变行高</p><p>在<code>\begin{tabular}</code> 前面加上<code>\renewcommand\arraystretch{1.2}</code>，行的高度变为原来的1.2倍。</p><pre><code>  \renewcommand\arraystretch{1.2}  \begin{tabular}{@{}ll@{}}</code></pre></li><li><p><a href="https://blog.csdn.net/loveaborn/article/details/9151505" target="_blank" rel="noopener">控制表格线的粗细</a></p><pre><code>\usepackage{booktabs}  首行(\toprule[2pt])，中间行(\midrule[1pt]), 及未尾行(\bottomrule[2pt])加粗</code></pre></li><li><p>表格编号与标题不在同一行</p><pre><code>captionsetup[table]{format=plain, singlelinecheck=off, justification=centering, labelsep=newline, font=small}</code></pre></li></ul><h2 id="bib参考文献管理和引用"><a href="#bib参考文献管理和引用" class="headerlink" title=".bib参考文献管理和引用"></a><a href="https://www.cnblogs.com/zhaoyang10/p/4468581.html" target="_blank" rel="noopener">.bib参考文献管理和引用</a></h2><ul><li><p><a href="https://blog.csdn.net/qq_21391921/article/details/78138139" target="_blank" rel="noopener">使用JabRef</a>生成.bib文件，<a href="https://www.zhihu.com/question/23565739/answer/24977097" target="_blank" rel="noopener">并引用</a></p></li><li><p><a href="https://blog.csdn.net/gokeyhps/article/details/46984497" target="_blank" rel="noopener">文献字体大小调整</a></p><pre><code>\tiny\scriptsize\footnotesize\small\normalsize\large\Large\LARGE\huge\Huge</code></pre></li><li><p>单元格内强制换行</p><ul><li>加入宏包 <code>\usepackage{makecell}</code></li><li>在表格中需要换行的内容处加 <code>\makecell</code>,再用<code>\\</code> 分隔即可。比如<code>\makecell{从这里\\换行}</code>.</li></ul></li></ul><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a><a href="https://blog.csdn.net/golden1314521/article/details/40923377" target="_blank" rel="noopener">伪代码</a></h2><h2 id="添加下一页和空多行"><a href="#添加下一页和空多行" class="headerlink" title="添加下一页和空多行"></a>添加下一页和空多行</h2><ul><li><p><a href="https://blog.csdn.net/zd0303/article/details/7572992" target="_blank" rel="noopener">Latex添加新一页</a><br>用<code>\clearpage</code></p></li><li><p>空多行（以下三种都可以）</p><ul><li>\vskip 4\baselineskip</li><li>\vspace{1\baselineskip}</li><li>\setlength{\parskip}{1.2ex}</li></ul></li></ul><h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><ul><li>简历模板<ul><li><a href="http://www.latextemplates.com/cat/curricula-vitae" target="_blank" rel="noopener">通用模板</a></li><li><a href="https://www.sharelatex.com/templates/cv-or-resume" target="_blank" rel="noopener">overleaf模板</a></li><li><a href="https://github.com/huajh/awesome-latex-cv/tree/zh-cn" target="_blank" rel="noopener">github模板（支持中英文）</a></li></ul></li><li><a href="https://pan.baidu.com/s/1pZblSJwD6EDgELwEujZ2FA" target="_blank" rel="noopener">入门讲义（提取码1111）</a></li></ul><h1 id="Word"><a href="#Word" class="headerlink" title="Word"></a>Word</h1><h2 id="插入图表"><a href="#插入图表" class="headerlink" title="插入图表"></a>插入图表</h2><ul><li><a href="https://www.jianshu.com/p/acc80f4295f7" target="_blank" rel="noopener">Word中实现图片自动编号与文中引用编号对应</a></li><li><a href="https://v.qq.com/x/page/w0389rwwct8.html" target="_blank" rel="noopener">论文中的图表跟随章节插入题注+定义标题样式</a></li><li>如果在公式或图片(1)前新加入一个公式/图片，会发现编号错误，需要通过更新域来更新编号。Ctrl+A全选全文，F9更新域。（Alt+F9更新域代码）</li></ul><h2 id="插入公式"><a href="#插入公式" class="headerlink" title="插入公式"></a>插入公式</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/109929891" target="_blank" rel="noopener">win10 Word中添加mathtype选项卡</a></p></li><li><p><a href="https://www.zhihu.com/question/34766002/answer/709505443" target="_blank" rel="noopener">mathtype中公式行间距变大解决方法</a></p><ul><li><p>选择有公式存在的那几行或者直接按Ctrl+a全选文档，接下来</p><ol><li>字体&gt;字符间距&gt;位置，选为标准</li><li>段落&gt;中文版式&gt;对齐方式，选为居中</li><li>布局&gt;页面设置&gt;文档网络，网格栏中选为无网格</li></ol></li><li><p>以上三步必须全部完成，缺一不可</p></li></ul></li><li><p><a href="http://blog.sina.com.cn/s/blog_a201dc3f0102yfnf.html" target="_blank" rel="noopener">在正文中引用公式编号</a></p><ul><li>mathtype选项卡-&gt;插入引用</li><li>双击需要引用的公式编号</li></ul></li><li><p>mathtype编号不从1开始</p><ul><li>在每一章的开始，mathtype选项卡-&gt;公式编号-&gt;插入分隔符-&gt;修改分隔符</li><li>修改章节分隔符的数字，可从特定的数字开始对公式编号</li><li><a href="https://blog.csdn.net/grllery/article/details/105448744" target="_blank" rel="noopener">隐藏mathtype分隔符</a> </li></ul><p><img src="https://i.loli.net/2020/11/23/y1baLJdO8PeCqHf.png" alt></p></li></ul><h2 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h2><ul><li><a href="https://zhidao.baidu.com/question/584901844530550645.html?qbl=relate_question_2" target="_blank" rel="noopener">中文设宋体，英文设Times New Roma</a><ul><li>Ctrl+A 全选，Ctrl+D分别设置字体格式</li></ul></li></ul><h2 id="在Word中用Endnote插入参考文献"><a href="#在Word中用Endnote插入参考文献" class="headerlink" title="在Word中用Endnote插入参考文献"></a>在Word中用Endnote插入参考文献</h2><ul><li><a href="https://www.howsci.com/endnote-word-optimize.html" target="_blank" rel="noopener">EndNote在Word中插入文献时电脑变卡的解决方法(使用第二种：Endnote 优化)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Network Programming - Deep Learning with PyTorch</title>
      <link href="/2020/11/01/python/ml/deep-learning-with-pytorch-note/"/>
      <url>/2020/11/01/python/ml/deep-learning-with-pytorch-note/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.youtube.com/watch?v=v5cngxo4mIg&list=PLZbbT5o_s2xrfNyHZsM6ufI0iZENK9xgG&index=1" target="_blank" rel="noopener">Youtube Video</a></p><p><a href="https://deeplizard.com/learn/video/v5cngxo4mIg" target="_blank" rel="noopener">Blog Post</a></p></blockquote><h1 id="8-PyTorch-Tensors-Explained-Neural-Network-Programming"><a href="#8-PyTorch-Tensors-Explained-Neural-Network-Programming" class="headerlink" title="8. PyTorch Tensors Explained - Neural Network Programming"></a>8. PyTorch Tensors Explained - Neural Network Programming</h1><p><img src="https://i.loli.net/2020/10/29/iDBuEPZH49t5fU8.png" alt></p><h1 id="9-Creating-PyTorch-Tensors-for-Deep-Learning-Best-Options"><a href="#9-Creating-PyTorch-Tensors-for-Deep-Learning-Best-Options" class="headerlink" title="9. Creating PyTorch Tensors for Deep Learning - Best Options"></a>9. Creating PyTorch Tensors for Deep Learning - Best Options</h1><p><img src="https://i.loli.net/2020/10/29/4wRlmHfgWB2aGIC.png" alt><br><img src="https://i.loli.net/2020/10/29/IZ9c25SXDewjVva.png" alt></p><h1 id="10-Flatten-Reshape-and-Squeeze-Explained"><a href="#10-Flatten-Reshape-and-Squeeze-Explained" class="headerlink" title="10. Flatten, Reshape, and Squeeze Explained"></a>10. Flatten, Reshape, and Squeeze Explained</h1><p><img src="https://i.loli.net/2020/10/29/dRGPOCAngyQp46U.png" alt></p><h1 id="11-CNN-Flatten-Operation-Visualized-Tensor-Batch-Processing-for-Deep-Learning"><a href="#11-CNN-Flatten-Operation-Visualized-Tensor-Batch-Processing-for-Deep-Learning" class="headerlink" title="11. CNN Flatten Operation Visualized - Tensor Batch Processing for Deep Learning"></a>11. CNN Flatten Operation Visualized - Tensor Batch Processing for Deep Learning</h1><ul><li>Flattening Specific Axes Of A Tensor</li></ul><p>In the post on CNN input tensor shape, we learned how tensor inputs to a convolutional neural network typically have 4 axes, one for batch size, one for color channels, and one each for height and width.</p><p>Notice in the call how we specified the <code>start_dim</code> parameter. This tells the <code>flatten()</code> method which axis it should start the flatten operation. The one here is an index, so it’s the second axis which is the color channel axis. We skip over the batch axis so to speak, leaving it intact.</p><h1 id="19-CNN-Weights-Learnable-Parameters-in-PyTorch-Neural-Networks"><a href="#19-CNN-Weights-Learnable-Parameters-in-PyTorch-Neural-Networks" class="headerlink" title="19. CNN Weights - Learnable Parameters in PyTorch Neural Networks"></a>19. CNN Weights - Learnable Parameters in PyTorch Neural Networks</h1><p><img src="https://i.loli.net/2020/11/09/L9DIuYM1ckrdUqp.png" alt></p><ul><li>input is 4-dimension, output is 3-dimension, the shape of weight is 3*4.</li></ul><p><img src="https://i.loli.net/2020/11/09/pmF53SiU7v9TDMt.png" alt><br><img src="https://i.loli.net/2020/11/09/QL1K9GgezrqByin.png" alt></p><h1 id="25-CNN-Output-Size-Formula-Bonus-Neural-Network-Debugging-Session"><a href="#25-CNN-Output-Size-Formula-Bonus-Neural-Network-Debugging-Session" class="headerlink" title="25. CNN Output Size Formula - Bonus Neural Network Debugging Session"></a>25. CNN Output Size Formula - Bonus Neural Network Debugging Session</h1><p><img src="https://i.loli.net/2020/11/10/LN8oVtwf6vga1YA.png" alt></p><h1 id="26-CNN-Training-with-Code-Example-Neural-Network-Programming-Course"><a href="#26-CNN-Training-with-Code-Example-Neural-Network-Programming-Course" class="headerlink" title="26. CNN Training with Code Example - Neural Network Programming Course"></a>26. CNN Training with Code Example - Neural Network Programming Course</h1><ul><li>Training Using a Single Batch<ul><li>Calculate Loss</li><li>Calculate Gradients</li><li>Update Weight</li></ul></li></ul><p><img src="https://i.loli.net/2020/11/10/z6RDKBotrWMHhkP.png" alt="Training Using a Single Batch"></p><h1 id="27-CNN-Training-Loop-Explained-Neural-Network-Code-Project"><a href="#27-CNN-Training-Loop-Explained-Neural-Network-Code-Project" class="headerlink" title="27. CNN Training Loop Explained - Neural Network Code Project"></a><a href="https://deeplizard.com/learn/video/XfYmia3q2Ow" target="_blank" rel="noopener">27. CNN Training Loop Explained - Neural Network Code Project</a></h1><blockquote><p>well explained what happened with each loop.</p></blockquote><h1 id="29-Stack-vs-Concat-in-PyTorch-TensorFlow-amp-NumPy-Deep-Learning-Tensor-Ops"><a href="#29-Stack-vs-Concat-in-PyTorch-TensorFlow-amp-NumPy-Deep-Learning-Tensor-Ops" class="headerlink" title="29. Stack vs Concat in PyTorch, TensorFlow &amp; NumPy - Deep Learning Tensor Ops"></a>29. Stack vs Concat in PyTorch, TensorFlow &amp; NumPy - Deep Learning Tensor Ops</h1><p><img src="https://i.loli.net/2020/11/11/N8KyWxQEvSdz9oj.png" alt></p><p><img src="https://i.loli.net/2020/11/11/yhHBitcz6aX7uJ8.png" alt></p><p><img src="https://i.loli.net/2020/11/11/vOwo3nzR798VqjL.png" alt></p><h1 id="31-Hyperparameter-Tuning-and-Experimenting-Training-Deep-Neural-Networks"><a href="#31-Hyperparameter-Tuning-and-Experimenting-Training-Deep-Neural-Networks" class="headerlink" title="31. Hyperparameter Tuning and Experimenting - Training Deep Neural Networks"></a>31. Hyperparameter Tuning and Experimenting - Training Deep Neural Networks</h1><p><img src="https://i.loli.net/2020/11/11/4MAjzTZo2pwq6mB.png" alt></p><h1 id="32-Training-Loop-Run-Builder-Neural-Network-Experimentation-Code"><a href="#32-Training-Loop-Run-Builder-Neural-Network-Experimentation-Code" class="headerlink" title="32. Training Loop Run Builder - Neural Network Experimentation Code"></a>32. Training Loop Run Builder - Neural Network Experimentation Code</h1><p><a href="https://deeplizard.com/learn/video/NSKghk0pcco" target="_blank" rel="noopener">Using The RunBuilder Class</a></p><ul><li>build sets of parameters that define our runs.</li></ul><p>All we have to do to add additional values is to <strong>add them to the original parameter list</strong>, and if we want to add an additional type of parameter, all we have to do is add it. The new parameter and its values will <strong>automatically become available to be consumed inside the run</strong>. The string output for the run also updates as well.</p><p>This functionality will allow us to have greater control as we experiment with different values during training.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> OrderedDict<span class="token keyword">from</span> collections <span class="token keyword">import</span> namedtuple<span class="token keyword">from</span> itertools <span class="token keyword">import</span> product<span class="token keyword">class</span> <span class="token class-name">RunBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    @staticmethod    <span class="token keyword">def</span> <span class="token function">get_runs</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">:</span>        Run <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Run'</span><span class="token punctuation">,</span> params<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        runs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> v <span class="token keyword">in</span> product<span class="token punctuation">(</span><span class="token operator">*</span>params<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            runs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Run<span class="token punctuation">(</span><span class="token operator">*</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> runs<span class="token comment" spellcheck="true"># Two parameters:</span>params <span class="token operator">=</span> OrderedDict<span class="token punctuation">(</span>    lr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">001</span><span class="token punctuation">]</span>    <span class="token punctuation">,</span>batch_size <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Three parameters:</span>params <span class="token operator">=</span> OrderedDict<span class="token punctuation">(</span>    lr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">001</span><span class="token punctuation">]</span>    <span class="token punctuation">,</span>batch_size <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">]</span>    <span class="token punctuation">,</span>device <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"cuda"</span><span class="token punctuation">,</span> <span class="token string">"cpu"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>runs <span class="token operator">=</span> RunBuilder<span class="token punctuation">.</span>get_runs<span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>runs<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output of two parameters</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># [</span><span class="token comment" spellcheck="true">#     Run(lr=0.01, batch_size=1000),</span><span class="token comment" spellcheck="true">#     Run(lr=0.01, batch_size=10000),</span><span class="token comment" spellcheck="true">#     Run(lr=0.001, batch_size=1000),</span><span class="token comment" spellcheck="true">#     Run(lr=0.001, batch_size=10000)</span><span class="token comment" spellcheck="true"># ]</span><span class="token comment" spellcheck="true"># output of three parameters</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># [</span><span class="token comment" spellcheck="true">#     Run(lr=0.01, batch_size=1000, device='cuda'),</span><span class="token comment" spellcheck="true">#     Run(lr=0.01, batch_size=1000, device='cpu'),</span><span class="token comment" spellcheck="true">#     Run(lr=0.01, batch_size=10000, device='cuda'),</span><span class="token comment" spellcheck="true">#     Run(lr=0.01, batch_size=10000, device='cpu'),</span><span class="token comment" spellcheck="true">#     Run(lr=0.001, batch_size=1000, device='cuda'),</span><span class="token comment" spellcheck="true">#     Run(lr=0.001, batch_size=1000, device='cpu'),</span><span class="token comment" spellcheck="true">#     Run(lr=0.001, batch_size=10000, device='cuda'),</span><span class="token comment" spellcheck="true">#     Run(lr=0.001, batch_size=10000, device='cpu')</span><span class="token comment" spellcheck="true"># ]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Supplement-RNN"><a href="#Supplement-RNN" class="headerlink" title="Supplement: RNN"></a>Supplement: RNN</h1><p>PyTorch Zero To All Lecture:</p><p><a href="https://www.youtube.com/playlist?list=PLlMkM4tgfjnJ3I-dbhO9JTw7gNty6o_2m" target="_blank" rel="noopener">Youtube Video</a><br><a href="https://github.com/hunkim/PyTorchZeroToAll" target="_blank" rel="noopener">Code</a><br><a href="https://drive.google.com/drive/folders/0B41Zbb4c8HVyUndGdGdJSXd5d3M" target="_blank" rel="noopener">Slides</a></p><ul><li>PyTorch Lecture 12: RNN1 - Basics</li></ul><p><img src="https://i.loli.net/2020/11/21/g2FetKVEsCM4fWG.png" alt><br><img src="https://i.loli.net/2020/11/21/aLB82ZmWMJ36xPe.png" alt><br><img src="https://i.loli.net/2020/11/21/Ph83JOY4cHwrlCj.png" alt><br><img src="https://i.loli.net/2020/11/21/GJsmoMIzye3lnQW.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学学习_pytorch版</title>
      <link href="/2020/09/12/python/ml/dong-shou-xue-shen-du-xue-xue-xi-pytorch-ban/"/>
      <url>/2020/09/12/python/ml/dong-shou-xue-shen-du-xue-xue-xi-pytorch-ban/</url>
      
        <content type="html"><![CDATA[<p><a href="https://tangshusen.me/Dive-into-DL-PyTorch/#/" target="_blank" rel="noopener">《动手学深度学习》(Pytorch版)</a></p><ul><li><a href="https://github.com/ShusenTang/Dive-into-DL-PyTorch" target="_blank" rel="noopener">github</a> 中有每章节的<code>code</code>源文件，clone到本地运行，可观察各模型效果。</li></ul><hr><h3 id="3-4-5-交叉熵损失函数"><a href="#3-4-5-交叉熵损失函数" class="headerlink" title="3.4.5 交叉熵损失函数"></a>3.4.5 交叉熵损失函数</h3><p>交叉熵只关心对正确类别的预测概率，因为只要其值足够大，就可以确保分类结果正确</p><blockquote><p><a href="https://blog.csdn.net/guolindonggld/article/details/79250642" target="_blank" rel="noopener">交叉熵损失（Cross Entropy Loss）计算过程</a></p></blockquote><h3 id="3-5-1-获取数据集"><a href="#3-5-1-获取数据集" class="headerlink" title="3.5.1 获取数据集"></a>3.5.1 获取数据集</h3><p><code>transform = transforms.ToTensor()</code>使所有数据转换为Tensor，如果不进行转换则返回的是PIL图片。<code>transforms.ToTensor()</code>将尺寸为<code>(H x W x C)</code>且数据位于[0, 255]的PIL图片或者数据类型为np.uint8的NumPy数组转换为尺寸为<code>(C x H x W)</code>且数据类型为torch.float32且位于[0.0, 1.0]的Tensor。</p><h2 id="3-8-多层感知机"><a href="#3-8-多层感知机" class="headerlink" title="3.8 多层感知机"></a>3.8 多层感知机</h2><p><img src="https://i.loli.net/2020/09/15/K1XFt4rIkQAsElT.png" alt="20200915224537"></p><p>上述问题的根源在于全连接层只是对数据做仿射变换<code>（affine transformation）</code>，而<strong>多个仿射变换的叠加仍然是一个仿射变换</strong>。解决问题的一个方法是<strong>引入非线性变换</strong>，例如对隐藏变量使用按元素运算的非线性函数进行变换，然后再作为下一个全连接层的输入。这个非线性函数被称为激活函数<code>（activation function）</code>。</p><h2 id="3-12-权重衰减"><a href="#3-12-权重衰减" class="headerlink" title="3.12 权重衰减"></a>3.12 权重衰减</h2><ul><li>正则化通过为模型损失函数添加惩罚项使学出的<strong>模型参数值较小</strong>，是<strong>应对过拟合</strong>的常用手段。</li><li>权重衰减等价于L2范数正则化，通常会使学到的<strong>权重参数的元素较接近0</strong>。</li><li>权重衰减可以通过优化器中的weight_decay超参数来指定。</li><li>可以定义多个优化器实例对不同的模型参数使用不同的迭代方法。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/47391705" target="_blank" rel="noopener">经典CNN结构简析：AlexNet、VGG、NIN、GoogLeNet、ResNet etc</a></p><h3 id="5-5-1-LeNet模型"><a href="#5-5-1-LeNet模型" class="headerlink" title="5.5.1 LeNet模型"></a>5.5.1 LeNet模型</h3><p>以单通道的28*28图片为例，各层网络输入输出说明如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> torch<span class="token keyword">from</span> torch <span class="token keyword">import</span> nn<span class="token punctuation">,</span> optim<span class="token keyword">import</span> syssys<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span> <span class="token keyword">import</span> d2lzh_pytorch <span class="token keyword">as</span> d2ldevice <span class="token operator">=</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">'cuda'</span> <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token string">'cpu'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">LeNet</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>LeNet<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># in_channels, out_channels, kernel_size.  1@28*28  ->  6@*(28-5+1)*(28-5+1)</span>            nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># kernel_size, stride. 6@24*24->6@12*12</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 6@12*12  ->  16@(12-5+1)*(12-5+1)</span>            nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 16*8*8  ->   16@4*4</span>        <span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">16</span><span class="token operator">*</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 把16张4*4的图片拉平（该向量长度为通道*高*宽），全连接层输入为16*4*4，输出为120</span>            nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">84</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 同上</span>            nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 同上</span>        <span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> img<span class="token punctuation">)</span><span class="token punctuation">:</span>        feature <span class="token operator">=</span> self<span class="token punctuation">.</span>conv<span class="token punctuation">(</span>img<span class="token punctuation">)</span>        output <span class="token operator">=</span> self<span class="token punctuation">.</span>fc<span class="token punctuation">(</span>feature<span class="token punctuation">.</span>view<span class="token punctuation">(</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 通过view，把特征变成 batch_size 行，通道数*高*宽  列</span>        <span class="token keyword">return</span> output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.cs.ryerson.ca/~aharley/vis/" target="_blank" rel="noopener">CNN卷积神经网络特征可视化</a>: <a href="https://www.cs.ryerson.ca/~aharley/vis/conv/flat.html" target="_blank" rel="noopener">二维</a>， <a href="https://www.cs.ryerson.ca/~aharley/vis/conv/" target="_blank" rel="noopener">三维</a></p><h2 id="5-7-使用重复元素的网络（VGG）"><a href="#5-7-使用重复元素的网络（VGG）" class="headerlink" title="5.7 使用重复元素的网络（VGG）"></a>5.7 使用重复元素的网络（VGG）</h2><ul><li>VGG块的组成规律是：使用的卷积全部为3x3，Pad=1，步长为1，也就是说，卷积不会改变输出大小（假设28<em>28的图片，），而改变输出大小这件事就交给了2x2，步长为2 的max pool，也就是说每通过一个 max pool，卷积的尺寸都会折半。<em>*卷积层保持输入的高和宽不变，而池化层则对其减半</em></em>。</li><li>VGG这种高和宽减半以及通道翻倍的设计使得多数卷积层都有相同的模型参数尺寸和计算复杂度。</li></ul><blockquote><p>对于给定的感受野（与输出有关的输入图片的局部大小），<strong>采用堆积的小卷积核优于采用大的卷积核</strong>，因为可以增加网络深度来保证学习更复杂的模式，而且代价还比较小（参数更少）。例如，在VGG中，使用了3个3x3卷积核来代替7x7卷积核，使用了2个3x3卷积核来代替5*5卷积核，这样做的主要目的是在保证具有相同感知野的条件下，提升了网络的深度，在一定程度上提升了神经网络的效果。</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/60235326" target="_blank" rel="noopener">图片来源：VGG网络结构详解</a><br><img src="https://i.loli.net/2020/09/20/926CF7hJN4BkcjD.png" alt="20200920231951"></p><p><img src="https://i.loli.net/2020/09/20/pgEoNj8a42fIXDQ.png" alt="20200920232012"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>199. 二叉树的右视图</title>
      <link href="/2020/08/31/leetcode/199-er-cha-shu-de-you-shi-tu/"/>
      <url>/2020/08/31/leetcode/199-er-cha-shu-de-you-shi-tu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/solution/dfs-bfs-by-powcai-7/" target="_blank" rel="noopener">199. 二叉树的右视图</a></p><ul><li><code>if len(res)&lt;=depth</code> 时, 说明遍历到了该层第一个元素，这时加个0用来占位置（第depth层的元素）</li><li>先深度遍历左子树，再深度遍历右子树，这样，这一层的值会被每一层的最后一个节点最终覆盖掉。用这种方式来实现右视图</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[int]        """</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>depth<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>                <span class="token keyword">return</span> res            <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">&lt;=</span>depth<span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            res<span class="token punctuation">[</span>depth<span class="token punctuation">]</span><span class="token operator">=</span>root<span class="token punctuation">.</span>val            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础知识汇总</title>
      <link href="/2020/08/30/python/python-ji-chu-zhi-shi-hui-zong/"/>
      <url>/2020/08/30/python/python-ji-chu-zhi-shi-hui-zong/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a><a href="https://www.liujiangblog.com/course/python/44" target="_blank" rel="noopener">封装、继承和多态</a></h2><h2 id="进程与线程的一个简单解释"><a href="#进程与线程的一个简单解释" class="headerlink" title="进程与线程的一个简单解释"></a><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释</a></h2><h2 id="进程之间有哪些通信方式？"><a href="#进程之间有哪些通信方式？" class="headerlink" title="进程之间有哪些通信方式？"></a><a href="https://zhuanlan.zhihu.com/p/104713463" target="_blank" rel="noopener">进程之间有哪些通信方式？</a></h2><p><a href="https://zhuanlan.zhihu.com/p/165224175" target="_blank" rel="noopener">小林coding进程间通信</a></p><ul><li>管道</li><li>消息队列</li><li>共享内存</li><li>信号量</li><li>Socket</li></ul><h2 id="Python并发编程之谈谈线程中的“锁机制”"><a href="#Python并发编程之谈谈线程中的“锁机制”" class="headerlink" title="Python并发编程之谈谈线程中的“锁机制”"></a><a href="https://juejin.im/post/6844903617535672328#heading-1" target="_blank" rel="noopener">Python并发编程之谈谈线程中的“锁机制”</a></h2><h2 id="COOKIE和SESSION有什么区别"><a href="#COOKIE和SESSION有什么区别" class="headerlink" title="COOKIE和SESSION有什么区别?"></a><a href="https://www.zhihu.com/question/19786827/answer/28752144" target="_blank" rel="noopener">COOKIE和SESSION有什么区别?</a></h2><ul><li>Session是在<strong>服务端</strong>保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</li><li>Cookie是<strong>客户端</strong>保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</li></ul><h2 id="分页和分段有什么区别？"><a href="#分页和分段有什么区别？" class="headerlink" title="分页和分段有什么区别？"></a><a href>分页和分段有什么区别？</a></h2><ul><li><p>页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率,是为了管理主存的方便而划分的，对用户是透明的。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要,因此段对用户是可见的。</p></li><li><p>页的大小固定且由系统决定；而段的长度却不固定，决定于用户所编写的程序。</p></li><li><p>分页的地址空间是一维的，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</p></li></ul><h2 id="成员保护和访问限制"><a href="#成员保护和访问限制" class="headerlink" title="成员保护和访问限制"></a><a href="https://www.liujiangblog.com/course/python/45" target="_blank" rel="noopener">成员保护和访问限制</a></h2><ul><li>在Python中，如果要让内部成员不被外部访问，可以在成员的名字前加上两个下划线<code>__</code>，这个成员就变成了一个私有成员（private）。私有成员只能在类的内部访问，外部无法访问。</li><li>类的成员与下划线总结：<ul><li><code>_name、_name_、_name__</code>:建议性的私有成员，不要在外部访问。</li><li><code>__name、 __name_</code>:强制的私有成员，但是你依然可以蛮横地在外部危险访问。</li><li><code>__name__</code>:特殊成员，与私有性质无关，例如<code>__doc__</code>。</li><li><code>name_、name__</code>:没有任何特殊性，普通的标识符，但最好不要这么起名。</li></ul></li></ul><h2 id="Python的垃圾回收机制"><a href="#Python的垃圾回收机制" class="headerlink" title="Python的垃圾回收机制"></a><a href="https://zhuanlan.zhihu.com/p/83251959" target="_blank" rel="noopener">Python的垃圾回收机制</a></h2><p>Python中的垃圾回收是以<strong>引用计数</strong>为主，<strong>标记-清除</strong>和<strong>分代收集</strong>为辅</p><ul><li>引用计数：Python在内存中存储每个对象的引用计数，如果计数变成0，该对象就会消失，分配给该对象的内存就会释放出来。</li><li>标记-清除：一些容器对象，比如list、dict、tuple，instance等可能会出现引用循环，对于这些循环，垃圾回收器会定时回收这些循环（对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边）。<ul><li>注意，只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列</li></ul></li><li>分代收集：对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。</li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="实现Python单例模式-Singleton"><a href="#实现Python单例模式-Singleton" class="headerlink" title="实现Python单例模式(Singleton)"></a><a href="https://zhuanlan.zhihu.com/p/37534850" target="_blank" rel="noopener">实现Python单例模式(Singleton)</a></h2><ul><li>单例是一种设计模式，应用该模式的类只会生成一个实例。单例模式保证了在程序的不同位置都可以且仅可以取到同一个对象实例：如果实例不存在，会创建一个实例；如果已存在就会返回这个实例。</li></ul><p>通过类实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_cls<span class="token operator">=</span>cls        self<span class="token punctuation">.</span>_instance<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> cls <span class="token operator">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>_instance<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>_instance<span class="token punctuation">[</span>cls<span class="token punctuation">]</span><span class="token operator">=</span>cls<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_instance<span class="token punctuation">[</span>cls<span class="token punctuation">]</span>@Singleton<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>solution1<span class="token operator">=</span>Solutionsolution2<span class="token operator">=</span>Solution<span class="token keyword">print</span><span class="token punctuation">(</span>id<span class="token punctuation">(</span>solution1<span class="token punctuation">)</span> <span class="token operator">==</span> id<span class="token punctuation">(</span>solution2<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过函数实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">singleton</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>    _instance<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> cls <span class="token operator">not</span> <span class="token keyword">in</span> _instance<span class="token punctuation">:</span>            _instance<span class="token punctuation">[</span>cls<span class="token punctuation">]</span><span class="token operator">=</span>cls<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> _instance<span class="token punctuation">[</span>cls<span class="token punctuation">]</span>    <span class="token keyword">return</span> wrapper@singleton<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>Solution1<span class="token operator">=</span>Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>Solution2<span class="token operator">=</span>Solution<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>id<span class="token punctuation">(</span>Solution1<span class="token punctuation">)</span> <span class="token operator">==</span> id<span class="token punctuation">(</span>Solution2<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><p>Python中对象之间的赋值是按引用传递的，如果要拷贝对象需要使用标准模板中的copy</p><ul><li>直接赋值：其实就是对象的引用（别名）。</li><li>copy.copy：浅拷贝，只拷贝父对象，不拷贝父对象的子对象。</li><li>copy.deepcopy：深拷贝，拷贝父对象和子对象。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> copya <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#原始对象</span>b <span class="token operator">=</span> a                       <span class="token comment" spellcheck="true">#赋值，传对象的引用</span>c <span class="token operator">=</span> copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>a<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#对象拷贝，浅拷贝</span>d <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>a<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#对象拷贝，深拷贝</span>a<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true">#修改对象a</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#修改对象a中的['a', 'b']数组对象</span><span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">'a = '</span><span class="token punctuation">,</span> a <span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">'b = '</span><span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">'c = '</span><span class="token punctuation">,</span> c <span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">'d = '</span><span class="token punctuation">,</span> d <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre><code>(&#39;a = &#39;, [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 5])(&#39;b = &#39;, [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 5])(&#39;c = &#39;, [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]])(&#39;d = &#39;, [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;]])</code></pre><h2 id="new和init的区别，-call-方法"><a href="#new和init的区别，-call-方法" class="headerlink" title="new和init的区别， __call__() 方法"></a><a href="https://zhuanlan.zhihu.com/p/23526961" target="_blank" rel="noopener"><strong>new</strong>和<strong>init</strong>的区别， <code>__call__()</code> 方法</a></h2><ul><li><p><code>__init__</code>是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值。</p></li><li><p><code>__new__</code>是在<strong>实例创建之前被调用的</strong>，因为它的任务就是<strong>创建实例然后返回该实例</strong>，是个静态方法。</p></li></ul><p>也就是：<code>__new__</code>在<code>__init__</code>之前被调用，<code>__new__</code>的返回值（实例）将传递给<code>__init__</code>方法的第一个参数，然后<code>__init__</code>给这个实例设置一些参数</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'This is new'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">## super() equals to object</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'This is init'</span><span class="token punctuation">)</span>obj<span class="token operator">=</span>Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># This is new     This is init</span><span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># &lt;__main__.c01 object at 0x00000000024E7910></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果为一个类编写了<code>__call__()</code> 方法，那么在该类的实例后面加括号，就会调用这个方法</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"__init__"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'__call__'</span><span class="token punctuation">)</span>obj <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 输出 __init__</span>obj<span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># 输出 __call__</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="python字典常用操作"><a href="#python字典常用操作" class="headerlink" title="python字典常用操作"></a>python字典常用操作</h2><ol><li>普通字典</li></ol><p><a href="https://www.runoob.com/python/python-dictionary.html" target="_blank" rel="noopener">常用的字典操作</a></p><ul><li>字典按键或值排序</li></ul><pre class="line-numbers language-python"><code class="language-python">d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 按键排序</span>d_k <span class="token operator">=</span> sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d_k<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [(1, 2), (2, 1), (3, 4), (5, 3)]</span><span class="token comment" spellcheck="true"># 按值排序</span>d_v <span class="token operator">=</span> sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#取出排序后的键</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> d_k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [1, 2, 3, 5]</span><span class="token comment" spellcheck="true"># 把键按空格输出</span>res<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span><span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> d_k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 取出排序后的值</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> d_k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [2, 1, 4, 3]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>defaultdict 字典</li></ol><p><a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" target="_blank" rel="noopener">常用的defaultdict字典操作</a></p><p>defaultdict接受一个工厂函数作为参数：<code>dict =defaultdict( factory_function)</code>. 这个factory_function可以是list、set、str、int等等。作用<strong>是当key不存在时，返回的是工厂函数的默认值</strong>。比如list对应[ ]，str对应的是空字符串，set对应set( )，int对应0</p><ul><li>取出字典中的信息</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> collectionss <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>d <span class="token operator">=</span> collections<span class="token punctuation">.</span>defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># d的键对应的值默认为列表</span><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> s<span class="token punctuation">:</span>    d<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># defaultdict(&lt;class 'list'>, {'yellow': [6, 3], 'blue': [2, 4], 'red': [1]})</span><span class="token comment" spellcheck="true"># 按键排序</span><span class="token keyword">print</span><span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [('blue', [2, 4]), ('red', [1]), ('yellow', [6, 3])]</span><span class="token comment" spellcheck="true"># 打印字典</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># dict_items([('yellow', [6, 3]), ('blue', [2, 4]), ('red', [1])])</span><span class="token comment" spellcheck="true"># 打印某键对应的值</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token string">"blue"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [2, 4]</span><span class="token comment" spellcheck="true"># 打印键</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># dict_keys(['yellow', 'blue', 'red'])</span><span class="token comment" spellcheck="true"># 打印值</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># dict_values([[6, 3], [2, 4], [1]])</span><span class="token comment" spellcheck="true"># 把值以列表的形式输出</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>d<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [[6, 3], [2, 4], [1]]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>200. 岛屿数量</title>
      <link href="/2020/08/29/leetcode/200-dao-yu-shu-liang/"/>
      <url>/2020/08/29/leetcode/200-dao-yu-shu-liang/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></p><p>利用dfs深度优先搜索解决：</p><ul><li>心里先想象出一棵搜索树</li><li>在节点处判断：<ul><li>如果满足条件：该节点没有超过二维数组范围且是岛屿（用1表示），则把该点置为水（用0表示）以避免重复搜索。并在此节点的基础上，继续向搜索树下面（下面的选择有上下左右四个分支）搜索</li><li>若不满足条件，则返回</li></ul></li><li>一开始时，搜索树的入口：grid[i][j]处若为1，则进入搜索树。用count来计数，每进入一次树，count+=1</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># gird[i][j] 点若是岛屿，则把该点置0，避免后续重复搜索到。然后从该点的上下左右继续搜</span>            <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span>  grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span>                dfs<span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span>        count <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 每进入一次搜索树，cont+=1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 搜索树的入口</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                    dfs<span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>                    count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章：计算机网络</title>
      <link href="/2020/08/28/labuladong/di-liu-zhang-ji-suan-ji-wang-luo/"/>
      <url>/2020/08/28/labuladong/di-liu-zhang-ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<p><a href="https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men" target="_blank" rel="noopener">labuladong 计算机网络</a></p><h1 id="25-张图解：键入网址后，到网页显示，其间发生了什么"><a href="#25-张图解：键入网址后，到网页显示，其间发生了什么" class="headerlink" title="25 张图解：键入网址后，到网页显示，其间发生了什么"></a><a href="https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/25-zhang-tu-jie-jian-ru-wang-zhi-hou-dao-wang-ye-xian-shi-qi-jian-fa-sheng-le-shi-mo#01-gu-dan-xiao-di-http" target="_blank" rel="noopener">25 张图解：键入网址后，到网页显示，其间发生了什么</a></h1><h2 id="解答："><a href="#解答：" class="headerlink" title="解答："></a><a href="https://blog.csdn.net/kongmin_123/article/details/82555936" target="_blank" rel="noopener">解答：</a></h2><ul><li>DNS域名解析<ul><li><strong>查询服务器域名对应的 IP 地址</strong>。因为委托操作系统发送消息时，必须提供通信对象的 IP 地址</li><li>DNS 中的域名都是用句点来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的界限。在域名中，越靠右的位置表示其层级越高</li></ul></li><li>浏览器得到了IP以后，向服务器发送TCP连接<ul><li>TCP 连接的过程，通常称为三次握手，目的是<strong>保证双方都有发送和接收的能力</strong>。</li></ul></li><li>浏览器发送HTTP请求<ul><li>浏览器和服务器建立连接以后，浏览器接着按这个IP地址给服务器发送一个http请求，方式为get，例如访问<code>www.baidu.com</code>。其本质是在建立起的TCP连接中，按照HTTP协议标准<strong>发送一个索要网页的请求</strong></li></ul></li><li>服务器处理请求<ul><li>服务器（经过物理层→数据链路层→网络层→传输层→应用层）收到浏览器的请求以后，会解析这个请求（读请求头），然后生成一个响应头和具体响应内容。接着服务器会传回来一个响应头和一个响应，响应头告诉了浏览器一些必要的信息 </li></ul></li><li>浏览器解析渲染页面</li><li>关闭TCP连接，即TCP的四次挥手<br><img src="https://img-blog.csdnimg.cn/20200828163409378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></li></ul><h1 id="30张图解：HTTP常见面试题"><a href="#30张图解：HTTP常见面试题" class="headerlink" title="30张图解：HTTP常见面试题"></a><a href="https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/30-zhang-tu-jie-http-chang-jian-mian-shi-ti" target="_blank" rel="noopener">30张图解：HTTP常见面试题</a></h1><h2 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h2><ul><li>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」，是一个<strong>双向协议</strong>。</li></ul><h2 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h2><ul><li>GET 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等</li><li>POST 方法则是相反操作，它向 URI <strong>指定的资源提交数据</strong>，数据就放在报文的 body 里</li><li>GET 方法就是<strong>安全且幂等</strong>的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以<strong>不是幂等的</strong></li></ul><h2 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h2><ul><li>HTTP 是超文本传输协议，信息是明文传输，<strong>存在安全风险</strong>的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 <strong>TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议</strong>，使得报文能够加密传输<ul><li>HTTPS 实现了<strong>信息加密，校验机制，身份证书</strong>等功能，使传输更安全</li></ul></li><li>HTTP 连接建立相对简单， <strong>TCP 三次握手之后便可进行 HTTP 的报文传输</strong>。而 HTTPS 在 TCP 三次握手之后，<strong>还需进行 SSL/TLS 的握手过程</strong>，才可进入加密报文传输</li><li>HTTP 的端口号是 80，HTTPS 的端口号是 443</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li></ul><p><img src="https://img-blog.csdnimg.cn/20200828162303211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><h2 id="HTTPS-是如何解决HTTP的窃听，冒充，篡改等风险的？"><a href="#HTTPS-是如何解决HTTP的窃听，冒充，篡改等风险的？" class="headerlink" title="HTTPS 是如何解决HTTP的窃听，冒充，篡改等风险的？"></a>HTTPS 是如何解决HTTP的窃听，冒充，篡改等风险的？</h2><ul><li><strong>混合加密</strong>的方式实现信息的机密性，解决了窃听的风险</li><li>将<strong>服务器公钥放入到数字证书</strong>中，解决了冒充的风险</li><li><strong>摘要算法的方式</strong>来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险</li></ul><h1 id="30张图解：TCP重传、滑动窗口、流量控制、拥塞控制"><a href="#30张图解：TCP重传、滑动窗口、流量控制、拥塞控制" class="headerlink" title="30张图解：TCP重传、滑动窗口、流量控制、拥塞控制"></a><a href="https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/30-zhang-tu-jie-tcp-zhong-chuan-hua-dong-chuang-kou-liu-liang-kong-zhi-yong-sai-kong-zhi-fa-chou" target="_blank" rel="noopener">30张图解：TCP重传、滑动窗口、流量控制、拥塞控制</a></h1><h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息<br><img src="https://img-blog.csdnimg.cn/20200828170035866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br>但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？<br>所以 TCP 针对数据包丢失的情况，会用重传机制解决：<br>    1.    超时重传 ：当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据<br>    2.    快速重传：不以时间为驱动，而是以<strong>数据</strong>驱动重传。但是这样的话，发送方不知道哪些数据收到了，哪些没收到<br>    3.    SACK（ Selective Acknowledgment 选择性确认）: 可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据<br>    4.    Duplicate-SACK：使用了 SACK 来告诉「发送方」有哪些数据被重复接收了</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul><li><p>TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。但这样的话，<strong>数据包的往返时间越长，通信的效率就越低</strong>。所以用滑动窗口解决该问题。窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>（TCP窗口的最大值为2的16次方，即65535字节）</p></li><li><p>TCP 头里有一个字段叫 Window，也就是窗口大小。这个字段是<strong>接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</p></li><li><p>流量控制</p><ul><li>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果对方处理不过来，那么就会导致触发重发机制，浪费资源</li><li>TCP 提供一种机制可以让「发送方」根据「接收方」的<strong>实际接收能力控制发送的数据量</strong>，这就是所谓的<strong>流量控制</strong></li></ul></li><li><p>拥塞控制</p><ul><li>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</li><li>于是，就有了拥塞控制，控制的目的就是<strong>避免「发送方」的数据填满整个网络</strong>。 拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的</li></ul></li></ul><h1 id="40张图解：TCP三次握手和四次挥手面试题"><a href="#40张图解：TCP三次握手和四次挥手面试题" class="headerlink" title="40张图解：TCP三次握手和四次挥手面试题"></a><a href="https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/40-zhang-tu-jie-tcp-san-ci-wo-shou-he-si-ci-hui-shou-mian-shi-ti" target="_blank" rel="noopener">40张图解：TCP三次握手和四次挥手面试题</a></h1><h2 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a>TCP 和 UDP 区别</h2><ul><li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）</li><li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信</li></ul><ol><li>连接<br>TCP 是面向连接的传输层协议，传输数据前先要建立连接。<br>UDP 是不需要连接，即刻传输数据。</li><li>服务对象<br>TCP 是一对一的两点服务，即一条连接只有两个端点。<br>UDP 支持一对一、一对多、多对多的交互通信</li><li>可靠性<br>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。<br>UDP 是尽最大努力交付，不保证可靠交付数据。</li><li>拥塞控制、流量控制<br>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。<br>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li><li>首部开销<br>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。<br>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li><li>传输方式<br>TCP 是流式传输，没有边界，但保证顺序和可靠。<br>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li><li>分片不同<br>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。<br>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，则就需要重传所有的数据包，这样传输效率非常差，所以通常 UDP 的报文应该小于 MTU。</li></ol><h2 id="TCP-和-UDP-应用场景"><a href="#TCP-和-UDP-应用场景" class="headerlink" title="TCP 和 UDP 应用场景"></a>TCP 和 UDP 应用场景</h2><ul><li>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</li></ul><ol><li>FTP 文件传输</li><li>HTTP / HTTPS</li></ol><ul><li>由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</li></ul><ol><li>包总量较少的通信，如 DNS 、SNMP 等</li><li>视频、音频等多媒体通信</li><li>广播通信</li></ol><h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><p><strong>第三次握手是可以携带数据的</strong>，前两次握手是不可以携带数据的<br><img src="https://img-blog.csdnimg.cn/20200828193854391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><h2 id="TCP为什么是三次握手？"><a href="#TCP为什么是三次握手？" class="headerlink" title="TCP为什么是三次握手？"></a>TCP为什么是三次握手？</h2><ul><li>（因为三次握手才能保证双方具有接收和发送的能力）</li><li><strong>三次握手才可以阻止重复历史连接的初始化（主要原因）</strong><ul><li>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵情况下：<ul><li>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；那么此时服务端就会回一个 SYN + ACK 报文给客户端；客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。</li></ul></li><li>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：<ul><li>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 RST 报文，以此中止历史连接；<br>如果不是历史连接，则第三次发送的报文是 ACK 报文，通信双方就会成功建立连接</li></ul></li></ul></li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul><h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p><img src="https://img-blog.csdnimg.cn/20200828203712197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><h2 id="TCP-为什么是四次挥手？"><a href="#TCP-为什么是四次挥手？" class="headerlink" title="TCP 为什么是四次挥手？"></a>TCP 为什么是四次挥手？</h2><ul><li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了<strong>但是还能接收数据</strong></li><li>服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，<strong>而服务端可能还有数据需要处理和发送</strong>，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接</li></ul><h1 id="45张图解：IP基础知识全家桶"><a href="#45张图解：IP基础知识全家桶" class="headerlink" title="45张图解：IP基础知识全家桶"></a><a href="https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/45-zhang-tu-jie-ip-ji-chu-zhi-shi-quan-jia-tong" target="_blank" rel="noopener">45张图解：IP基础知识全家桶</a></h1><h2 id="IP的基本认识"><a href="#IP的基本认识" class="headerlink" title="IP的基本认识"></a>IP的基本认识</h2><ul><li><p>IP 在 TCP/IP 参考模型中处于第三层，也就是<strong>网络层</strong>。网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信。</p></li><li><p>MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。</p></li></ul><p><strong>IP</strong>：整个旅游行程表就<strong>相当于网络层</strong>，充当远程定位的功能，<strong>行程的开始好比源 IP，行程的终点好比目的 IP 地址</strong>。<br><strong>MAC</strong>：在区间内移动相当于<strong>数据链路层</strong>，充当<strong>区间内两个节点传输</strong>的功能，区间内的出发点好比源 MAC 地址，目标地点好比目的 MAC 地址<br><img src="https://img-blog.csdnimg.cn/20200828205359161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><h2 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h2><p>对于 A、B、C 类主要分为两个部分，分别是网络号和主机号<br><img src="https://img-blog.csdnimg.cn/20200828230539759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br><img src="https://img-blog.csdnimg.cn/20200828232212201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br>主机号全为 1 指定某个网络下的所有主机，用于广播<br>主机号全为 0 指定某个网络</p><h2 id="无分类地址-CIDR及子网掩码"><a href="#无分类地址-CIDR及子网掩码" class="headerlink" title="无分类地址 CIDR及子网掩码"></a>无分类地址 CIDR及子网掩码</h2><p><img src="https://img-blog.csdnimg.cn/20200828232734141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br><img src="https://img-blog.csdnimg.cn/20200828232841700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br><img src="https://img-blog.csdnimg.cn/20200828233219102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br>由于子网网络地址被划分成 2 位，那么子网地址就有 4 个，分别是 00、01、10、11。<img src="https://img-blog.csdnimg.cn/20200828233357342.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br><img src="https://img-blog.csdnimg.cn/20200828233433874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><h2 id="公有-IP-地址与私有-IP-地址"><a href="#公有-IP-地址与私有-IP-地址" class="headerlink" title="公有 IP 地址与私有 IP 地址"></a>公有 IP 地址与私有 IP 地址</h2><p><img src="https://img-blog.csdnimg.cn/20200828233532502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><h2 id="IPV4-和IPV6"><a href="#IPV4-和IPV6" class="headerlink" title="IPV4 和IPV6"></a>IPV4 和IPV6</h2><ul><li>IPv4 的地址是 <strong>32 位</strong>的，大约可以提供 42 亿个地址。但是 IPv6 的地址是 <strong>128 位</strong>的，这可分配的地址数量是大的惊人，说个段子 IPv6 可以保证地球上的每粒沙子都能被分配到一个 IP 地址</li><li>IPv6 除了有更多的地址之外，还有更好的安全性和扩展性，说简单点就是 IPv6 相比于 IPv4 能带来更好的网络体验。<ul><li>IPv6 可自动配置，即使没有 DHCP 服务器也可以<strong>实现自动分配IP地址</strong></li><li>IPv6 包头包首部长度采用固定的值 40 字节，去掉了包头校验和，简化了首部结构，<strong>减轻了路由器负荷，大大提高了传输的性能</strong>。</li><li>IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，<strong>大大提升了安全性</strong><br><img src="https://img-blog.csdnimg.cn/20200829125751727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></li></ul></li></ul><h2 id="ARP-（Address-Resolution-Protocol，地址解析协议）"><a href="#ARP-（Address-Resolution-Protocol，地址解析协议）" class="headerlink" title="ARP （Address Resolution Protocol，地址解析协议）"></a>ARP （Address Resolution Protocol，地址解析协议）</h2><p><img src="https://i.loli.net/2020/08/29/GWgYKVaB5NJCu6I.png" alt="20200829232021"></p><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><p>ARP 实现由 IP 地址得到 MAC 地址。</p><ul><li>在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下一跳。然而，网络层的下一层是数据链路层，而链路层实现具体每段链路之间的通信。<strong>所以我们还要知道「下一跳」的 MAC 地址</strong>。</li><li>由于主机的路由表中可以找到下一跳的 IP 地址，所以可以通过 ARP 协议，求得下一跳的 MAC 地址。</li></ul><p>ARP 是借助 ARP 请求与 ARP 响应两种类型的包确定 MAC 地址的：</p><ul><li>主机会<strong>通过广播发送 ARP 请求</strong>，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li><li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就<strong>将自己的 MAC 地址塞入 ARP 响应包</strong>返回给主机。<br><img src="https://img-blog.csdnimg.cn/20200829131607551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯2020笔试记录</title>
      <link href="/2020/08/24/leetcode/others/teng-xun-2020-bi-shi-ji-lu/"/>
      <url>/2020/08/24/leetcode/others/teng-xun-2020-bi-shi-ji-lu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/discuss/486638" target="_blank" rel="noopener">技术研究 数据分析笔试题&amp;题解</a></p><p>（P.S. <a href="https://wandbox.org/" target="_blank" rel="noopener">一个支持多语言在线编译的页面</a>）</p><p><a href="https://blog.csdn.net/qq_22522375/article/details/108189181" target="_blank" rel="noopener">题解1</a><br><a href="https://www.nowcoder.com/discuss/486688?channel=1009&source_id=discuss_terminal_discuss_sim" target="_blank" rel="noopener">题解2（python实现）</a></p><h1 id="1-使括号有效的最小添加"><a href="#1-使括号有效的最小添加" class="headerlink" title="1. 使括号有效的最小添加"></a>1. 使括号有效的最小添加</h1><p><img src="https://img-blog.csdnimg.cn/20200824165931141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><blockquote><p>如果是单类别的括号，就是：<br><a href="https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/solution/python-tong-ji-shi-gua-hao-you-xiao-de-tian-jia-by/" target="_blank" rel="noopener">LeetCode921题</a><br>给定一个由 ‘(‘ 和 ‘)’ 括号组成的字符串 S，我们需要添加最少的括号（ ‘(‘ 或是<br>‘)’，可以在任何位置），以使得到的括号字符串有效。</p><p>从形式上讲，只有满足下面几点之一，括号字符串才是有效的：</p><ul><li>它是一个空字符串，或者 </li><li>它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者 </li><li>它可以被写作 (A)，其中 A是有效字符串。 </li></ul><p>给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minAddToMakeValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'?'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 加一个'?'打底，防止栈为空并且需要pop时报错</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> S<span class="token punctuation">:</span>            <span class="token keyword">if</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'('</span> <span class="token operator">and</span> i<span class="token operator">==</span><span class="token string">')'</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 栈顶为左括号，且当前元素为右括号，可以互相抵消。此时栈顶出栈</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 抵消不了的元素通通入栈</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> ```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><strong>本题解题思路：</strong></p><ul><li>经典区间dp问题，构建一个<code>len(s)*len(s)</code>的二维数组。dp[i][j]代表着从字符串i位置到j位置需要的最小括号匹配数。</li><li>对角线部分（<code>dp[i][i]</code>）为1，从下到上遍历上三角部分，    <code>dp[0][len(s)-1]</code> 为所求结果</li><li>当i&lt;j 时:<ul><li>如果第i个位置和第j个位置的两个括号是匹配的（<code>if((s[i]==&#39;[&#39; &amp;&amp; s[j]==&#39;]&#39;) or (s[i]==&#39;(&#39; &amp;&amp; s[j]==&#39;)&#39;))</code>），那么<code>dp[i][j] = dp[i+1][j-1]</code>，相当于两边分别往里缩了一个；</li><li>如果第i个位置和第j个位置的两个括号无法抵消，则 <code>dp[i][j] = dp[i][k]+dp[k+1][j]</code>  k的范围为<code>[i,j)</code></li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>    n<span class="token operator">=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># dp=[[float('inf') for _ in range(n)] for _ in range(n)] # 不可以这样初始化，为什么？</span>    dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 对角线初始化为1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            当i <span class="token operator">&lt;</span> j时            <span class="token comment" spellcheck="true"># 如果能抵消，则 dp[i][j]=dp[i+1][j-1]</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'['</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">']'</span><span class="token punctuation">)</span> <span class="token operator">or</span>  <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'('</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 如果不能抵消，则 dp[i][j] = dp[i][k]+dp[k+1][j] k的范围为[i,j)</span>                temp<span class="token operator">=</span>n                <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;=</span>temp<span class="token punctuation">:</span>                        temp<span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>temp        <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># s=str(input().strip())</span>s<span class="token operator">=</span><span class="token string">'()[)[)(][(]([)]]]((]]'</span>helper<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-求抛物线围成的面积"><a href="#2-求抛物线围成的面积" class="headerlink" title="2. 求抛物线围成的面积"></a>2. 求抛物线围成的面积</h1><p><img src="https://img-blog.csdnimg.cn/20200824184943576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><ul><li>题目要求取6位小数，注意输出的格式：<code>print(&quot;{:.6f}&quot;.format(ans))</code><br><a href="https://www.runoob.com/python/att-string-format.html" target="_blank" rel="noopener">Python format 格式化函数</a></li><li>计算n组面积</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> math<span class="token keyword">def</span> <span class="token function">solution</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>C<span class="token punctuation">,</span>D<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 简单的微积分后，求得的面积</span>    ans <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span>A<span class="token operator">*</span><span class="token punctuation">(</span>D<span class="token operator">**</span><span class="token number">3</span><span class="token operator">-</span>C<span class="token operator">**</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token operator">*</span><span class="token punctuation">(</span>D<span class="token operator">**</span><span class="token number">2</span><span class="token operator">-</span>C<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">+</span>B<span class="token operator">*</span><span class="token punctuation">(</span>D<span class="token operator">-</span>C<span class="token punctuation">)</span>    <span class="token keyword">return</span> ansn <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    ans <span class="token operator">=</span> abs<span class="token punctuation">(</span>solution<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># print("%.6f"%ans)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"{:.6f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-选队长的方案"><a href="#3-选队长的方案" class="headerlink" title="3. 选队长的方案"></a>3. 选队长的方案</h1><p><img src="https://img-blog.csdnimg.cn/20200824193626747.png#pic_center" alt><br>主要考察的知识点：</p><ul><li>排列组合找规律：方案数为 <code>ans=n * 2^(n-1)</code></li><li>用<strong>快速幂</strong>来计算方案数：<a href="https://leetcode-cn.com/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/" target="_blank" rel="noopener">Krahets的快速幂知识点讲解</a></li></ul><p><img src="https://img-blog.csdnimg.cn/20200824194151327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">myPow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 若为0，直接返回结果</span>        res <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span> x<span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> x<span class="token punctuation">,</span> <span class="token operator">-</span>n <span class="token comment" spellcheck="true"># 把n为负数的情况转化成正数</span>        <span class="token keyword">while</span> n<span class="token punctuation">:</span>            <span class="token keyword">if</span> n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>res<span class="token operator">*=</span>x <span class="token comment" spellcheck="true"># res随着x的增大越来越大</span>            x<span class="token operator">*=</span>x             n<span class="token operator">=</span>n<span class="token operator">//</span><span class="token number">2</span> <span class="token comment" spellcheck="true"># 幂每次向下除2，直至为0</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以本题把方案数带进去即可：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">myPow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 求x的n次方</span>    <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>    res <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span> x<span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> x<span class="token punctuation">,</span> <span class="token operator">-</span>n    <span class="token keyword">while</span> n<span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> res <span class="token operator">*=</span> x        x <span class="token operator">*=</span> x        n <span class="token operator">=</span> n <span class="token operator">//</span> <span class="token number">2</span>    <span class="token keyword">return</span> resn<span class="token operator">=</span>int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>output<span class="token operator">=</span>n<span class="token operator">*</span>myPow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">**</span><span class="token number">9</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-计算图的价值"><a href="#4-计算图的价值" class="headerlink" title="4.  计算图的价值"></a>4.  计算图的价值</h1><p><img src="https://img-blog.csdnimg.cn/20200824232431214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br><img src="https://img-blog.csdnimg.cn/20200824232603550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><ul><li>统计小伙伴相同的点对数量。用     <code>defaultdict</code> 实现。<br>（AC 90%）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token comment" spellcheck="true"># 数据输入</span><span class="token triple-quoted-string string">'''4 31 22 32 4'''</span>n<span class="token punctuation">,</span>m<span class="token operator">=</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 统计每个点的对应的小伙伴。主人（1个）：小伙伴（1个或多个）</span>host<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token keyword">for</span> x<span class="token punctuation">,</span>y <span class="token keyword">in</span> res<span class="token punctuation">:</span>    host<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 键为x对应的小伙伴</span>    host<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print(host) # defaultdict(&lt;class 'list'>, {1: [2], 2: [1, 3, 4], 3: [2], 4: [2]})</span><span class="token comment" spellcheck="true"># 统计小伙伴相同的（主人）键。此时，小伙伴(处理过了，是独特的1个名称)：主人（1个或多个）</span>partner<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token keyword">for</span> u<span class="token punctuation">,</span>v <span class="token keyword">in</span> host<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    v<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span>sorted<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 小伙伴从  [1,3,4]-> 134</span>    partner<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print(partner) # defaultdict(&lt;class 'list'>, {'2': [1, 3, 4], '134': [2]})</span><span class="token comment" spellcheck="true"># partner中，主人数>1的才会对图产生价值 （1:2，然后 2:1 的这种无价值）</span>ans<span class="token operator">=</span><span class="token number">0</span><span class="token keyword">for</span> v<span class="token punctuation">,</span>u <span class="token keyword">in</span> partner<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    hostLen<span class="token operator">=</span>len<span class="token punctuation">(</span>u<span class="token punctuation">)</span>    <span class="token keyword">if</span> hostLen<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 从n种样品中 取 2种，无先后区分。则一共有 n*（n-1）/2 种组合</span>        ans<span class="token operator">+=</span>hostLen<span class="token operator">*</span><span class="token punctuation">(</span>hostLen<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token keyword">print</span><span class="token punctuation">(</span>int<span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>921. 使括号有效的最少添加</title>
      <link href="/2020/08/24/leetcode/921-shi-gua-hao-you-xiao-de-zui-shao-tian-jia/"/>
      <url>/2020/08/24/leetcode/921-shi-gua-hao-you-xiao-de-zui-shao-tian-jia/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/" target="_blank" rel="noopener">921. 使括号有效的最少添加</a></p><p>统计不可匹配的括号数 = 使括号有效的最少添加</p><ul><li>加一个’?’打底，防止栈为空并且需要pop时报错</li><li>若栈顶为左括号，且当前元素为右括号，可以互相抵消。此时栈顶出栈</li><li>其他情况：抵消不了. 此时，不管是左括号还是右括号, 通通入栈</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minAddToMakeValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'?'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 加一个'?'打底，防止栈为空并且需要pop时报错</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> S<span class="token punctuation">:</span>            <span class="token keyword">if</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'('</span> <span class="token operator">and</span> i<span class="token operator">==</span><span class="token string">')'</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 栈顶为左括号，且当前元素为右括号，可以互相抵消。此时栈顶出栈</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 抵消不了的元素通通入栈</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美团2020笔试及赛码网输入输出示例</title>
      <link href="/2020/08/22/leetcode/others/mei-tuan-2020-bi-shi-ji-sai-ma-wang-shu-ru-shu-chu/"/>
      <url>/2020/08/22/leetcode/others/mei-tuan-2020-bi-shi-ji-sai-ma-wang-shu-ru-shu-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a><a href="https://www.nowcoder.com/discuss/485689?toCommentId=6937138" target="_blank" rel="noopener">字符匹配</a></h1><p>规则：<br>首字母必须为字母<br>只能包含数字和字母<br>数字和字母必须都有</p><p>(<a href="https://mofanpy.com/tutorials/python-basic/basic/regular-expression/" target="_blank" rel="noopener">莫烦python</a>，也可以用正则表达式解决)</p><p><strong>每一行输入都对应一行输出</strong></p><blockquote><p>输入：<br>第一行：数字（需要判断的行数）<br>后面的行：每行一个字符串<br>输出： Accept 或者 Wrong</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> re<span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">20</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token comment" spellcheck="true"># 判断首字母是否为字母</span>    <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>isalpha<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token comment" spellcheck="true"># 判断字符串是否由字母和数字组成</span>    <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token comment" spellcheck="true"># 判断是否含有数字</span>    numMatch <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span><span class="token string">'[0-9]'</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token operator">not</span> numMatch<span class="token punctuation">.</span>search<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment" spellcheck="true"># # 判断是否含有数字也可以这样：截止现在，只剩下 全字母  和  字母+数字 组合</span>    <span class="token comment" spellcheck="true"># if s.isalpha():</span>    <span class="token comment" spellcheck="true">#     return False</span>    <span class="token comment" spellcheck="true"># else:</span>    <span class="token comment" spellcheck="true">#     return True</span>T <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>    s <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 这里要strip,大坑耽误不少时间</span>    <span class="token keyword">if</span> isValid<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Accept'</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Wrong'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="小美跑腿"><a href="#小美跑腿" class="headerlink" title="小美跑腿"></a>小美跑腿</h1><p><strong>输入所有行后才输出结果</strong></p><blockquote><p>输入示例:<br>输入第一行:<br>[5,2] # 5个订单，只能取2个订单。<br>后面的行：# 赚的钱是第一个数+第二个数<em>2。<br>[1,2] # 1+2</em>2=5元<br>[3,1] # 5<br>[4,2] # 8<br>[4,2] # 8<br>[5,1] # 7<br>输出：<br>要赚最多的钱，返回小美选择的订单序列 </p></blockquote><pre class="line-numbers language-python"><code class="language-python">n<span class="token punctuation">,</span> m <span class="token operator">=</span> map<span class="token punctuation">(</span>int<span class="token punctuation">,</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    v<span class="token punctuation">,</span> w <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    arr<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>v<span class="token operator">+</span>w<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>arr<span class="token operator">=</span>sorted<span class="token punctuation">(</span>arr<span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 按第一个元素降序排列，第一个元素相同时，按第二个元素升序排列</span>res<span class="token operator">=</span><span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span>res<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>394. 字符串解码</title>
      <link href="/2020/08/20/leetcode/394-zi-fu-chuan-jie-ma/"/>
      <url>/2020/08/20/leetcode/394-zi-fu-chuan-jie-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/" target="_blank" rel="noopener">394. 字符串解码</a></h1><p><a href="https://leetcode-cn.com/problems/decode-string/solution/zhan-by-ssk-x/" target="_blank" rel="noopener">方法1：利用栈先进后出原则_更容易理解</a></p><ul><li>digit = []   ###存放数字</li><li>letter = []  ###存放数字前面的字母串</li><li>res = ‘’     ###解码结果。在遍历过程中，也会临时存放字母串<ul><li>遇到左括号时，根据res更新letter，并清空res</li><li>遇到右括号时，更新res </li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decodeString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        digit <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">###存放数字</span>        letter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">###存放数字前面的字母串</span>        res <span class="token operator">=</span> <span class="token string">''</span>     <span class="token comment" spellcheck="true">###左括号后面的字母串</span>        number <span class="token operator">=</span> <span class="token number">0</span>   <span class="token comment" spellcheck="true">###数字</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token string">'0'</span><span class="token operator">&lt;=</span>i<span class="token operator">&lt;=</span><span class="token string">'9'</span><span class="token punctuation">:</span>                number <span class="token operator">=</span> number<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>int<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token string">'['</span><span class="token punctuation">:</span>                digit<span class="token punctuation">.</span>append<span class="token punctuation">(</span>number<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">###当遇见左括号的时候数字结束，这个很关键</span>                letter<span class="token punctuation">.</span>append<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true">###遇见左括号的时候数字前面的字符串也存入栈</span>                number <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">###置零</span>                res <span class="token operator">=</span> <span class="token string">''</span>   <span class="token comment" spellcheck="true">###置空</span>            <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token string">']'</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">###当遇见右括号取出数字前面的字母串，数字，然后数字乘以当前字符串</span>                a <span class="token operator">=</span> digit<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                b <span class="token operator">=</span> letter<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                res <span class="token operator">=</span> b<span class="token operator">+</span>a<span class="token operator">*</span>res            <span class="token keyword">else</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span> i <span class="token comment" spellcheck="true">###当前数字后面的字母串</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode-cn.com/problems/decode-string/solution/394zi-fu-chuan-jie-ma-zhan-by-zhouzhoucn-2/" target="_blank" rel="noopener">方法2：利用递归函数</a></p><ul><li>将 <code>[</code> 和 <code>]</code> 分别作为递归的开启与终止条件。 </li><li>明确递归函数的功能<del>（不要跳进函数内）</del>：<code>decoding(s, index)</code>返回字符串s中，<strong>以index下标开始的后面的子字符串解码后的结果</strong>。<ul><li>当<code>&#39;s[i]==&#39;[&#39;</code>，进入函数，并接受返回值</li><li>当 <code>s[i]==&#39;]&#39;</code>，返回解码后的结果，以及<strong>入口左括号对应的右括号的下标</strong></li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decodeString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">decoding</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># num储存当前遍历到的数字</span>            <span class="token comment" spellcheck="true"># res储存当前遍历到的字符串</span>            num <span class="token operator">=</span> <span class="token string">""</span>            res <span class="token operator">=</span> <span class="token string">""</span>            <span class="token comment" spellcheck="true"># 遍历字符串</span>            <span class="token keyword">while</span> index <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 读取当前字符串</span>                current <span class="token operator">=</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span>                <span class="token comment" spellcheck="true"># index表示当前字符的索引</span>                <span class="token comment" spellcheck="true"># 如果是数字，添加到num</span>                <span class="token keyword">if</span> current<span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    num <span class="token operator">+=</span> current                <span class="token comment" spellcheck="true"># 如果是字母，添加到res</span>                <span class="token keyword">if</span> current<span class="token punctuation">.</span>isalpha<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> current                <span class="token comment" spellcheck="true"># 如果是"["，进入下一层递归并返回下一状态的res</span>                <span class="token comment" spellcheck="true"># 返回的res与当前状态下的num相乘，并添加到当前的res</span>                <span class="token keyword">if</span> current <span class="token operator">==</span> <span class="token string">"["</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># temp表示解码后的结果，index表示下标</span>                    temp<span class="token punctuation">,</span> index <span class="token operator">=</span> decoding<span class="token punctuation">(</span>s<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                    res <span class="token operator">+=</span> int<span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">*</span> temp                    num <span class="token operator">=</span> <span class="token string">""</span>                <span class="token comment" spellcheck="true"># 如果是"]",返回这一状态的res与index</span>                <span class="token keyword">if</span> current <span class="token operator">==</span> <span class="token string">"]"</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># 返回这一状态的res与index</span>                    <span class="token keyword">return</span> res<span class="token punctuation">,</span> index                <span class="token comment" spellcheck="true"># 下标右移，继续下一次循环</span>                index <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 遍历完所有字符串，返回res</span>            <span class="token keyword">return</span> res        <span class="token comment" spellcheck="true"># 开始递归，index初始为0  </span>        <span class="token keyword">return</span> decoding<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2020秋招腾讯后台笔试题（一）"><a href="#2020秋招腾讯后台笔试题（一）" class="headerlink" title="2020秋招腾讯后台笔试题（一）"></a><a href="https://zhuanlan.zhihu.com/p/116482908" target="_blank" rel="noopener">2020秋招腾讯后台笔试题（一）</a></h1><p>该题的思路同上，也是利用栈</p><ul><li><code>|</code>就相当于上题的<code>[</code>的功能。</li><li>而<code>[</code> 在本题没用，用<code>s=s.replace(&#39;[&#39;,&#39;&#39;)</code>删除掉即可 </li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">decodeString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 删除掉'['字符</span>    s<span class="token operator">=</span>s<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'['</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span>    digit <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">###存放数字</span>    letter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">###存放数字前面的字母串</span>    res <span class="token operator">=</span> <span class="token string">''</span>     <span class="token comment" spellcheck="true">###左括号后面的字母串</span>    number <span class="token operator">=</span> <span class="token number">0</span>   <span class="token comment" spellcheck="true">###数字</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> s<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token string">'0'</span><span class="token operator">&lt;=</span>i<span class="token operator">&lt;=</span><span class="token string">'9'</span><span class="token punctuation">:</span>            number <span class="token operator">=</span> number<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>int<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token string">'|'</span><span class="token punctuation">:</span>            digit<span class="token punctuation">.</span>append<span class="token punctuation">(</span>number<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">###当遇见左括号的时候数字结束，这个很关键</span>            letter<span class="token punctuation">.</span>append<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true">###遇见左括号的时候数字前面的字符串也存入栈</span>            number <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">###置零</span>            res <span class="token operator">=</span> <span class="token string">''</span>   <span class="token comment" spellcheck="true">###置空</span>        <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token string">']'</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">###当遇见右括号取出数字前面的字母串，数字，然后数字乘以当前字符串</span>            a <span class="token operator">=</span> digit<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            b <span class="token operator">=</span> letter<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> b<span class="token operator">+</span>a<span class="token operator">*</span>res        <span class="token keyword">else</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> i <span class="token comment" spellcheck="true">###当前数字后面的字母串</span>    <span class="token keyword">return</span> resa<span class="token operator">=</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>decodeString<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>54. 螺旋矩阵</title>
      <link href="/2020/08/20/leetcode/54-luo-xuan-ju-zhen/"/>
      <url>/2020/08/20/leetcode/54-luo-xuan-ju-zhen/</url>
      
        <content type="html"><![CDATA[<h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/" target="_blank" rel="noopener">54. 螺旋矩阵</a></h1><p>顺时针打印矩阵</p><ul><li>设定上下左右四个点</li><li>从左到右彻底遍历一行，然后上边界+1。若上边界超过下边界：跳出</li><li>从上到下彻底遍历一列，然后右边界-1。若左边界超过右边界：跳出</li><li>从右到左彻底遍历一行，然后下边界-1。若上边界超过下边界：跳出</li><li>从下到上彻底遍历一列，然后左边界+1。若左边界超过右边界：跳出</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> matrix<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        t <span class="token operator">=</span> <span class="token number">0</span>        b <span class="token operator">=</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 从左到右</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            t <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> t <span class="token operator">></span> b<span class="token punctuation">:</span> <span class="token keyword">break</span>            <span class="token comment" spellcheck="true"># 从上到下</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>t<span class="token punctuation">,</span> b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>            r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> l <span class="token operator">></span> r<span class="token punctuation">:</span> <span class="token keyword">break</span>            <span class="token comment" spellcheck="true"># 从右到左</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>r<span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            b <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> t <span class="token operator">></span> b<span class="token punctuation">:</span> <span class="token keyword">break</span>            <span class="token comment" spellcheck="true"># 从下到上</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>b<span class="token punctuation">,</span> t <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span>            l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> l <span class="token operator">></span> r<span class="token punctuation">:</span> <span class="token keyword">break</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有种取巧的方法（仅供参考）：</p><ul><li>把第一行pop出来，加到结果中</li><li>把剩下的矩阵逆时针翻转90度，把第一行pop出来，加到结果中。直至结束</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type matrix: List[List[int]]        :rtype: List[int]        """</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> matrix<span class="token punctuation">:</span>            res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>matrix<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            matrix<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>list<span class="token punctuation">,</span>zip<span class="token punctuation">(</span><span class="token operator">*</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2020-8-19-华为笔试题目1"><a href="#2020-8-19-华为笔试题目1" class="headerlink" title="2020.8.19 华为笔试题目1"></a><a href="https://www.nowcoder.com/discuss/482620?type=1&channel=0&source_id=discuss_terminal_discuss_hot" target="_blank" rel="noopener">2020.8.19 华为笔试题目1</a></h1><ul><li>同样是顺时针遍历数组，只是增加了一个判断个位十位的功能</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 判断个位十位的函数</span><span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> n <span class="token operator">%</span> <span class="token number">10</span> <span class="token comment" spellcheck="true"># 个位</span>    b <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">//</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token comment" spellcheck="true"># 十位</span>    <span class="token keyword">return</span> a <span class="token operator">==</span> <span class="token number">7</span> <span class="token operator">and</span> b <span class="token operator">%</span> <span class="token number">2</span><span class="token keyword">def</span> <span class="token function">getRes</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 超过范围，返回</span>    <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">&lt;=</span> M <span class="token operator">&lt;=</span> <span class="token number">1000</span> <span class="token operator">and</span> <span class="token number">10</span> <span class="token operator">&lt;=</span> N <span class="token operator">&lt;=</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[]"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    idx <span class="token operator">=</span> <span class="token number">0</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    l <span class="token operator">=</span> <span class="token number">0</span>    r <span class="token operator">=</span> N <span class="token operator">-</span> <span class="token number">1</span>    t <span class="token operator">=</span> <span class="token number">0</span>    b <span class="token operator">=</span> M <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 从左到右</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            idx <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> helper<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>t<span class="token punctuation">,</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span>        t <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> t <span class="token operator">></span> b<span class="token punctuation">:</span> <span class="token keyword">break</span>        <span class="token comment" spellcheck="true"># 从上到下：</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>t<span class="token punctuation">,</span> b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            idx <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> helper<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span> r<span class="token punctuation">]</span><span class="token punctuation">)</span>        r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">if</span> l <span class="token operator">></span> r<span class="token punctuation">:</span> <span class="token keyword">break</span>        <span class="token comment" spellcheck="true"># 从右到左</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>r<span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            idx <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> helper<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>b<span class="token punctuation">,</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span>        b <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">if</span> t <span class="token operator">></span> b<span class="token punctuation">:</span> <span class="token keyword">break</span>        <span class="token comment" spellcheck="true"># 从下到上</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>b<span class="token punctuation">,</span> t <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            idx <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> helper<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span> l<span class="token punctuation">]</span><span class="token punctuation">)</span>        l <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> l <span class="token operator">></span> r<span class="token punctuation">:</span> <span class="token keyword">break</span>        <span class="token comment" spellcheck="true"># print(res)</span>    res <span class="token operator">=</span> str<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    tmp<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    M<span class="token operator">=</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    N<span class="token operator">=</span>tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    getRes<span class="token punctuation">(</span>M<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网编程常见输入输出练习</title>
      <link href="/2020/08/19/leetcode/others/niu-ke-wang-bian-cheng-chang-jian-shu-ru-shu-chu-lian-xi/"/>
      <url>/2020/08/19/leetcode/others/niu-ke-wang-bian-cheng-chang-jian-shu-ru-shu-chu-lian-xi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5649#question" target="_blank" rel="noopener">OJ在线编程常见输入输出练习场题目链接</a></p><p><a href="https://www.codeleading.com/article/67893417412/" target="_blank" rel="noopener">python:各种字符输入、数值输入总结、OJ输入输出</a></p><h1 id="A-B-1"><a href="#A-B-1" class="headerlink" title="A+B(1)"></a>A+B(1)</h1><ul><li>可以输入无数次</li><li>每次输入一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200822232853963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">for</span> line <span class="token keyword">in</span> sys<span class="token punctuation">.</span>stdin<span class="token punctuation">:</span>    a<span class="token punctuation">,</span> b <span class="token operator">=</span> map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">for</span> line <span class="token keyword">in</span> sys<span class="token punctuation">.</span>stdin<span class="token punctuation">:</span>    a <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># a是这样的：['1','2']</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>int<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> int<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        a<span class="token punctuation">,</span>b<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="A-B-2"><a href="#A-B-2" class="headerlink" title="A+B(2)"></a>A+B(2)</h1><ul><li>可以输入<code>t</code>次</li><li>每次输入一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200823080711526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python">t<span class="token operator">=</span>int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>    a<span class="token punctuation">,</span>b<span class="token operator">=</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># a,b=list(map(int,input().strip().split())) # 也可以</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="A-B-3"><a href="#A-B-3" class="headerlink" title="A+B(3)"></a>A+B(3)</h1><ul><li>可以输入无数次, 但遇到 输入为0 0 时，结束输入 （跳出循环） </li><li>每次输入一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/2020082308113630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        a<span class="token punctuation">,</span>b<span class="token operator">=</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> a<span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">and</span> b<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="A-B-4"><a href="#A-B-4" class="headerlink" title="A+B(4)"></a>A+B(4)</h1><ul><li><p>可以输入无数次, 但如果输入的第一个元素为0，结束输入（跳出循环） </p></li><li><p>每次输入一行后，输出一行结果</p><p><img src="https://img-blog.csdnimg.cn/20200823081848657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        l <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">(</span>l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="A-B-5"><a href="#A-B-5" class="headerlink" title="A+B(5)"></a>A+B(5)</h1><ul><li>可以输入<code>t</code>次</li><li>每次输入一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200823083446835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python">t<span class="token operator">=</span>int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>    l<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">(</span>l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="A-B-6"><a href="#A-B-6" class="headerlink" title="A+B(6)"></a>A+B(6)</h1><ul><li>可以输入无数次</li><li>每次输入一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200823084416906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        l<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">(</span>l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="A-B-7"><a href="#A-B-7" class="headerlink" title="A+B(7)"></a>A+B(7)</h1><ul><li>可以输入无数次</li><li>每次输入一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200823084921151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        l <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> EOFError<span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="字符串排序-1"><a href="#字符串排序-1" class="headerlink" title="字符串排序(1)"></a>字符串排序(1)</h1><ul><li>输入有两行，第一行表示字符串的个数<code>n</code>，第二行是输入的<code>n</code>个字符串</li><li>每次完整输入后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200823090055420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python">n<span class="token operator">=</span>int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>res<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>res<span class="token operator">=</span>sorted<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># res=" ".join(res)</span>res<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="字符串排序-2"><a href="#字符串排序-2" class="headerlink" title="字符串排序(2)"></a>字符串排序(2)</h1><ul><li>可以输入无数次 </li><li>每次输入（空格隔开）一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200823091047706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        l<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        l<span class="token operator">=</span>sorted<span class="token punctuation">(</span>l<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="字符串排序-3"><a href="#字符串排序-3" class="headerlink" title="字符串排序(3)"></a>字符串排序(3)</h1><ul><li>可以输入无数次 </li><li>每次输入（逗号隔开）一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/2020082309124959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        l<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        l<span class="token operator">=</span>sorted<span class="token punctuation">(</span>l<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="当输入的行数不确定时"><a href="#当输入的行数不确定时" class="headerlink" title="当输入的行数不确定时"></a>当输入的行数不确定时</h1><p>输入示例：<br>1 2回车<br>3 4回车<br>回车</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sysres<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    line <span class="token operator">=</span> sys<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 读取该行的内容 如 1空格2</span>    <span class="token keyword">if</span> <span class="token operator">not</span> line<span class="token punctuation">:</span>        <span class="token keyword">break</span>    lineList <span class="token operator">=</span> str<span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 以空格间开</span>    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>lineList<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># [['1', '2'], ['3', '4']]</span>resNum<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> res<span class="token punctuation">:</span>    i<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>    resNum<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>resNum<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [[1, 2], [3, 4]]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何去除有序数组的重复元素</title>
      <link href="/2020/08/18/labuladong/di-si-zhang-ru-he-qu-chu-you-xu-shu-zu-de-chong-fu-yuan-su/"/>
      <url>/2020/08/18/labuladong/di-si-zhang-ru-he-qu-chu-you-xu-shu-zu-de-chong-fu-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/ru-he-qu-chu-you-xu-shu-zu-de-zhong-fu-yuan-su" target="_blank" rel="noopener">如何去除有序数组的重复元素</a></p><p>用<strong>快慢指针</strong>解决问题（两种初始化都可以）<br>初始化时：</p><pre class="line-numbers language-python"><code class="language-python">slow<span class="token punctuation">,</span>fast<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>slow<span class="token punctuation">,</span>fast<span class="token operator">=</span>head<span class="token punctuation">,</span>head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-python"><code class="language-python">slow<span class="token punctuation">,</span>fast<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span>slow<span class="token punctuation">,</span>fast<span class="token operator">=</span>head<span class="token punctuation">,</span>head<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>快指针在前，慢指针在后。快指针在每次前进时，如果和慢指针的元素不同，则慢指针跳1格，然后把快指针的元素赋给慢指针</li></ul><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># nums = [0,0,1,1,1,2,2,3,3,4]</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token number">0</span>        slow<span class="token punctuation">,</span>fast<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">while</span> fast<span class="token operator">&lt;</span>n<span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token operator">!=</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">:</span>                slow <span class="token operator">+=</span> <span class="token number">1</span>                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span>            fast<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> slow<span class="token operator">+</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: ListNode        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> head<span class="token punctuation">:</span> <span class="token keyword">return</span> None        slow<span class="token operator">=</span>head        fast<span class="token operator">=</span>head<span class="token punctuation">.</span>next        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">if</span> slow<span class="token punctuation">.</span>val<span class="token operator">!=</span>fast<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next                slow<span class="token punctuation">.</span>val<span class="token operator">=</span>fast<span class="token punctuation">.</span>val            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next        slow<span class="token punctuation">.</span>next<span class="token operator">=</span>None        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何高效解决接雨水问题</title>
      <link href="/2020/08/17/labuladong/di-si-zhang-ru-he-gao-xiao-jie-jue-jie-yu-shui-wen-ti/"/>
      <url>/2020/08/17/labuladong/di-si-zhang-ru-he-gao-xiao-jie-jue-jie-yu-shui-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/jie-yu-shui" target="_blank" rel="noopener">如何高效解决接雨水问题</a></p><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></p><p>我们开两个数组 r_max 和 l_max 充当备忘录</p><ul><li>l_max[i] 表示位置 i 左边最高的柱子高度（包括本身在内，正着遍历）， r_max[i] 表示位置 i 右边最高的柱子高度（包括本身在内，倒着遍历）。位置 i 能保存的最大的水柱高度就是 <code>min(l_max, r_max)- height[i]</code></li><li>预先把这两个数组计算好，避免重复计算</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type height: List[int]        :rtype: int        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> height<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true">#初始化</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>height<span class="token punctuation">)</span>        l_max<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>n        r_max<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>n        l_max<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>height<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        r_max<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span>height<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 计算i对应的左右最大值</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            l_max<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>l_max<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            r_max<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>r_max<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 计算面积</span>        ans<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            ans<span class="token operator">+=</span>min<span class="token punctuation">(</span>l_max<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>r_max<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> ans<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何运用二分查找算法</title>
      <link href="/2020/08/17/labuladong/di-si-zhang-ru-he-yun-yong-er-fen-cha-zhao-suan-fa/"/>
      <url>/2020/08/17/labuladong/di-si-zhang-ru-he-yun-yong-er-fen-cha-zhao-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/koko-tou-xiang-jiao" target="_blank" rel="noopener">如何运用二分查找算法</a></p><p><a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a></p><ul><li><p><code>canFinish()</code> 函数：当前速度下，能吃完的小时数（注意要<strong>向上整除</strong>）    </p></li><li><p>最小速度为1，最大速度为数组中最大值。因此利用二分查找框架求h（<strong>h相当于二分查找中的目标值</strong>），注意相等时，也是更新右边界。最后返回左边界</p><p>*  此题需在python3中提交（python3 中 <code>pile/speed</code> 是除法，除不尽时有小数（python2 与此略有不同），然后向上取整）</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minEatingSpeed</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> piles<span class="token punctuation">,</span> H<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type piles: List[int]        :type H: int        :rtype: int        """</span>        <span class="token keyword">import</span> math        <span class="token comment" spellcheck="true"># 当前速度下需要的时间</span>        <span class="token keyword">def</span> <span class="token function">canFinish</span><span class="token punctuation">(</span>piles<span class="token punctuation">,</span> H<span class="token punctuation">,</span> speed<span class="token punctuation">)</span><span class="token punctuation">:</span>            h <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> pile <span class="token keyword">in</span> piles<span class="token punctuation">:</span>                h <span class="token operator">+=</span> math<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>pile <span class="token operator">/</span> speed<span class="token punctuation">)</span>            <span class="token keyword">return</span> h        <span class="token comment" spellcheck="true"># 二分查找</span>        l <span class="token operator">=</span> <span class="token number">1</span>        r <span class="token operator">=</span> max<span class="token punctuation">(</span>piles<span class="token punctuation">)</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>            speed <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> canFinish<span class="token punctuation">(</span>piles<span class="token punctuation">,</span> H<span class="token punctuation">,</span> speed<span class="token punctuation">)</span> <span class="token operator">></span> H<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 速度太慢</span>                l <span class="token operator">=</span> speed <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">elif</span> canFinish<span class="token punctuation">(</span>piles<span class="token punctuation">,</span> H<span class="token punctuation">,</span> speed<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> H<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 速度太快</span>                <span class="token comment" spellcheck="true"># 因为是找左边界，所以若相等，更新右边界</span>                r <span class="token operator">=</span> speed <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">return</span> l        <span class="token comment" spellcheck="true"># # while 循环也可以写成这样：</span>        <span class="token comment" spellcheck="true"># while l&lt;=r:</span>        <span class="token comment" spellcheck="true">#     speed=l+(r-l)//2</span>        <span class="token comment" spellcheck="true">#     if canFinish(piles,H,speed)>H:</span>        <span class="token comment" spellcheck="true">#         l=speed+1</span>        <span class="token comment" spellcheck="true">#     elif canFinish(piles,H,speed)&lt;H:</span>        <span class="token comment" spellcheck="true">#         r=speed-1</span>        <span class="token comment" spellcheck="true">#     elif canFinish(piles,H,speed)==H:</span>        <span class="token comment" spellcheck="true">#         return speed</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank" rel="noopener">1011.在D天内送达包裹的能力</a></p><p>与上题思路相同，只是</p><ul><li><p>cap 的最小值和最大值分别为 max(weights) 和 sum(weights)。</p></li><li><p>按照有无超过容量来更新完成的天数<code>d</code></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">def</span> <span class="token function">shipWithinDays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> weights<span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token triple-quoted-string string">"""     :type weights: List[int]     :type D: int     :rtype: int     """</span>     <span class="token comment" spellcheck="true"># 当前capacity下完成的天数</span>     <span class="token keyword">def</span> <span class="token function">canFinish</span><span class="token punctuation">(</span>weights<span class="token punctuation">,</span>cap<span class="token punctuation">)</span><span class="token punctuation">:</span>         cur_w<span class="token operator">=</span><span class="token number">0</span>         d<span class="token operator">=</span><span class="token number">1</span>         <span class="token keyword">for</span> i <span class="token keyword">in</span> weights<span class="token punctuation">:</span>             <span class="token keyword">if</span> cur_w<span class="token operator">+</span>i<span class="token operator">></span>cap<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 超过容量了，放不下，天数加1，当前容量更新为i</span>                 d<span class="token operator">+=</span><span class="token number">1</span>                 cur_w<span class="token operator">=</span>i             <span class="token keyword">else</span><span class="token punctuation">:</span>                 cur_w<span class="token operator">+=</span>i <span class="token comment" spellcheck="true"># 没有超过，当前容量+i</span>         <span class="token keyword">return</span> d     <span class="token comment" spellcheck="true"># 二分搜索找左边界</span>     l<span class="token operator">=</span>max<span class="token punctuation">(</span>weights<span class="token punctuation">)</span>     r<span class="token operator">=</span>sum<span class="token punctuation">(</span>weights<span class="token punctuation">)</span>     <span class="token keyword">while</span> l<span class="token operator">&lt;=</span>r<span class="token punctuation">:</span>         cap<span class="token operator">=</span>l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>         <span class="token keyword">if</span> canFinish<span class="token punctuation">(</span>weights<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token operator">></span>D<span class="token punctuation">:</span>             l<span class="token operator">=</span>cap<span class="token operator">+</span><span class="token number">1</span>         <span class="token keyword">elif</span> canFinish<span class="token punctuation">(</span>weights<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token operator">&lt;=</span>D<span class="token punctuation">:</span>             r<span class="token operator">=</span>cap<span class="token number">-1</span>     <span class="token keyword">return</span> l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何高效寻找素数</title>
      <link href="/2020/08/17/labuladong/di-si-zhang-ru-he-gao-xiao-xun-zhao-su-shu/"/>
      <url>/2020/08/17/labuladong/di-si-zhang-ru-he-gao-xiao-xun-zhao-su-shu/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/da-yin-su-shu" target="_blank" rel="noopener">如何高效寻找素数</a></p><p><a href="https://leetcode-cn.com/problems/count-primes/solution/qiu-zhi-shu-chao-guo-90-by-powcai/" target="_blank" rel="noopener">204. 计数质数</a></p><p>统计所有<strong>小于非负整数 n</strong> 的质数的数量</p><ul><li>初始化时，给每个位置立一个flag，并初始化为1</li><li>遍历时，对于i而言：<ul><li>如果这个位置的flag为1，说明数字 i  没有被比 i 小的数整除过，说明它是质数，计数器+1。</li><li>i 的倍数一定不是质数，将这些数的flag设置为0</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countPrimes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#给每个位置立一个flag，初始化为1</span>        isPrimes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token comment" spellcheck="true">#result，输出的质数总个数的计数器，初始化为0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true">#循环，从最小质数i开始到n循环</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#如果这个位置的flag为1，说明数字 i  没有被比 i 小的数整除过，说明它是质数，计数器+1</span>            <span class="token keyword">if</span> isPrimes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> res <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true">#下面这几步的思路是， i 的倍数一定不是质数，将这些数的flag设置为0</span>            <span class="token comment" spellcheck="true">#设置倍数 j ，初始化与 i 相等。 因为i也是一点点加上来的，比如 i=5的时候，i 的4倍一定在 i=4 时已经设置为0过。</span>            j <span class="token operator">=</span> i            <span class="token comment" spellcheck="true"># 因为统计的是所有小于非负整数 n 的质数的数量，当 i 的 j 倍 >=n 时，跳出循环</span>            <span class="token keyword">while</span> i <span class="token operator">*</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true">#设置i 的 j 倍的flag为0</span>                isPrimes<span class="token punctuation">[</span>i <span class="token operator">*</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                <span class="token comment" spellcheck="true"># 自增，下一个找 j+1 倍</span>                j <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true">#返回结果</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：递归详解</title>
      <link href="/2020/08/17/labuladong/di-san-zhang-di-gui-xiang-jie/"/>
      <url>/2020/08/17/labuladong/di-san-zhang-di-gui-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/di-gui-xiang-jie" target="_blank" rel="noopener">递归详解</a></p><ul><li>明白一个递归函数的作用并相信它能完成这个任务，千万不要试图跳进细节</li><li>补充递归结束的条件<br><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">路径总和 III</a></li><li><code>pathSum(self, root, sum)</code> : 给定root 和目标值，返回和为目标值的路径总数。选择时，有两种情况： 路径开始时，<strong>选择当前节点/不选择当前节点，只考虑左右孩子</strong><ul><li>结果由3部分构成：以自己开头+（不以自己开头，以左孩子开头）+ （不以自己开头，以右孩子开头）</li></ul></li><li>以自己开头时，<code>count(self,root,sum)</code>:  返回count的个数 （能凑出几个<strong>以该节点为路径开头</strong>，和为目标值的路径总数）<ul><li>结果由3部分构成：自己独挡一面+（自己出力+左孩子出力）+（自己出力+右孩子出力）</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :type sum: int        :rtype: int        """</span>        <span class="token comment" spellcheck="true"># 注意递归结束条件</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 自己为开头的路径数</span>        ro<span class="token operator">=</span>self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>root<span class="token punctuation">,</span>sum<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 左边路径总数（相信他能算出来）</span>        l<span class="token operator">=</span>self<span class="token punctuation">.</span>pathSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>sum<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 右边路径总数（相信他能算出来）</span>        r<span class="token operator">=</span>self<span class="token punctuation">.</span>pathSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>sum<span class="token punctuation">)</span>        res<span class="token operator">=</span>ro<span class="token operator">+</span>l<span class="token operator">+</span>r        <span class="token keyword">return</span> res    <span class="token comment" spellcheck="true"># 返回count的个数 （能凑出几个以该节点为路径开头，和为目标值的路径总数）</span>    <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>root<span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 注意递归结束条件</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 我自己能不能独当一面，作为一条单独的路径呢？</span>        isMe<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>sum <span class="token keyword">else</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 左边的小老弟，你那边能凑几个sum - node.val 呀？</span>        lc<span class="token operator">=</span>self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>sum<span class="token operator">-</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 右边的小老弟，你那边能凑几个sum - node.val 呀？</span>        rc<span class="token operator">=</span>self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>sum<span class="token operator">-</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 以我这个头开始的节点，能凑这么多个</span>        countAll<span class="token operator">=</span>isMe<span class="token operator">+</span>lc<span class="token operator">+</span>rc        <span class="token keyword">return</span> countAll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：信封嵌套问题</title>
      <link href="/2020/08/16/labuladong/di-san-zhang-xin-feng-qian-tao-wen-ti/"/>
      <url>/2020/08/16/labuladong/di-san-zhang-xin-feng-qian-tao-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/xin-feng-qian-tao-wen-ti#yi-ti-mu-gai-shu" target="_blank" rel="noopener">信封嵌套问题</a></p><p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354. 俄罗斯套娃信封问题</a></p><ul><li>先对宽度（第一个数）进行升序排序，宽度相同时，对高度（第二个数）降序排序 <code>envelopes=sorted(envelopes,key=lambda x:(x[0],-x[1]))</code></li><li>然后对高度求最长上升子序列</li></ul><p>这个解法的关键在于，对于宽度 w 相同的数对，要<strong>对其高度 h 进行降序排序</strong>。因为两个宽度相同的信封不能相互包含的，<strong>逆序排序保证在 w 相同的数对中最多只选取一个。</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxEnvelopes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> envelopes<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># w升序，w相同时h降序</span>        envelopes<span class="token operator">=</span>sorted<span class="token punctuation">(</span>envelopes<span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        h<span class="token operator">=</span><span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> envelopes<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 取h</span>        res<span class="token operator">=</span>self<span class="token punctuation">.</span>lengthOfLIS<span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 调用函数</span>        <span class="token keyword">return</span> res    <span class="token comment" spellcheck="true"># 最长上升子序列函数</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python装饰器</title>
      <link href="/2020/08/13/python/python-zhuang-shi-qi/"/>
      <url>/2020/08/13/python/python-zhuang-shi-qi/</url>
      
        <content type="html"><![CDATA[<ul><li>什么是装饰器？<ul><li>python装饰器用于装饰函数。可以在保留原函数功能的条件下，赋予该函数更丰富的功能（而无需改动原函数）</li></ul></li><li>为什么要用装饰器？<ul><li>可以更便于开发，实现代码复用</li></ul></li><li>装饰器可以解决哪些问题？<ul><li>不破坏原函数的条件下，扩展函数功能(或函数权限)</li></ul></li></ul><blockquote><p>小明每学会一个新本领，他妈妈都会说：“小明太棒了”。所以把妈妈说的话单独写个函数，以后在每次调用时，就可以代码复用</p><ul><li><code>momSaid(func)</code>里的参数为函数</li><li><code>def wrapper(*args,**kwargs)</code>  … <code>return wrapper</code> 可以自动调用函数参数。（如 <code>learnAdd</code>函数有3个参数，<code>learnSubtraction</code> 有两个，但是完全没问题）</li></ul></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">momSaid</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        f<span class="token operator">=</span>func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"算数结果为{}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"妈妈说小明太棒了"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> f    <span class="token keyword">return</span> wrapper@momSaid<span class="token keyword">def</span> <span class="token function">learnAdd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"小明学会了加法"</span><span class="token punctuation">)</span>    res<span class="token operator">=</span>a<span class="token operator">+</span>b<span class="token operator">+</span>c    <span class="token keyword">return</span> res@momSaid<span class="token keyword">def</span> <span class="token function">learnSubtraction</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"小明学会了减法"</span><span class="token punctuation">)</span>    res<span class="token operator">=</span>a<span class="token operator">-</span>b    <span class="token keyword">return</span> reslearnAdd<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"==="</span><span class="token punctuation">)</span>learnSubtraction<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为：</p><pre><code>小明学会了加法算数结果为6妈妈说小明太棒了===小明学会了减法算数结果为1妈妈说小明太棒了</code></pre><blockquote><p>小明和他爸爸都喜欢看动画片。于是小明的妈妈在电视上加了年龄权限，当爸爸在看天线宝宝时，会提醒他别看啦（增加函数权限）。而小明在看时，就不会提醒（不破坏原函数）</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">accessTV</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> age<span class="token operator">&lt;=</span><span class="token number">18</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"小明的爸爸，你都成年啦，别看天线宝宝啦"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> wapper@accessTV<span class="token keyword">def</span> <span class="token function">watchTV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"小明在看天线宝宝"</span><span class="token punctuation">)</span>age<span class="token operator">=</span><span class="token number">10</span>watchTV<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为：</p><pre><code>age小于等于18时，函数输出：小明在看天线宝宝age大于18时，函数输出：小明的爸爸，你都成年啦，别看天线宝宝啦</code></pre><p><a href="https://www.youtube.com/watch?v=QqRvteWBSWg" target="_blank" rel="noopener">参考1</a>,<a href="https://www.zhihu.com/question/26930016/answer/360300235" target="_blank" rel="noopener">参考2</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：前缀和技巧</title>
      <link href="/2020/08/12/labuladong/di-san-zhang-qian-zhui-he-ji-qiao/"/>
      <url>/2020/08/12/labuladong/di-san-zhang-qian-zhui-he-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/qian-zhui-he-ji-qiao" target="_blank" rel="noopener">前缀和技巧</a></p><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/qian-zhui-he-si-xiang-560-he-wei-kde-zi-shu-zu-by-/" target="_blank" rel="noopener">560. 和为K的子数组</a></p><p>方法1：前缀和<br>保存一个数组的前缀和，然后利用差分法得出任意区间段的和</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">subarraySum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>      cnt<span class="token punctuation">,</span> n <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>      pre <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>pre<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> pre<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span> cnt <span class="token operator">+=</span> <span class="token number">1</span>      <span class="token keyword">return</span> cnt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法2：维护更新hashmap</p><ul><li>维护一个 hashmap，hashmap 的 <strong>key 为累加值 acc，value 为累加值 acc 出现的次数</strong>。</li><li>遍历数组，然后不断更新 acc 和 hashmap，如果 acc 等于 k，那么很明显应该+1. 如果 hashmap[acc - k] 存在，我们就把它加到结果中去即可。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">subarraySum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict        record<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        res<span class="token operator">=</span><span class="token number">0</span>        record<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        presum<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            presum<span class="token operator">+=</span>i            <span class="token keyword">if</span> presum<span class="token operator">-</span>k <span class="token keyword">in</span> record<span class="token punctuation">:</span>                res<span class="token operator">+=</span>record<span class="token punctuation">[</span>presum<span class="token operator">-</span>k<span class="token punctuation">]</span>            record<span class="token punctuation">[</span>presum<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：双指针技巧总结</title>
      <link href="/2020/08/12/labuladong/di-san-zhang-shuang-zhi-zhen-ji-qiao-zong-jie/"/>
      <url>/2020/08/12/labuladong/di-san-zhang-shuang-zhi-zhen-ji-qiao-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/shuang-zhi-zhen-ji-qiao" target="_blank" rel="noopener">双指针技巧总结</a></p><p>利用快慢指针或者左右指针解决问题</p><h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></h1><p>利用快慢指针，一开始都指到头结点处，然后每次快指针走两步，慢指针。若最后相遇了，说明有环</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: bool        """</span>        slow<span class="token operator">=</span>head        fast<span class="token operator">=</span>head        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            <span class="token keyword">if</span> slow<span class="token operator">==</span>fast<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/142kuai-man-zhi-zhen-by-821218213/" target="_blank" rel="noopener">142. 环形链表 II</a></h1><p>返回入环的第一个链表</p><ul><li>快慢指针相遇后，把任意一个指针指向头结点，当他们再次相遇时，即是入环口<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token triple-quoted-string string">"""      :type head: ListNode      :rtype: ListNode      """</span>      <span class="token comment" spellcheck="true"># 找到相遇点</span>      slow<span class="token punctuation">,</span>fast<span class="token operator">=</span>head<span class="token punctuation">,</span>head      <span class="token keyword">while</span> fast<span class="token operator">!=</span>None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>          slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next          fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next          <span class="token keyword">if</span> slow<span class="token operator">==</span>fast<span class="token punctuation">:</span>              <span class="token keyword">break</span>      <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> None      slow<span class="token operator">=</span>head      <span class="token keyword">while</span> slow<span class="token operator">!=</span>fast<span class="token punctuation">:</span>          slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next          fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next      <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="倒数第k个节点"><a href="#倒数第k个节点" class="headerlink" title="倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/" target="_blank" rel="noopener">倒数第k个节点</a></h1><ul><li>让快指针先走k步，然后快慢指针一起同步走。快指针到达终点时，慢指针指向的就是倒数第k个节点</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">kthToLast</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :type k: int        :rtype: int        """</span>        fast<span class="token punctuation">,</span>slow<span class="token operator">=</span>head<span class="token punctuation">,</span>head        <span class="token keyword">while</span> k<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#相当于 while k>0</span>            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next            k<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">while</span> fast<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 相当于while fast!=None</span>            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next        <span class="token keyword">return</span> slow<span class="token punctuation">.</span>val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="两数之和2"><a href="#两数之和2" class="headerlink" title="两数之和2"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">两数之和2</a></h1><ul><li>只要数组有序，就应该想到双指针技巧</li><li>类似于二分查找，通过调节左右指针，得到目标和<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>      left<span class="token operator">=</span><span class="token number">0</span>      right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>      <span class="token keyword">while</span> left<span class="token operator">&lt;</span>right<span class="token punctuation">:</span>          <span class="token keyword">if</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>              right<span class="token operator">-=</span><span class="token number">1</span>          <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>              left<span class="token operator">+=</span><span class="token number">1</span>          <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>              <span class="token keyword">return</span> <span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>      <span class="token keyword">else</span><span class="token punctuation">:</span>          <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="两数之和1（无序）"><a href="#两数之和1（无序）" class="headerlink" title="两数之和1（无序）"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和1（无序）</a></h1><ul><li>遍历过程中，利用字典保存值对应的下标。若找到目标和，则返回下标</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type target: int        :rtype: List[int]        """</span>    <span class="token comment" spellcheck="true"># def two_sum(nums,target):</span>        dic<span class="token operator">=</span>dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> target<span class="token operator">-</span>v  <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                <span class="token keyword">return</span> i<span class="token punctuation">,</span> dic<span class="token punctuation">[</span>target<span class="token operator">-</span>v<span class="token punctuation">]</span>            dic<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span>i          <span class="token comment" spellcheck="true"># for i,j in enumerate(nums):</span>        <span class="token comment" spellcheck="true">#     if target-j in nums[i+1:]:</span>        <span class="token comment" spellcheck="true">#         return i, i+1+nums[i+1:].index(target-j)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></h1><ul><li>利用同步赋值，交换左右指针对应的值<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token triple-quoted-string string">"""      :type s: List[str]      :rtype: None Do not return anything, modify s in-place instead.      """</span>      left<span class="token operator">=</span><span class="token number">0</span>      right<span class="token operator">=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>      <span class="token keyword">while</span> left<span class="token operator">&lt;</span>right<span class="token punctuation">:</span>          s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span>          left<span class="token operator">+=</span><span class="token number">1</span>          right<span class="token operator">-=</span><span class="token number">1</span>      <span class="token keyword">return</span> s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：回溯算法最佳实践：括号生成</title>
      <link href="/2020/08/12/labuladong/di-san-zhang-hui-su-suan-fa-zui-jia-shi-jian-gua-hao-sheng-cheng/"/>
      <url>/2020/08/12/labuladong/di-san-zhang-hui-su-suan-fa-zui-jia-shi-jian-gua-hao-sheng-cheng/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/he-fa-kuo-hao-sheng-cheng" target="_blank" rel="noopener">回溯算法最佳实践：括号生成</a></p><p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></p><p>问题转化为：<strong>现在有 2n 个位置，每个位置可以放置字符 ( 或者 )，求生成所有可能的并且 有效的 括号组合</strong></p><ul><li>可用的左括号数量为 left 个，可用的右括号数量为 rgiht 个。cur表示当前字符串状态</li><li>左右括号都能用完，说明是合法的，res中记录当前cur</li><li>剩下的左括号比右括号多，或者括号数量小于0，说明是不合法的，直接return</li><li>回溯：做选择，撤销选择</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type n: int        :rtype: List[str]        """</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        choose<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'('</span><span class="token punctuation">,</span><span class="token string">')'</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>cur<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 还可以放几个左括号/右括号，当前字符串的状态</span>            <span class="token comment" spellcheck="true"># 合法的情况</span>            <span class="token keyword">if</span> left<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> right<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 左右括号都用完了，合法</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token comment" spellcheck="true"># 不合法的情况</span>            <span class="token comment" spellcheck="true"># 剩下的左括号比右括号多，或者括号数量小于0</span>            <span class="token keyword">if</span> left<span class="token operator">></span>right <span class="token operator">or</span> left<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> right<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token comment" spellcheck="true"># 回溯， 有两种方法</span>            <span class="token comment" spellcheck="true"># 方法1：以左括号为例</span>            cur<span class="token operator">=</span>cur<span class="token operator">+</span>choose<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 做选择 ，尝试放左括号</span>            backtrack<span class="token punctuation">(</span>left<span class="token number">-1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>cur<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># </span>            cur<span class="token operator">=</span>cur<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#撤销选择</span>            <span class="token comment" spellcheck="true"># 方法2：以右括号为例，直接在backtrack中进行更新</span>            backtrack<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token number">-1</span><span class="token punctuation">,</span>cur<span class="token operator">+</span>choose<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        backtrack<span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：递归反转链表的一部分</title>
      <link href="/2020/08/12/labuladong/di-er-zhang-di-gui-fan-zhuan-lian-biao-de-yi-bu-fen/"/>
      <url>/2020/08/12/labuladong/di-er-zhang-di-gui-fan-zhuan-lian-biao-de-yi-bu-fen/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/di-gui-fan-zhuan-lian-biao-de-yi-bu-fen" target="_blank" rel="noopener">递归反转链表的一部分</a></p><h1 id="方法1-递归反转链表"><a href="#方法1-递归反转链表" class="headerlink" title="方法1.递归反转链表 "></a>方法1.<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/pythondi-gui-jie-jue-by-clark-12/" target="_blank" rel="noopener"><del>递归反转链表</del> </a></h1><p>（只是说明递归方法的思想，本题优解应参考方法二）</p><blockquote><ul><li>先看例题<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转整个链表</a><ul><li>对于递归算法，最重要的就是<strong>明确递归函数实现的功能</strong><del>（而不是跳进递归中）</del> ，因此，reverseList函数定义为：输入一个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点    </li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 递归结束条件</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None <span class="token operator">or</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span> <span class="token keyword">return</span> head        <span class="token comment" spellcheck="true"># reverseList函数返回反转后的头结点</span>        last<span class="token operator">=</span>self<span class="token punctuation">.</span>reverseList<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span>        head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">=</span>head        head<span class="token punctuation">.</span>next<span class="token operator">=</span>None        <span class="token keyword">return</span> last ```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><p>先用递归实现：       反转以head开头的前n个节点</p></li><li><p>首先，如果 m == 1（因为头结点是从1开始计数的），就相当于反转链表开头的 n 个元素，也就是函数<code>reverseN(head, n)</code>   (也是<code>reverseBetween</code>结束递归的条件)</p></li><li><p>如果 m != 1 怎么办？如果我们把 head 的索引视为 1，那么我们是想从第 m 个元素开始反转；如果把 head.next 的索引视为 1 呢？那么相对于 head.next，反转的区间应该是从第 m - 1 个元素开始的；那么对于 head.next.next 呢……因此有：</p><pre class="line-numbers language-python"><code class="language-python">      <span class="token comment" spellcheck="true"># 如果不是第一个，那么以下一个为头结点开始递归，直到触发m==1递归终止条件</span>      head<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>reverseBetween<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>综上，反转m到n直接的节点的整体代码为：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 先用递归实现：       反转以head开头的前n个节点</span>      <span class="token keyword">def</span> <span class="token function">reverseN</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>              successor <span class="token operator">=</span> head<span class="token punctuation">.</span>next <span class="token comment" spellcheck="true"># 拿到后继节点</span>              <span class="token keyword">return</span> head<span class="token punctuation">,</span> successor          <span class="token comment" spellcheck="true"># 以 head.next 为起点，需要反转前 n - 1 个节点</span>          last<span class="token punctuation">,</span> successor <span class="token operator">=</span> reverseN<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span>          head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head          head<span class="token punctuation">.</span>next <span class="token operator">=</span> successor          <span class="token keyword">return</span> last<span class="token punctuation">,</span> successor      <span class="token keyword">if</span> m <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 递归终止条件</span>          res<span class="token punctuation">,</span> _ <span class="token operator">=</span> reverseN<span class="token punctuation">(</span>head<span class="token punctuation">,</span> n<span class="token punctuation">)</span>          <span class="token keyword">return</span> res      <span class="token comment" spellcheck="true"># 如果不是第一个，那么以下一个为头结点开始递归，直到触发条件</span>      head<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>reverseBetween<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="方法2-找到要翻转部分的链表-将其翻转-再与原链表拼接"><a href="#方法2-找到要翻转部分的链表-将其翻转-再与原链表拼接" class="headerlink" title="方法2. 找到要翻转部分的链表,将其翻转,再与原链表拼接"></a>方法2. <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/liang-chong-fang-fa-by-powcai/" target="_blank" rel="noopener">找到要翻转部分的链表,将其翻转,再与原链表拼接</a></h1></li></ul><blockquote><ol><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/" target="_blank" rel="noopener">复习一下逐个反转链表元素的代码：</a><ul><li>pre -&gt; cur (pre在前，cur 在后)</li><li>把cur的next指向pre，然后pre和cur分别向右跳一格。（利用<strong>同步赋值语句</strong>同时实现这些功能） </li></ul></li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>        pre<span class="token operator">=</span>None        cur<span class="token operator">=</span>head        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>            cur<span class="token punctuation">.</span>next<span class="token punctuation">,</span>pre<span class="token punctuation">,</span>cur<span class="token operator">=</span>pre<span class="token punctuation">,</span>cur<span class="token punctuation">,</span>cur<span class="token punctuation">.</span>next        <span class="token keyword">return</span> pre <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>先添加dummy节点，并连接在头结点前面</li><li>cur跳到位置m处，pre在cur左面</li><li>反转m到n的节点</li><li>连接各节点</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self):</span><span class="token comment" spellcheck="true">#         self.val=x</span><span class="token comment" spellcheck="true">#         self.next=None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        dummy<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        dummy<span class="token punctuation">.</span>next<span class="token operator">=</span>head        pre<span class="token operator">=</span>dummy        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            pre<span class="token operator">=</span>pre<span class="token punctuation">.</span>next        cur<span class="token operator">=</span>pre<span class="token punctuation">.</span>next        node<span class="token operator">=</span>pre        <span class="token comment" spellcheck="true"># node保存m的前一个节点，为后续连接做准备</span>        <span class="token comment" spellcheck="true"># cur为反转的当前节点，node为cur的上一个节点 </span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">-</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#反转m到n的节点</span>            cur<span class="token punctuation">.</span>next<span class="token punctuation">,</span>node<span class="token punctuation">,</span>cur<span class="token operator">=</span>node<span class="token punctuation">,</span>cur<span class="token punctuation">,</span>cur<span class="token punctuation">.</span>next <span class="token comment" spellcheck="true">#注意顺序，cur.next 在最前</span>        <span class="token comment" spellcheck="true">#连接反转后的各节点</span>        pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">=</span>cur        pre<span class="token punctuation">.</span>next<span class="token operator">=</span>node        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：特殊数据结构：单调队列</title>
      <link href="/2020/08/05/labuladong/di-er-zhang-te-shu-shu-ju-jie-gou-dan-diao-dui-lie/"/>
      <url>/2020/08/05/labuladong/di-er-zhang-te-shu-shu-ju-jie-gou-dan-diao-dui-lie/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/dan-tiao-dui-lie" target="_blank" rel="noopener">特殊数据结构：单调队列</a></p><h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/python-deque-by-frankchen250/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></h1><h2 id="方法1：更新滑动窗口法（暴力遍历，超时）"><a href="#方法1：更新滑动窗口法（暴力遍历，超时）" class="headerlink" title="方法1：更新滑动窗口法（暴力遍历，超时）"></a><del>方法1：更新滑动窗口法（暴力遍历，超时）</del></h2><ul><li>滑动窗口没有完全进入数组时，把数据加入窗口中</li><li>窗口完全进入数组后，保存最大值，同时弹出窗口最左侧的元素（即，右边进，左边出，更新窗口），继续进行下一次循环</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        window<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 滑动窗口未完全进入数组，把元素添加到窗口中</span>                window<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                window<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>max<span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 记录窗口中最大值</span>                window<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 弹出窗口最左边的元素</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法二：维护一个递减的单调队列"><a href="#方法二：维护一个递减的单调队列" class="headerlink" title="方法二：维护一个递减的单调队列"></a>方法二：维护一个递减的单调队列</h2><p><strong>踩扁前面比他小的数</strong><br><img src="https://img-blog.csdnimg.cn/20200624150009357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt="图片来自labuladong"><br><img src="https://img-blog.csdnimg.cn/20200624145943325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt="图片来自labuladong"><br><img src="https://img-blog.csdnimg.cn/20200624145958795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt="图片来自labuladong"></p><blockquote><blockquote><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p></blockquote><p>返回滑动窗口中的最大值。</p><p>进阶：</p><p>你能在线性时间复杂度内解决此题吗？</p><p>示例:<br>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7]  解释: </p></blockquote><table><thead><tr><th>滑动窗口的位置</th><th>最大值</th></tr></thead><tbody><tr><td>[1  3  -1] -3  5  3  6  7</td><td>3</td></tr><tr><td>1 [3  -1  -3] 5  3  6  7</td><td>3</td></tr><tr><td>1  3 [-1  -3  5] 3  6  7</td><td>5</td></tr><tr><td>1  3  -1 [-3  5  3] 6  7</td><td>5</td></tr><tr><td>1  3  -1  -3 [5  3  6] 7</td><td>6</td></tr><tr><td>1  3  -1  -3  5 [3  6  7]</td><td>7</td></tr></tbody></table><blockquote><p>遍历过程中，deque中存储的元素：</p><p>deque([1])    （前两次窗口未满）<br>deque([3])      （前两次窗口未满）<br>deque([3, -1])<br>deque([-1, -3])   （当前窗口中的元素为[3,-1,-3],但我们要确保下一个元素能被加到队列中，因此，如果队列中最左边的元素为nums[i - k + 1]，则把它删掉，否则不用删（已经被压扁了））<br>deque([5])<br>deque([5, 3])<br>deque([6])<br>deque([7])</p></blockquote><ul><li>双端队列中存储着压扁后剩下的结果 （确保队列单调递减）</li><li>队列中的最大值有重复时，保留重复（只踩扁比它小的数，相同的不踩，确保次序一致）</li><li><strong>之所以要判断<code>queue[0] == n</code>，是因为我们想删除的队头元素 n 可能已经被「压扁」了，这时候就不用删除了</strong><ul><li>双端队列中最多<strong>存储着<code>k-1</code> 个</strong>元素，以确保下一次循环时，元素能被加到队列中。因此，若加进来的元素一直压不扁队头，但队列已满时，要删掉最左边的队头元素 （如果已经压扁过了，那么<code>queue[0] == nums[i - k + 1]</code>不成立 ,不用删了）</li><li>以滑动窗口位置在<code>1 [3 -1 -3] 5 3 6 7</code>  为例，现在的队列是[3,-1,-3] (-1 和 -3 都没能压扁3，说明这时<code>queue[0] == nums[i - k + 1]</code>，在窗口向右挪动时，这个3就要过时了)，为了给后面的元素腾出空位，把队列最左边的元素删掉，让队列变成[-1,-3]</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">push_num</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 把元素n加入双端队列，小于n的元素被n踩扁</span>            <span class="token keyword">while</span> queue <span class="token operator">and</span> queue<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>n<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">pop_num</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 把最左端的元素n（若存在）弹出双端队列</span>            <span class="token keyword">if</span> queue <span class="token operator">and</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> n<span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 双端队列没有完全进入列表，则把该元素加入队列</span>                push_num<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                push_num<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 把该元素加入队列</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 最左端为最大值</span>                pop_num<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 删除位置为i-k+1的元素 （若已经被压扁了，则不用删了）</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：特殊数据结构：单调栈</title>
      <link href="/2020/08/05/labuladong/di-er-zhang-te-shu-shu-ju-jie-gou-dan-diao-zhan/"/>
      <url>/2020/08/05/labuladong/di-er-zhang-te-shu-shu-ju-jie-gou-dan-diao-zhan/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/dan-tiao-zhan" target="_blank" rel="noopener">特殊数据结构：单调栈</a></p><blockquote><p>文章例题：<br>给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。<br>解释：第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。</p></blockquote><p>这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人站成一列，如何求元素「2」的 Next Greater Number 呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的 Next Greater Number，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。</p><p>这就是单调队列解决问题的模板。<strong>for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个“高个”元素之间的元素排除，因为他们的存在没有意义，前面挡着个“更高”的元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了。</strong></p><p>O(∩_∩)O <strong>也可以用“压扁思想”理解（倒序遍历）：</strong><br>3没有东西压扁，栈为空，所以对应-1。然后3进栈，此时栈为[3]<br>4能压扁3，pop后栈为空，所以对应-1。然后4进栈,此时栈为[4]<br>2不能压扁4，不能pop，栈为[4],所以对应4。然后2进栈，此时栈为[4,2]<br>1不能压扁2和4，不能pop，栈为[4,2],所以对应2。然后1进栈，此时栈为[4,2,1]<br>2能压扁1,2,不能压扁4，栈为[4],所以对应4。<del>然后2进栈，此时栈为[4,2]</del></p><p><img src="https://img-blog.csdnimg.cn/20200623194612914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt="图片来自labuladong"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    ans<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    s<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#倒着往栈里放</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">while</span>  s <span class="token operator">and</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#矮个起开</span>            s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">if</span>  s <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>        s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 进队，接受之后的身高判定</span>    <span class="token keyword">return</span> ansnums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ans:"</span><span class="token punctuation">,</span>nextGreaterElement<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果输出（栈里的元素始终单调递减）：</p><blockquote><p>每次的s:<br>[]<br>[3]<br>[4]<br>[4, 2]<br>[4, 2, 1]</p><p>ans: [4, 2, 4, -1, -1]</p></blockquote><h1 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">503. 下一个更大元素 II</a></h1><ul><li>从<strong>最后一个</strong>元素开始逆序遍历，维护一个单调递减的<strong>栈</strong>。</li><li>因为这个栈是<strong>先进后出</strong>，且<strong>单调递减</strong>的，所以弹出栈中<strong>小于等于</strong>当前元素的值后，栈顶的元素就是找到的结果</li><li>把<strong>当前元素入栈</strong>，这样，它前面的元素才能和它继续比较 </li><li>根据不同输出结果的要求，栈中存放当前元素对应的信息，此题存放<strong>当前元素</strong></li></ul><blockquote><p>以 [2,1,2,4,3] 为例，<code>nums*2</code> 后得[2,1,2,,4,3,2,1,2,4,3] （扩充数组，以便求取最后一个值对应的结果）。<br>当前值对应的结果为栈中当前值所在的<strong>前一个</strong>元素（记录结果后才把当前值入栈），当前值前面没有元素，则结果为-1</p><p>则逆序遍历过程中：<br>当前值为：3，加入当前值后对应的栈为[3]   （无解，-1）<br>当前值为：4，加入当前值后对应的栈为[4] （无解，-1）<br>当前值为：2，加入当前值后对应的栈为[<strong>4</strong>, 2]<br>当前值为：1，加入当前值后对应的栈为[4, <strong>2</strong>, 1]<br>当前值为：2，加入当前值后对应的栈为[<strong>4</strong>, 2]<br><em>当前值为：3，加入当前值后对应的栈为[<strong>4</strong>, 3]<br>当前值为：4，加入当前值后对应的栈为[4]   （无解，-1）<br>当前值为：2，加入当前值后对应的栈为[<strong>4</strong>, 2]<br>当前值为：1，加入当前值后对应的栈为[4, <strong>2</strong>, 1]<br>当前值为：2，加入当前值后对应的栈为[<strong>4</strong>, 2]</em></p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nextGreaterElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[int]        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        nums<span class="token operator">=</span>nums<span class="token operator">*</span><span class="token number">2</span>  <span class="token comment" spellcheck="true"># 扩充数组</span>        ans<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 初始化</span>        s<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 逆序遍历</span>            <span class="token keyword">while</span> s <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 1.弹出栈中小于等于当前元素的值</span>                s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> s <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment" spellcheck="true"># 2.弹出不符合的元素后，栈顶元素就是所求的结果</span>            s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 3. 当前元素入栈，这样，它前面的元素才能和它继续比较</span>        <span class="token keyword">return</span> ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I</a></h1><ul><li>该题与上题的区别是： <ul><li>上题直接给定列表，在逆序遍历的同时，更新单调栈</li><li>本题中，对任意的nums1[i], 需要找到当前元素在nums2 中的位置，并把该位置及其后面的元素取出来并反转后作为栈<code>s</code> 中的内容 （<code>nums2[nums2.index(nums1[i]):][::-1]</code>）,然后进行比较。 <ul><li>（这里并不是维护单调递减的栈，而是把找到的反转栈从尾部开始逐个弹出不符合条件的元素，最终得到结果）</li></ul></li><li>根据不同输出结果的要求，栈中存放当前元素的信息，此题存放<strong>当前元素在nums2中对应的本身及其后面的元素（并反转）</strong></li></ul></li></ul><blockquote><p>以 nums1=[4,1,2]， nums2=[1,3,4,2] 为例，<br>则逆序遍历过程中：<br>当前值为2,对应的反转后的栈为[2]<br>当前值为1,对应的反转后的栈为[2, 4, 3, 1]<br>（解释：<em>nums2中找到1的位置，1及其1后面的元素为[1,3,4,2],反转后为[2,4,3,1]）</em><br>当前值为4,对应的反转后的栈为[2, 4]</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">,</span> nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums1<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#若为空数组，则返回</span>        ans<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#逆序遍历</span>            <span class="token comment" spellcheck="true"># 用反转，使得pop的顺序一致</span>            <span class="token comment" spellcheck="true"># 比如1 要和[1,3,4,2]比，输出3</span>            <span class="token comment" spellcheck="true"># 则反转后为[2,4,3,1], 弹1，得到3为符合条件的值</span>            s<span class="token operator">=</span>nums2<span class="token punctuation">[</span>nums2<span class="token punctuation">.</span>index<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 找到每个元素对应的栈，并反转</span>            <span class="token keyword">while</span> s <span class="token operator">and</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 1.弹出栈中小于等于当前元素的值</span>                s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#矮个起开</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> s <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment" spellcheck="true"># 2.弹出不符合的元素后，栈顶元素就是所求的结果</span>        <span class="token keyword">return</span> ans<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739.每日温度</a></h1><ul><li>用栈记录的是list中元素的index，而不是list中元素值本身 （与503题类似，根据不同输出结果的要求，栈中存放当前元素的信息，此题存放<strong>当前元素的index下标</strong>）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type T: List[int]        :rtype: List[int]        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> T <span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        ans<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        s<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 这里放元素索引，而不是元素</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> s <span class="token operator">and</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>T<span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>i <span class="token keyword">if</span> s <span class="token keyword">else</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 得到索引间距</span>            s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 放入索引</span>        <span class="token comment" spellcheck="true"># print(ans)</span>        <span class="token keyword">return</span> ansT<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">73</span><span class="token punctuation">,</span> <span class="token number">74</span><span class="token punctuation">,</span> <span class="token number">75</span><span class="token punctuation">,</span> <span class="token number">71</span><span class="token punctuation">,</span> <span class="token number">69</span><span class="token punctuation">,</span> <span class="token number">72</span><span class="token punctuation">,</span> <span class="token number">76</span><span class="token punctuation">,</span> <span class="token number">73</span><span class="token punctuation">]</span>so<span class="token operator">=</span>Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>so<span class="token punctuation">.</span>dailyTemperatures<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：如何计算完全二叉树的节点数</title>
      <link href="/2020/08/02/labuladong/di-er-zhang-ru-he-ji-suan-wan-quan-er-cha-shu-de-jie-dian-shu/"/>
      <url>/2020/08/02/labuladong/di-er-zhang-ru-he-ji-suan-wan-quan-er-cha-shu-de-jie-dian-shu/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://mp.weixin.qq.com/s/xW2fbE3v4JhMSKfxoxIHBg" target="_blank" rel="noopener">如何计算完全二叉树的节点数</a></p><h1 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></h1><ul><li>完全二叉树都是<strong>紧凑靠左排列</strong>的</li><li>满二叉树<strong>每一层都是满的</strong> （除底层的叶子节点外，左右孩子都有），<strong>是一种特殊的完全二叉树</strong></li></ul><p>遍历二叉树节点时：</p><ol><li>若是普通的二叉树，则在遍历节点时计数即可</li><li>若是满二叉树，则说明左右子树的高度相等，节点个数=2^高度-1</li></ol><p>因此，若判断该完全二叉树是满二叉树，则用情况2，否则用情况1</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        l<span class="token punctuation">,</span>r<span class="token operator">=</span>root<span class="token punctuation">,</span>root        hl<span class="token punctuation">,</span>hr<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        <span class="token keyword">while</span> l<span class="token operator">!=</span>None<span class="token punctuation">:</span>            l<span class="token operator">=</span>l<span class="token punctuation">.</span>left            hl<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">while</span> r<span class="token operator">!=</span>None<span class="token punctuation">:</span>            r<span class="token operator">=</span>r<span class="token punctuation">.</span>right            hr<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">if</span> hl<span class="token operator">==</span>hr<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 左右子树高度相等，是满二叉树，用公式计算</span>            <span class="token keyword">return</span> pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>hl<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>self<span class="token punctuation">.</span>countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">+</span>self<span class="token punctuation">.</span>countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 普通二叉树，用递归方法计算</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：二叉搜索树操作集锦</title>
      <link href="/2020/08/02/labuladong/di-er-zhang-er-cha-sou-suo-shu-cao-zuo-ji-jin/"/>
      <url>/2020/08/02/labuladong/di-er-zhang-er-cha-sou-suo-shu-cao-zuo-ji-jin/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/er-cha-sou-suo-shu-cao-zuo-ji-jin" target="_blank" rel="noopener">二叉搜索树操作集锦</a></p><ul><li><p>二叉树</p><ul><li>二叉树算法设计的总路线：<strong>把当前节点要做的事做好，其他的交给递归框架，不用当前节点操心。</strong>    （可以理解成<strong>递归</strong>方法的应用）<ul><li>明确递归结束的条件 （已经到了叶子节点）</li><li>把root该做的事情做完， 然后左右子节点递归调用该方法</li></ul></li><li>如果当前节点会对下面的子节点<strong>有整体影响</strong>，可以通过<strong>辅助函数增长参数列表</strong>，借助参数传递信息。<pre class="line-numbers language-python"><code class="language-python">void traverse<span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">//</span> root 需要做什么？在这做。<span class="token operator">//</span> 其他的不用 root 操心，抛给框架traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>二叉搜索树</p><ul><li>定义：任意<strong>节点的值要大于等于左子树所有节点</strong>的值，且要<strong>小于等于右子树的所有节点</strong>的值。</li><li>因此，<strong>中序遍历</strong>二叉搜索树后，可以得到<strong>递增</strong>数组。<pre class="line-numbers language-python"><code class="language-python">void BST<span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> int target<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">==</span> target<span class="token punctuation">)</span>  <span class="token operator">//</span> 找到目标，做点什么<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> target<span class="token punctuation">)</span>   BST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> target<span class="token punctuation">)</span>  BST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h1 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/solution/ji-yu-xie-shu-suan-fa-de-tao-lu-kuang-jia-de-pytho/" target="_blank" rel="noopener">100. 相同的树</a></h1><ul><li>函数内先判断两个root节点是否相等，然后递归调用该函数，判断左右子节点是否相等</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type p: TreeNode        :type q: TreeNode        :rtype: bool        """</span>        <span class="token keyword">if</span> p<span class="token operator">==</span>None <span class="token operator">and</span> q <span class="token operator">==</span>None<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span> <span class="token comment" spellcheck="true"># 都为空节点</span>        <span class="token keyword">if</span> p<span class="token operator">==</span>None <span class="token operator">or</span> q <span class="token operator">==</span>None<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span> <span class="token comment" spellcheck="true"># 其中一个为空节点</span>        <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">!=</span>q<span class="token punctuation">.</span>val<span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token boolean">False</span> <span class="token comment" spellcheck="true"># 值不相等</span>        <span class="token comment" spellcheck="true"># 调用递归，判断左右子树是否都满足isSameTree</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>isSameTree<span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">,</span>q<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>isSameTree<span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">,</span>q<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="面试题-04-05-合法二叉搜索树"><a href="#面试题-04-05-合法二叉搜索树" class="headerlink" title="面试题 04.05. 合法二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/die-dai-yu-di-gui-by-powcai/" target="_blank" rel="noopener">面试题 04.05. 合法二叉搜索树</a></h1><h2 id="方法1：利用携带的最大最小值进行判断"><a href="#方法1：利用携带的最大最小值进行判断" class="headerlink" title="方法1：利用携带的最大最小值进行判断"></a>方法1：利用携带的最大最小值进行判断</h2><ul><li><p>root 需要做的不只是和左右子节点比较，而是要和整个左子树和右子树<strong>所有节点</strong>比较</p></li><li><p>使用辅助函数，增加函数参数列表，在<strong>参数中携带额外信息</strong>（当前节点需要比较的最小值和最大值）</p><ul><li>直接赋予最小值<code>-float(&quot;inf&quot;)</code>、最大值<code>float(&quot;inf&quot;)</code>，在递归的过程中修改最值（<strong>自顶向下</strong>的过程中，<strong>右子树的最小值从<code>-float(&quot;inf&quot;)</code> 逐渐增大，左子树的最大值从<code>float(&quot;inf&quot;)</code> 逐渐减小</strong>）</li></ul></li></ul><blockquote><p>以该不合法的二叉搜索树树为例：</p><ul><li>遍历到15 时，15与 <code>[10, float(&quot;inf&quot;)]</code> 比较，结果是True（此时最小值为10）</li><li>对于15的左子树，它应该在[10,15] 范围内，但现在是6，结果为False <img src="https://img-blog.csdnimg.cn/20200802113813779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt></li></ul></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: bool        """</span>        <span class="token keyword">def</span> <span class="token function">valid</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>mi<span class="token punctuation">,</span>ma<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">&lt;=</span>mi<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">>=</span>ma<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">return</span> valid<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> mi <span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">and</span> valid<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> ma<span class="token punctuation">)</span>        <span class="token keyword">return</span> valid<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token operator">-</span>float<span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> float<span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法2：中序遍历二叉搜索树后，判断其是否为没有重复元素的递增数组"><a href="#方法2：中序遍历二叉搜索树后，判断其是否为没有重复元素的递增数组" class="headerlink" title="方法2：中序遍历二叉搜索树后，判断其是否为没有重复元素的递增数组"></a>方法2：中序遍历二叉搜索树后，判断其是否为没有重复元素的递增数组</h2><ul><li>最后的<code>return nodes == sorted(set(nodes))</code>, 要<strong>先set，再 sorted</strong>，这样返回的是列表形式，即判断列表是否等于列表（<del>若先sorted，再set，返回的是一个集合，即判断列表是否等于集合，出现错误）</del> 。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: bool        """</span>        nodes<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 中序遍历后，判断其是否递增</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>            inOrder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            inOrder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">return</span> nodes        inOrder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> nodes <span class="token operator">==</span> sorted<span class="token punctuation">(</span>set<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700. 二叉搜索树中的搜索</a></h1><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :type val: int        :rtype: TreeNode        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> None        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>val<span class="token punctuation">:</span> <span class="token keyword">return</span> root        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">></span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> seatchBST<span class="token punctuation">(</span>self<span class="token punctuation">,</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>val<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> searchBST<span class="token punctuation">(</span>self<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="701-二叉搜索树的插入操作"><a href="#701-二叉搜索树的插入操作" class="headerlink" title="701.二叉搜索树的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/submissions/" target="_blank" rel="noopener">701.二叉搜索树的插入操作</a></h1><p>对数据结构的操作无非遍历 + 访问，遍历就是“找”，访问就是“改”。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。</p><p>上一个问题，我们总结了 BST 中的遍历框架，就是“找”的问题。直接套框架，加上“改”的操作即可。一旦涉及“<strong>改</strong>”，函数就要<strong>返回 TreeNode 类型</strong>，并且<strong>对递归调用的返回值进行接收。</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :type val: int        :rtype: TreeNode        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>val<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">if</span> val<span class="token operator">></span>root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>insertIntoBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>val<span class="token punctuation">)</span>        <span class="token keyword">elif</span> val<span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>insertIntoBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>val<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></h1><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :type key: int        :rtype: TreeNode        """</span>        <span class="token comment" spellcheck="true"># 若无根节点，直接返回</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span><span class="token keyword">return</span> None        <span class="token comment" spellcheck="true"># 若找到目标值</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>key<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 处理无子节点/只有一个子节点的情况</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token operator">==</span>None<span class="token punctuation">:</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>right            <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token operator">==</span>None<span class="token punctuation">:</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>left            <span class="token comment" spellcheck="true"># 找到右子树的最左（小）节点，并替换</span>            minNode<span class="token operator">=</span>self<span class="token punctuation">.</span>getMin<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            root<span class="token punctuation">.</span>val<span class="token operator">=</span>minNode<span class="token punctuation">.</span>val            <span class="token comment" spellcheck="true"># 转而删除最小节点</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>minNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 二叉搜索树</span>        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val<span class="token operator">></span>key<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>key<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> root    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 最小值一定在左叶子节点处</span>        <span class="token keyword">while</span> root<span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>            root<span class="token operator">=</span>root<span class="token punctuation">.</span>left        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/liang-chong-die-dai-by-powcai/" target="_blank" rel="noopener"><strong>前序、中序、后序、层序遍历 打包，讲解很棒！</strong></a></p><p>只需要<strong>改变遍历的顺序</strong>即可</p><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/di-gui-he-die-dai-by-powcai-5/" target="_blank" rel="noopener">前序遍历</a></h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[int]        """</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span><span class="token keyword">return</span>             res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/dong-hua-yan-shi-94-er-cha-shu-de-zhong-xu-bian-li/" target="_blank" rel="noopener">中序遍历</a></h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[int]        """</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span>             helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/liang-chong-die-dai-by-powcai/" target="_blank" rel="noopener">后序遍历</a></h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>                <span class="token keyword">return</span>             helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><h3 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/solution/mian-shi-ti-32-i-cong-shang-dao-xia-da-yin-er-ch-4/" target="_blank" rel="noopener">剑指 Offer 32 - I. 从上到下打印二叉树</a></h3><ul><li><strong>队列</strong>中存储当前层的节点，然后利用<strong>先进先出</strong>特性得到结果 。构建队列： <code>queue = collections.deque()</code><ul><li>同一层的节点，左儿子先进入，右儿子后进入 （如 queue的 2，3）</li><li>对于子节点，左儿子弹出后，将左儿子的左右孙子连接到右儿子后面（如 queue的3，4，5）。右儿子弹出后，将右儿子的左右孙子继续连接到左儿子的左右孙子后面（如 queue的 4,5,6,7）</li></ul></li></ul><blockquote><p>以如下二叉树为例，说明队列的先进先出，并得到层序遍历的打印结果[1,2,3,4,5,6,7]<br><img src="https://img-blog.csdnimg.cn/2020080220292811.png" alt>          </p><table><thead><tr><th>res（存储节点的值）</th><th>queue （存储节点，因为要判断是否有左右子节点）</th></tr></thead><tbody><tr><td>[]</td><td>1</td></tr><tr><td>[1]</td><td>2,3</td></tr><tr><td>[1,2]</td><td>3,4,5</td></tr><tr><td>[1,2,3]</td><td>4,5,6,7</td></tr><tr><td>[1,2,3,4]</td><td>5,6,7</td></tr><tr><td>[1,2,3,4,5]</td><td>6,7</td></tr><tr><td>[1,2,3,4,5,6]</td><td>7</td></tr><tr><td>[1,2,3,4,5,6,7]</td><td>空</td></tr></tbody></table></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[int]        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        queue<span class="token operator">=</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></h3><p>上一题把所有遍历的结果保存在数组中，即<code>[1,2,3,4,5,6,7]</code>。该题与上题的不同之处在于，这一次把每一层的元素保存在结果中，即 <code>[[1],[2,3],[4,5,6,7]]</code>.</p><p>所以只需要在<code>range(len(queue))</code> 范围内，增加临时变量temp保存当前层的结果。</p><blockquote><p>注意！即便<br><code>if node.left: queue.append(node.left)</code><br><code>if node.right: queue.append(node.right)</code> 会改变queue的长度，<code>for i in range(len(queue))</code>在超出当时赋值<code>range(len(queue))</code>范围后才跳出for循环（即，i的变化范围是0|0,1|0,1,2,3|,而不会随着循环语句中queue的改变而改变for循环次数)</p><p>如：</p><pre class="line-numbers language-python"><code class="language-python">nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>结果为： 0 1 2 。不随着nums的变化而改变for循环的次数</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[List[int]]        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        queue <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                         node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：LRU算法详解</title>
      <link href="/2020/08/01/labuladong/di-er-zhang-lru-suan-fa-xiang-jie/"/>
      <url>/2020/08/01/labuladong/di-er-zhang-lru-suan-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/lru-suan-fa" target="_blank" rel="noopener">LRU算法详解</a></p><p><a href="https://leetcode-cn.com/problems/lru-cache/solution/pythonde-ordereddict-huo-zhe-ha-xi-shuang-xiang-li/" target="_blank" rel="noopener">146. LRU(Least Recently Used) 缓存机制</a></p><p>利用<strong>字典+双向链表</strong></p><ul><li>字典里存的是<strong>Node的节点类</strong>，self.add(Node(key, value))</li><li>传给add函数的是一个Node类，这个字典的<strong>键是node.key</strong>，<strong>值是Node类</strong></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 构建Node类</span><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val        self<span class="token punctuation">.</span>prev <span class="token operator">=</span> None        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 构建首尾节点, 使之相连</span>        <span class="token comment" spellcheck="true"># 之后处理head到tail之间的node</span>        self<span class="token punctuation">.</span>head <span class="token operator">=</span> Node<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>tail <span class="token operator">=</span> Node<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> self<span class="token punctuation">.</span>head        self<span class="token punctuation">.</span>lookup <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>max_len <span class="token operator">=</span> capacity    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>lookup<span class="token punctuation">:</span>            node <span class="token operator">=</span> self<span class="token punctuation">.</span>lookup<span class="token punctuation">[</span>key<span class="token punctuation">]</span>            self<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>add<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            <span class="token keyword">return</span> node<span class="token punctuation">.</span>val        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>lookup<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>self<span class="token punctuation">.</span>lookup<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 移除该节点</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>lookup<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>max_len<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 把表头位置节点删除(说明最近的数据值)</span>            self<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Node<span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 删除链表节点</span>    <span class="token keyword">def</span> <span class="token function">remove</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">del</span> self<span class="token punctuation">.</span>lookup<span class="token punctuation">[</span>node<span class="token punctuation">.</span>key<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 删除该节点</span>        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next <span class="token comment" spellcheck="true"># 更新链表</span>        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">.</span>prev    <span class="token comment" spellcheck="true"># 加在链表尾</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>lookup<span class="token punctuation">[</span>node<span class="token punctuation">.</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> node <span class="token comment" spellcheck="true"># 添加(key ,node)节点</span>        pre_tail <span class="token operator">=</span> self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev <span class="token comment" spellcheck="true">#暂存该节点</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>tail <span class="token comment" spellcheck="true">#更新链表</span>        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> node        pre_tail<span class="token punctuation">.</span>next <span class="token operator">=</span> node        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pre_tail<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：贪心算法之区间调度问题</title>
      <link href="/2020/07/31/labuladong/di-yi-zhang-tan-xin-suan-fa-zhi-qu-jian-diao-du-wen-ti/"/>
      <url>/2020/07/31/labuladong/di-yi-zhang-tan-xin-suan-fa-zhi-qu-jian-diao-du-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/tan-xin-suan-fa-zhi-qu-jian-tiao-du-wen-ti" target="_blank" rel="noopener">贪心算法之区间调度问题</a></p><h1 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. 无重叠区间</a></h1><blockquote><p>一天有好多活动，你可以选择不重叠的时间尽量多参加活动。</p><ul><li>按照活动结束的时间排序后（不管开始得多早，都不如选择早点结束的活动，这样还能继续选其他活动）<ul><li>假设当前参加的是活动A，如果活动B的开始时间大于等于活动A的结束时间，则继续参加B活动。</li><li>这时活动数+1，后面的活动开始时间要和活动B结束的时间进行比较，所以活动结束的时间更新为活动B结束的时间。</li></ul></li></ul></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">eraseOverlapIntervals</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> intervals<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> intervals<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        intervals<span class="token operator">=</span>sorted<span class="token punctuation">(</span>intervals<span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x <span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        end<span class="token operator">=</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 第0个活动结束的时间</span>        count<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 可以想象成当前活动开始的时间大于等于之前活动结束的时间，那么参加当前活动</span>            <span class="token keyword">if</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">>=</span>end<span class="token punctuation">:</span>                count<span class="token operator">+=</span><span class="token number">1</span>                end<span class="token operator">=</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">-</span>count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：动态规划之子序列问题解题模板</title>
      <link href="/2020/07/31/labuladong/di-yi-zhang-dong-tai-gui-hua-zhi-zi-xu-lie-wen-ti-jie-ti-mo-ban/"/>
      <url>/2020/07/31/labuladong/di-yi-zhang-dong-tai-gui-hua-zhi-zi-xu-lie-wen-ti-jie-ti-mo-ban/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md" target="_blank" rel="noopener">动态规划之子序列问题解题模板</a></p><h1 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a></h1><ol><li>dp数组的含义：s[i…j] 中最长回文子序列的长度保存在dp[i][j] 中</li><li>状态转移方程：如果i处和j处的字符相同，则从短串s[i+1…j-1]中扩充2（<code>dp[i][j]=dp[i+1][j-1]+2</code>）。 否则继承 s[i+1…j] ， s[i…j-1] 的最长回文子序列长度的最大值 （<code>max(dp[i+1][j],dp[i][j-1])</code>）</li><li>base case: dp 数组先初始化为 0 （而且对角线下半部分的三角形表示i &gt; j, 不可能出现这种情况，因此为0）。i 和 j 指向同一个字符时，回文子序列为其本身， 因此对角线处的dp数组元素初始化为1</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestPalindromeSubseq</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">2</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：经典动态规划：最长公共子序列</title>
      <link href="/2020/07/31/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-zui-chang-gong-gong-zi-xu-lie/"/>
      <url>/2020/07/31/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-zui-chang-gong-gong-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-chang-gong-gong-zi-xu-lie" target="_blank" rel="noopener">经典动态规划：最长公共子序列</a></p><p><em>（在dp数组中添加0行和0列可以包含text为空的情况，并且更便于状态转移）</em></p><ol><li>dp数组的含义： 对于 text1[0..i-1] 和 text2[0..j-1]，dp[i][j]中保存当前位置的最长公共子序列的长度</li><li>状态转移方程：若当前元素相等，则在之前状态下+1 （<code>dp[i][j]=dp[i-1][j-1]+1</code>）。 若不相等，则继承之前的最大值（<code>dp[i][j]=max(dp[i-1][j],dp[i][j-1])</code>）</li><li>base case : 第0行和第0列初始化为0 。（至少有一个为空字符时，不可能有公共子序列 （两个都为空时，公共子序列长度也为0））</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text1<span class="token punctuation">,</span> text2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token punctuation">(</span>text1 <span class="token operator">and</span> text2<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        m<span class="token operator">=</span>len<span class="token punctuation">(</span>text1<span class="token punctuation">)</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>text2<span class="token punctuation">)</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> text1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span>text2<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：经典动态规划：编辑距离</title>
      <link href="/2020/07/30/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-bian-ji-ju-chi/"/>
      <url>/2020/07/30/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-bian-ji-ju-chi/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/bian-ji-ju-li" target="_blank" rel="noopener">经典动态规划：编辑距离</a></p><p><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></p><p><img src="https://img-blog.csdnimg.cn/2020073020134580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt></p><ul><li>在word1 和word2 前面分别插入<code>&quot;&quot;</code> 不仅可以包括字符串为空的情况，而且可以更清楚地用空字符串说明状态转移的过程</li><li>i 和 j 中，因为最前面加了<code>&quot;&quot;</code>, 因此第i个字符的下标为i-1 <ul><li>若两个字符相等（<code>word1[i-1]==word2[j-1]</code>），则i和j分别继续向右跳一格</li><li>若不相等，则增（dp[i][j-1]，如第0行），改（dp[i-1][j-1]），删（dp[i-1][j]，如第0列）的最小操作数 +1 </li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word1<span class="token punctuation">,</span> word2<span class="token punctuation">)</span><span class="token punctuation">:</span>        m<span class="token operator">=</span>len<span class="token punctuation">(</span>word1<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>word2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>j        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>i        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> word1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span>word2<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：动态规划设计：最大子数组</title>
      <link href="/2020/07/29/labuladong/di-yi-zhang-dong-tai-gui-hua-she-ji-zui-da-zi-shu-zu/"/>
      <url>/2020/07/29/labuladong/di-yi-zhang-dong-tai-gui-hua-she-ji-zui-da-zi-shu-zu/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-da-zi-shu-zu" target="_blank" rel="noopener">动态规划设计：最大子数组</a></p><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></p><hr><p>课堂上，学生排排坐。</p><p>老师：“这门课的作业，你们可以选择自己完成，也可以根据座位顺序，和你前面的同学组队（前面的同学可能和前前面的同学组了队，也可能就他一个人）。” </p><p>每个人都想把自己的作业完成得最好。</p><p> 在座位<code>i</code>处的大佬心想：“前面可能是大大佬（可以组队, <code>dp[i-1]+nums[i]</code>），也可能是小小菜（组队会拖我后腿，还不如我自己<code>nums[i]</code>）。”  不管哪种选择，最后，他的最好成绩取这两种选择的最大值即可。</p><hr><ul><li>dp数组含义： <strong>以nums[i]结尾</strong>的当前最大子序和保存在dp[i] 中</li><li>状态转移方程：<strong>nums[i] 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组</strong><ul><li><strong>对nums[i]而言</strong>（dp数组的含义决定了子序和是以nums[i]结尾的），若连接前面的子序列，则dp[i]=dp[i-1]+nums[i]。 若不连接，则自立门户 dp[i]=nums[i] 。根据这两种选择，直接取最大值即可 <code>dp[i]=max(nums[i],dp[i-1]+nums[i])</code>。</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：动态规划设计：最长递增子序列</title>
      <link href="/2020/07/29/labuladong/di-yi-zhang-dong-tai-gui-hua-she-ji-zui-chang-di-zeng-zi-xu-lie/"/>
      <url>/2020/07/29/labuladong/di-yi-zhang-dong-tai-gui-hua-she-ji-zui-chang-di-zeng-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.md" target="_blank" rel="noopener">动态规划设计：最长递增子序列</a></p><h1 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></h1><ul><li>dp数组的含义：以nums[i] 结尾的当前最长上升子序列的长度记录在dp[i]中</li><li>状态转移方程：nums[i] 与它之前的元素nums[j]进行比较，若大于nums[j], 则比较之前保存的dp[i] 和dp[j]+1 的大小，并更新dp[i] （始终保存最大值）</li><li>base case： 上升子序列至少为自己，因此dp数组初始化为1</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：动态规划和回溯算法到底谁是谁爹？</title>
      <link href="/2020/07/29/labuladong/di-yi-zhang-dong-tai-gui-hua-he-hui-su-suan-fa-dao-di-shui-shi-shui-die/"/>
      <url>/2020/07/29/labuladong/di-yi-zhang-dong-tai-gui-hua-he-hui-su-suan-fa-dao-di-shui-shi-shui-die/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/targetsum" target="_blank" rel="noopener">动态规划和回溯算法到底谁是谁爹？</a></p><h1 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/solution/dong-tai-gui-hua-by-powcai-22/" target="_blank" rel="noopener">494. 目标和</a></h1><h2 id="方法1：动态规划（dp二维数组）"><a href="#方法1：动态规划（dp二维数组）" class="headerlink" title="方法1：动态规划（dp二维数组）"></a>方法1：动态规划（dp二维数组）</h2><p>dp[i][j]表示 <strong>数组中前i个元素组成和为j的方案数</strong></p><ol><li>base case: </li></ol><ul><li>首先初始化数组第0行。如果第一个元素为0，则<code>dp[0][total]=2</code> <ul><li>（-0 和+0 都为0，所以先初始化为2） 比如 [0,1,2], 目标和为3，则有-0+1+2=3，+0+1+2=3</li></ul></li><li>否则和为±nums[0] 的位置的方案数置为1</li></ul><pre class="line-numbers language-python"><code class="language-python">        <span class="token keyword">if</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span>            <span class="token comment" spellcheck="true"># 相当于</span>            <span class="token comment" spellcheck="true"># dp[0][total-nums[0]]=2</span>            <span class="token comment" spellcheck="true"># dp[0][total+nums[0]]=2</span>            <span class="token comment" spellcheck="true"># 只是此时nums[0]=0，因此写成 dp[0][total]=2</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token operator">-</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（或者直接用下面的代码来包含nums[0]为0 和非0的情况）</p><pre class="line-numbers language-python"><code class="language-python">        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token operator">-</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">+</span><span class="token number">1</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">+</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li><p>状态转移方程<br>保证数组的列索引在0到total*2+1范围内</p><pre class="line-numbers language-python"><code class="language-python">             l<span class="token operator">=</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">0</span>             r<span class="token operator">=</span>j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>total<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span>             dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>dp[i][j]的含义 : 数组中前i个元素组成和为j的方案数。因为和最大为sum（nums），所以和的范围为 <code>-sum（nums）</code>到 <code>0</code>到 <code>sum（nums）</code>。 数组大小设为<code>[[0 for _ in range(sum(nums)*2+1)] for _ in range(len(nums))]</code></p></li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">:</span>        total<span class="token operator">=</span>sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> abs<span class="token punctuation">(</span>total<span class="token punctuation">)</span><span class="token operator">&lt;</span>abs<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">#若目标和大于数组和，凑不成，返回0</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>total<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#初始化数组第0行</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token operator">-</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>total<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># l和r要保证在合法的索引范围内</span>                l<span class="token operator">=</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">0</span>                r<span class="token operator">=</span>j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>total<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token operator">+</span>S<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法2：动态规划（0-1背包的变体）"><a href="#方法2：动态规划（0-1背包的变体）" class="headerlink" title="方法2：动态规划（0-1背包的变体）"></a>方法2：动态规划（0-1背包的变体）</h2><blockquote><ul><li><em>dp数组行和列都分别增加1，第0列表示背包容量为0，第0行表示（虚拟）物品重量为0（这样做，方便初始化dp数组以及后续dp状态转移）</em></li><li><em>由于加了虚拟的0行和0列， 物品i从 1 开始，而数组索引是从 0 开始的，所以第 i 个物品的重量应该是 nums[i-1]</em></li></ul></blockquote><p>以[1,1,2,3]为例，目标和为 target=3.</p><p> 一种可行的方式为 <code>+1+1-2+3=3</code> 。正数列表为P=[1,1,3] , 负数列表为N=[2] 。 则有<br>    <code>sum（P）- sum（N）=target                （1）</code><br>  另一方面，<br>  <code>sum（P）+sum（N）=sum（nums）   （2）</code><br>  公式（1）与（2）相加，得 <code>sum（P）= （sum（nums）+target）/2</code><br>  问题转化为    -&gt;     <strong>各个物品大小为 [1,1,2,3], 背包容量为（sum（nums）+target）/2，求把背包正好装满的方案数</strong></p><p>但是，这里有个<strong>与0-1背包的区别</strong>：</p><ul><li>对于0-1 背包，物品大小为正数，可以先对二维数组初始化第0行（除[0][0]位置外全为0）和<strong>第0列（全为1）</strong>。<strong>然后<code>i</code>和<code>j</code>都从1开始遍历</strong></li><li>对于该问题，列表中可能存在为 0 的元素，因此选不选这个0，都能将容量为0的背包装满。所以<strong>只有<code>dp[0][0]=1</code></strong> （因为是增加的虚拟0行和0列）, 剩下的第0列的其他位置的值用状态转移方程确定 <del>（而不能初始化为1）</del> 。<strong>即<code>i</code>从1开始遍历，<code>j</code>从0开始遍历</strong><ul><li>如 列表为 [0,0,0] , 目标值为 0，则最终的dp数组为<code>[[1], [2], [4], [8]]</code></li><li>如 列表为 [0,0,1]，目标值为 1，则最终的dp数组为<code>[[1, 0], [2, 0], [4, 0], [4, 4]]</code></li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">:</span>        total <span class="token operator">=</span> sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> abs<span class="token punctuation">(</span>total<span class="token punctuation">)</span> <span class="token operator">&lt;</span> abs<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token comment" spellcheck="true"># 目标和太大</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>total <span class="token operator">+</span> S<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">#(total + S)必须为偶数，即，能被2整除</span>        volume <span class="token operator">=</span> <span class="token punctuation">(</span>total <span class="token operator">+</span> S<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>volume <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span> volume <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> j<span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 背包太小，装不下</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 装和不装的总和</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：经典动态规划：完全背包问题</title>
      <link href="/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-wan-quan-bei-bao-wen-ti/"/>
      <url>/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-wan-quan-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/bei-bao-ling-qian" target="_blank" rel="noopener">经典动态规划：完全背包问题</a></p><hr><p>动态规划之背包汇总</p><p><a href="https://ismxue.github.io/2020/07/24/labuladong/di-ling-zhang-dong-tai-gui-hua-jie-ti-tao-lu-kuang-jia/">第零章：动态规划解题套路框架</a><br><a href="https://ismxue.github.io/2020/07/27/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-0-1-bei-bao-wen-ti/">第一章：经典动态规划：0-1 背包问题</a><br><a href="https://ismxue.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-zi-ji-bei-bao-wen-ti/">第零章：经典动态规划：子集背包问题</a><br><a href="https://ismxue.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-wan-quan-bei-bao-wen-ti/">第零章：经典动态规划：完全背包问题</a></p><hr><table><thead><tr><th>0-1背包</th><th>完全背包</th></tr></thead><tbody><tr><td>当前的物品放还是不放</td><td>当前的物品放还是不放，如果放，放几个（<strong>每种物品有无数个，可以无限次选取</strong>）</td></tr></tbody></table><p>dp[i][j]数组的含义：dp[i][j] 表示对前i个物品，背包容量为j时，可以凑的硬币组合数（dp数组可以加一行一列表示0物品或0容量时的状态，更便于进行状态转移）</p><ul><li>0-1 背包时，对第i行的硬币<code>coins[i-1]</code> ,若选择该硬币，则dp[i][j]=dp[i-1][j-coins[i-1]] (因为每种硬币只有一枚，<strong>所以状态是从上一枚硬币转到当前硬币</strong>)</li><li>完全背包时，对第i行的硬币<code>coins[i-1]</code> ,若选择该硬币，则dp[i][j]=dp[i][j-coins[i-1]] （因为硬币有无数枚，<strong>选完当前硬币可以再选当前硬币</strong>）。<ul><li>选的时候为<code>dp[i][j-coins[i-1]]</code>，选<code>coins[i-1]</code>时，总的金额减少到<code>j-coins[i-1]</code>,但由于是完全背包问题，每个物品可以选无限次，所以，剩下的可以选的<em>*</em>还是应该是<code>coins[0...i-1]</code>前<code>i</code>个</li></ul></li></ul><h1 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/solution/bei-bao-si-xiang-jie-jue-ling-qian-dui-huan-wen-ti/" target="_blank" rel="noopener">518. 零钱兑换 II</a></h1><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">change</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> amount<span class="token punctuation">,</span> coins<span class="token punctuation">)</span><span class="token punctuation">:</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>coins<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 行和列都分别增加1，第0列表示背包容量为0，第一行表示（虚拟）物品重量为0</span>        <span class="token comment" spellcheck="true"># 这样做，方便初始化dp数组以及后续dp状态转移</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>coins<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 如果该物品重量超过容量，肯定不能放</span>                <span class="token keyword">if</span> j<span class="token operator">&lt;</span>coins<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token comment" spellcheck="true"># 如果没有超过重量，则有两种情况</span>                <span class="token comment" spellcheck="true"># 1. （不放当前的商品）之前的物品已经凑齐:dp[i-1][j]</span>                <span class="token comment" spellcheck="true"># 2. (放当前的商品) 比如用[1,2]凑5，已经知道了[1,2]凑（5-2）的方法，</span>                <span class="token comment" spellcheck="true">#     则把现在的2放进去就可以：dp[i][j-coins[i-1]]. (2可以多次使用)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：经典动态规划：子集背包问题</title>
      <link href="/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-zi-ji-bei-bao-wen-ti/"/>
      <url>/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-zi-ji-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/bei-bao-zi-ji" target="_blank" rel="noopener">经典动态规划：子集背包问题</a></p><hr><p>动态规划之背包汇总</p><p><a href="https://ismxue.github.io/2020/07/24/labuladong/di-ling-zhang-dong-tai-gui-hua-jie-ti-tao-lu-kuang-jia/">第零章：动态规划解题套路框架</a><br><a href="https://ismxue.github.io/2020/07/27/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-0-1-bei-bao-wen-ti/">第一章：经典动态规划：0-1 背包问题</a><br><a href="https://ismxue.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-zi-ji-bei-bao-wen-ti/">第零章：经典动态规划：子集背包问题</a><br><a href="https://ismxue.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-wan-quan-bei-bao-wen-ti/">第零章：经典动态规划：完全背包问题</a></p><hr><p>该背包问题相当于<strong>0-1背包问题</strong>的变体  </p><h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/dong-tai-gui-hua-kong-jian-you-hua-zhu-xing-jie--2/" target="_blank" rel="noopener">416. 分割等和子集</a></h1><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><table><thead><tr><th>0-1背包问题：背包容量为m，物品有大小和价值两种属性，求背包最大能装多少价值的物品？</th><th>0-1背包问题变体（分割等和子集）：<strong>背包容量为total/2, 每个物品的大小为 nums[i] 。对于前i个物品，是否有一种装法，能恰好装满背包？</strong></th></tr></thead><tbody><tr><td>dp[i][j] 表示对前i个物品，背包容量为j时，可以装的最大价值</td><td>dp[i][j] 表示对前i个物品，背包容量为j时，值为True/ False (能否装满)</td></tr></tbody></table><ul><li>dp数组行和列都分别增加1，第0列表示背包容量为0，第0行表示（虚拟）物品重量为0（这样做，方便初始化dp数组以及后续dp状态转移）</li><li>由于加了虚拟的0行和0列， 物品i从 1 开始，而数组索引是从 0 开始的，所以第 i 个物品的重量应该是 nums[i-1]</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        total<span class="token operator">=</span>sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># total为列表之和</span>        <span class="token keyword">if</span> total<span class="token operator">%</span><span class="token number">2</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token boolean">False</span> <span class="token comment" spellcheck="true"># 若无法被2整除，说明无法等和，直接返回False</span>        <span class="token comment" spellcheck="true"># 行和列都分别增加1，第0列表示背包容量为0，第0行表示（虚拟）物品重量为0</span>        <span class="token comment" spellcheck="true"># 这样做，方便初始化dp数组以及后续dp状态转移</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>total<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 和为0时，第一列为True</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>total<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> j<span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 若背包容量超过物品大小，装不下</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 继承之前的结果</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 继承之前装下/装不下的结果（只要之前有True，dp[i][j]就为True）</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">|</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：经典动态规划：0-1 背包问题</title>
      <link href="/2020/07/27/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-0-1-bei-bao-wen-ti/"/>
      <url>/2020/07/27/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-0-1-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485064&idx=1&sn=550705eb67f5e71487c8b218382919d6&chksm=9bd7f880aca071962a5a17d0f85d979d6f0c5a5ce32c84b8fee88e36d451f9ccb3bb47b88f78&scene=21#wechat_redirect" target="_blank" rel="noopener">经典动态规划：0-1 背包问题</a></p><hr><p>动态规划之背包汇总</p><p><a href="https://ismxue.github.io/2020/07/24/labuladong/di-ling-zhang-dong-tai-gui-hua-jie-ti-tao-lu-kuang-jia/">第零章：动态规划解题套路框架</a><br><a href="https://ismxue.github.io/2020/07/27/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-0-1-bei-bao-wen-ti/">第一章：经典动态规划：0-1 背包问题</a><br><a href="https://ismxue.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-zi-ji-bei-bao-wen-ti/">第零章：经典动态规划：子集背包问题</a><br><a href="https://ismxue.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-wan-quan-bei-bao-wen-ti/">第零章：经典动态规划：完全背包问题</a></p><hr><p><a href="https://www.lintcode.com/problem/backpack-ii/description" target="_blank" rel="noopener">题目地址</a></p><blockquote><p>有 n 个物品和一个大小为 m 的背包. 给定数组 A 表示每个物品的大小和数组 V 表示每个物品的价值.</p><p>问最多能装入背包的总价值是多大?</p><p>样例 样例 1:</p><p>输入: m = 10, A = [2, 3, 5, 7], V = [1, 5, 2, 4] 输出: 9 解释: 装入 A[1] 和<br>A[3] 可以得到最大价值, V[1] + V[3] = 9  样例 2:</p><p>输入: m = 10, A = [2, 3, 8], V = [2, 5, 8] 输出: 10 解释: 装入 A[0] 和 A[2]<br>可以得到最大价值, V[0] + V[2] = 10</p></blockquote><ol><li>base case：0 物品和 0 背包容量时，价值为0</li><li>明确状态和选择<ul><li>状态：背包的容量 ，放进去的物品</li><li>选择：放/不放 当前物品到背包中</li></ul></li><li>dp数组的含义：因为状态有两个，所以dp用二维数组表示。<code>dp[i][j]</code>    表示对前<code>i</code>个物品，背包容量为<code>j</code>时，可以装的最大价值（dp数组可以加一行一列表示0物品或0容量时的状态，更<strong>便于进行状态转移</strong>）<ul><li>若书包容量太小，容不下（<code>if j&lt;A[i-1]</code>），则<code>dp[i][j]=dp[i-1][j]</code></li><li>否则，可以放进去<ul><li>若不放进去，则dp[i][j]=dp[i-1][j]</li><li>若放进去，则dp[i][j]=dp[i-1][j-w[i]] +V[i]</li></ul></li></ul></li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">backPackII</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">,</span> A<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># write your code here</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                <span class="token keyword">if</span> j<span class="token operator">&lt;</span>A<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 若书包容量为j时，放不进去第i个物品（从0开始，所以A[i-1]表示第i个物品的大小）</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 否则，可以放进去</span>                    notBring<span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 选择不放</span>                    bring<span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>A<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>V<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 选择放</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>notBring<span class="token punctuation">,</span>bring<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 取最大值即可</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：团灭 LeetCode 打家劫舍问题</title>
      <link href="/2020/07/26/labuladong/di-ling-zhang-tuan-mie-leetcode-da-jia-jie-she-wen-ti/"/>
      <url>/2020/07/26/labuladong/di-ling-zhang-tuan-mie-leetcode-da-jia-jie-she-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%8A%A2%E6%88%BF%E5%AD%90.md" target="_blank" rel="noopener">团灭 LeetCode 打家劫舍问题</a></p><p><a href="https://leetcode-cn.com/problems/house-robber/solution/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap/" target="_blank" rel="noopener">图解动态规划的解题四步骤</a></p><p>动态规划：在确定动态转移方程后，可以用<del>（自顶向下的使用备忘录递归的方法）</del> <strong>自底向上使用 dp 数组</strong>的方法</p><h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h1><p>因为状态转移方程中，dp[i]涉及到dp[i-2], 在base case 中，在最前面加一个虚拟的空房子，状态更容易转换。而dp[1] 就初始化为nums[0]。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true"># 子问题：</span>    <span class="token comment" spellcheck="true"># f(k) = 偷 [0..k) 房间中的最大金额</span>    <span class="token comment" spellcheck="true"># f(0) = 0</span>    <span class="token comment" spellcheck="true"># f(1) = nums[0]</span>    <span class="token comment" spellcheck="true"># f(k) = max{ rob(k-1), nums[k-1] + rob(k-2) }</span>    N <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k<span class="token number">-2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h1><ul><li><p>现在房子环成了一个圈，也就是说第一间和最后一间不能同时抢。那么有：</p><ol><li><p>抢第一间，不抢最后一间</p></li><li><p>不抢第一间， 抢最后一间</p></li><li><p>不抢第一间， 不抢最后一间</p><p>实际上，情况3的结果是小于情况2的(或者可以说是包含关系), 所以我们只需要考虑情况1,2。</p></li></ol></li><li><p>因此，当有多于1个房子时，只需要比较<code>nums[:-1] , nums[1:]</code> 并返回最大值<code>max(my_rob(nums[:-1]),my_rob(nums[1:]))</code>即可</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">my_rob</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token triple-quoted-string string">"""            :type nums: List[int]            :rtype: int            """</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>            dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>my_rob<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>my_rob<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token keyword">else</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="337-树形打家劫舍"><a href="#337-树形打家劫舍" class="headerlink" title="337 树形打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/solution/shu-xing-dp-by-enda-2/" target="_blank" rel="noopener">337 树形打家劫舍</a></h1><ul><li>对于每一个节点，都只有选和不选两种情况。数组中<code>[ ,  ]</code>第一个index表示不打劫当前节点的收益，第二个index表示打劫当前节点的收益</li><li>如果没选当前节点，则可以选左右节点（<code>withoutRoot=max(l)+max(r)</code>）。如果选了当前节点，则不能选左右节点（<code>withRoot=root.val+l[0]+r[0]</code>）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dp</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 不偷/偷的收益</span>            l<span class="token operator">=</span>dp<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 左节点不偷/偷带来的收益</span>            r<span class="token operator">=</span>dp<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 右节点不偷/偷带来的收益</span>            <span class="token comment" spellcheck="true"># 若偷当前节点，则收益=当前节点+左节点不偷+右节点不偷</span>            <span class="token comment" spellcheck="true"># 若不偷当前节点，则收益=左节点偷或不偷的最大值+右节点偷或不偷的最大值</span>            withRoot<span class="token operator">=</span>root<span class="token punctuation">.</span>val<span class="token operator">+</span>l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 若偷当前节点</span>            withoutRoot<span class="token operator">=</span>max<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token operator">+</span>max<span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 若不偷当前节点</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span>withoutRoot<span class="token punctuation">,</span>withRoot<span class="token punctuation">]</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 返回 不偷/偷当前节点 的收益最大值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：我写了首诗，把滑动窗口算法变成了默写题</title>
      <link href="/2020/07/25/labuladong/di-ling-zhang-wo-xie-liao-shou-shi-ba-hua-dong-chuang-kou-suan-fa-bian-cheng-liao-mo-xie-ti/"/>
      <url>/2020/07/25/labuladong/di-ling-zhang-wo-xie-liao-shou-shi-ba-hua-dong-chuang-kou-suan-fa-bian-cheng-liao-mo-xie-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://mp.weixin.qq.com/s/ioKXTMZufDECBUwRRp3zaA" target="_blank" rel="noopener">我写了首诗，把滑动窗口算法变成了默写题</a></p><ol><li>增大窗口 </li><li>找到可行解后缩小窗口</li><li><strong>注意维护valid及window中的内容</strong>（若包含需要找的元素，才更新window）</li></ol><blockquote><p> <strong>滑动窗口算法的思路</strong>是这样：</p><p>1、我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引<strong>左闭右开区间</strong>[left, right)称为一个「窗口」。</p><p>2、我们先不断地增加right指针扩大窗口[left, right)，直到窗口中的字符串符合要求（包含了T中的所有字符）。</p><p>3、此时，我们停止增加right，转而不断增加left指针缩小窗口[left, right)，直到窗口中的字符串不再符合要求（不包含T中的所有字符了）。同时，每次增加left，我们都要更新一轮结果。</p><p>4、重复第 2 和第 3 步，直到right到达字符串S的尽头。</p><p>这个思路其实也不难，第 2 步相当于<strong>在寻找一个「可行解」</strong>，然后第 3 步再<strong>优化这个「可行解」</strong>，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p></blockquote><h1 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-suan-fa-tong-yong-si-xiang-by-/" target="_blank" rel="noopener">76.最小覆盖子串</a></h1><ol><li>遍历t，得到need字典</li><li>窗口<strong>左闭右开</strong>。先增大右窗口，更新window 和valid</li><li>找全以后，开始缩小左窗口，相应地，也要更新window和valid。</li><li>在<strong>更新左窗口前</strong>，<strong>先用<code>ans</code>记录并更新左右指针位置</strong>，然后再更新window和valid。这样的话，当窗口的字符串因左窗口的缩小而不再符合要求时（退出while循环），ans中保存的是仍然正好符合要求的左右指针</li><li>如果左指针从未更新过（仍为-1），说明没有在s中找到符合要求的字符串，返回””,否则返回左右指针对应的字符串</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict        window<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        need<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> t<span class="token punctuation">:</span>            need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        l<span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        ans<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">]</span>        valid<span class="token operator">=</span><span class="token number">0</span> <span class="token comment" spellcheck="true"># 合法元素的个数</span>        <span class="token keyword">while</span> r<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            c<span class="token operator">=</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span>            <span class="token comment" spellcheck="true"># 增大窗口 ：相应的要改变window和valid</span>            r<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> need<span class="token punctuation">:</span>                window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span>need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>                    valid<span class="token operator">+=</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># 找到可行解后要缩小窗口：相应的要改变window和valid</span>            <span class="token keyword">while</span> valid<span class="token operator">==</span>len<span class="token punctuation">(</span>need<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> r<span class="token operator">-</span>l<span class="token operator">&lt;</span>ans<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    ans<span class="token operator">=</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span>                c<span class="token operator">=</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> c <span class="token keyword">in</span> need<span class="token punctuation">:</span>                    <span class="token keyword">if</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span>need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>                        valid<span class="token operator">-=</span><span class="token number">1</span>                    window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token string">""</span> <span class="token keyword">if</span> ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">else</span> s<span class="token punctuation">[</span>ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>ans<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a></h1><p>窗口大小等于s1长度，则判断窗口的内容是否符合条件。若符合，返回<code>True</code>。否则，继续更新左窗口。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">checkInclusion</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s1: str        :type s2: str        :rtype: bool        """</span>        <span class="token comment" spellcheck="true"># 准备初始值及统计信息</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict        need<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        window<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        valid<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s1<span class="token punctuation">:</span>            need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        l<span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        <span class="token comment" spellcheck="true"># 维护valid及window</span>        <span class="token keyword">while</span> r<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 维护及增大右窗口</span>            c<span class="token operator">=</span>s2<span class="token punctuation">[</span>r<span class="token punctuation">]</span>            r<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> need<span class="token punctuation">:</span>                window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span>need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>                    valid<span class="token operator">+=</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># 如果窗口大小等于s1长度，则判断窗口的内容是否符合条件</span>            <span class="token comment" spellcheck="true"># 注意是左闭右开，所以是r-l==len(s1)，而不是r-l+1==len(s1)</span>            <span class="token keyword">if</span> r<span class="token operator">-</span>l<span class="token operator">==</span>len<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 若符合，返回True</span>                <span class="token keyword">if</span> valid<span class="token operator">==</span>len<span class="token punctuation">(</span>need<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>                <span class="token comment" spellcheck="true"># 收缩并更新左窗口</span>                c<span class="token operator">=</span>s2<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> c <span class="token keyword">in</span> need<span class="token punctuation">:</span>                    <span class="token keyword">if</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span>need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>                        valid<span class="token operator">-=</span><span class="token number">1</span>                    window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h1><p>相当于在上题的基础上，返回所有满足条件的排列的初始索引值。 用res保存结果（用<code>res.append(l)</code> 添加左指针的索引）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 输入:</span><span class="token comment" spellcheck="true"># s: "cbaebabacd" p: "abc"</span><span class="token comment" spellcheck="true"># 输出:</span><span class="token comment" spellcheck="true"># [0, 6]</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findAnagrams</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :type p: str        :rtype: List[int]        """</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict        need<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        window<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        l<span class="token punctuation">,</span>r<span class="token punctuation">,</span>valid<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> p<span class="token punctuation">:</span>            need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">while</span> r<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            c<span class="token operator">=</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span>            r<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> need<span class="token punctuation">:</span>                window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span>need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>                    valid<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> r<span class="token operator">-</span>l<span class="token operator">==</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> valid<span class="token operator">==</span>len<span class="token punctuation">(</span>need<span class="token punctuation">)</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>l<span class="token punctuation">)</span>                c<span class="token operator">=</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> c <span class="token keyword">in</span> need<span class="token punctuation">:</span>                    <span class="token keyword">if</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span>need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>                        valid<span class="token operator">-=</span><span class="token number">1</span>                    window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h1><ul><li>这次连need和valid都不需要，直接更新window即可</li><li><code>while window[c]&gt;1</code>时，说明窗口中存在重复元素，不符合条件，就该移动left缩小窗口了</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 输入: "abcabcbb"</span><span class="token comment" spellcheck="true"># 输出: 3</span><span class="token comment" spellcheck="true"># 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict        window<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        l<span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        res_max<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> r <span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 更新右窗口</span>            c<span class="token operator">=</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span>            r<span class="token operator">+=</span><span class="token number">1</span>            window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># 符合左窗口更新的条件</span>            <span class="token comment" spellcheck="true"># 注意这里要用while，把不符合条件的左窗口内容一直跳过去</span>            <span class="token comment" spellcheck="true"># 如 "pwwkew"，把左侧p移除后，继续移除左侧w</span>            <span class="token keyword">while</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>                d<span class="token operator">=</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l<span class="token operator">+=</span><span class="token number">1</span>                window<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># 更新答案</span>            res_max<span class="token operator">=</span>max<span class="token punctuation">(</span>res_max<span class="token punctuation">,</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span>        <span class="token keyword">return</span> res_max<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>此题也可用动态规划解：</p><ul><li>dp数组含义：<strong>包含</strong>第i个元素的所有无重复字符串的长度（即<code>len(visited)</code>）</li><li><code>visited</code> 用于保存无重复字符串元素。<code>visited=[s[i]]</code>一定包含当前元素，然后从i-1 开始，逆序遍历之前的元素，若不在visited里，则添加到visited，否则break跳出。</li><li>最后返回dp数组的最大值</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: int        """</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            visited<span class="token operator">=</span><span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                    visited<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>len<span class="token punctuation">(</span>visited<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：我写了首诗，让你闭着眼睛也能写对二分搜索</title>
      <link href="/2020/07/25/labuladong/di-ling-zhang-wo-xie-liao-shou-shi-rang-ni-bi-zhao-yan-jing-ye-neng-xie-dui-er-fen-sou-suo/"/>
      <url>/2020/07/25/labuladong/di-ling-zhang-wo-xie-liao-shou-shi-rang-ni-bi-zhao-yan-jing-ye-neng-xie-dui-er-fen-sou-suo/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/er-fen-cha-zhao-xiang-jie" target="_blank" rel="noopener">我写了首诗，让你闭着眼睛也能写对二分搜索</a></p><ul><li>二分查找的一个技巧是：不要出现 else，而是<strong>把所有情况用 <code>elif</code> 列出来</strong>，这样可以清楚地展现所有细节</li><li><code>mid=left + (right - left) // 2</code> 可防止溢出</li><li>对于左右侧边界的二分查找，<code>elif nums[mid]==target</code> 时<strong>更新的边界</strong>不一样。<code>while</code>循环结束后要通过<strong>打补丁</strong>的方式返回结果<h1 id="基本二分查找"><a href="#基本二分查找" class="headerlink" title="基本二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">基本二分查找</a></h1></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>            mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                right<span class="token operator">=</span>mid<span class="token number">-1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> mid        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="寻找左右侧边界的二分查找"><a href="#寻找左右侧边界的二分查找" class="headerlink" title="寻找左右侧边界的二分查找"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">寻找左右侧边界的二分查找</a></h1><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">searchRange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">leftSearch</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>            left<span class="token operator">=</span><span class="token number">0</span>            right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>                mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>            <span class="token comment" spellcheck="true"># 注意此处的打补丁，因为是左边界，所以是 nums[left]!=target</span>            <span class="token keyword">if</span> left<span class="token operator">>=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">or</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">!=</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">return</span> left            <span class="token comment" spellcheck="true"># # 或者</span>            <span class="token comment" spellcheck="true"># if left&lt;=len(nums)-1 and nums[left]==target:</span>            <span class="token comment" spellcheck="true">#     return left</span>            <span class="token comment" spellcheck="true"># return -1</span>        <span class="token keyword">def</span> <span class="token function">rightSearch</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>            left<span class="token operator">=</span><span class="token number">0</span>            right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>                mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># 注意此处的打补丁，因为是右边界，所以是 nums[right]!=target</span>            <span class="token keyword">if</span> right<span class="token operator">&lt;</span><span class="token number">0</span>  <span class="token operator">or</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">!=</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">return</span> right            <span class="token comment" spellcheck="true"># 或者</span>            <span class="token comment" spellcheck="true"># if right>=0 and nums[right]==target:</span>            <span class="token comment" spellcheck="true">#     return right</span>            <span class="token comment" spellcheck="true"># return -1</span>        l<span class="token operator">=</span>leftSearch<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span>        r<span class="token operator">=</span>rightSearch<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>l<span class="token punctuation">,</span>r<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
            <tag> BinarySearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：BFS 算法解题套路框架（暂）</title>
      <link href="/2020/07/24/labuladong/di-ling-zhang-bfs-suan-fa-jie-ti-tao-lu-kuang-jia-zan/"/>
      <url>/2020/07/24/labuladong/di-ling-zhang-bfs-suan-fa-jie-ti-tao-lu-kuang-jia-zan/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/bfs-kuang-jia" target="_blank" rel="noopener">BFS 算法解题套路框架</a></p><h1 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/li-jie-zhe-dao-ti-de-jie-shu-tiao-jian-by-user7208/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></h1><p>这里先用递归解决</p><ul><li>递归结束的条件或者特判：若是空节点，则返回0</li><li>若左右孩子都为空：返回1</li><li>若左右孩子有一个为空：返回非空孩子的递归结果+1</li><li>否则都不为空，返回左右孩子递归结果的最小值+1</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 递归结束的条件:没有左右孩子</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        leftMin <span class="token operator">=</span> self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        rightMin <span class="token operator">=</span> self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> leftMin <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">and</span> rightMin <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">elif</span> leftMin <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> rightMin <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> leftMin <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> leftMin<span class="token operator">!=</span><span class="token number">0</span> <span class="token keyword">else</span> rightMin <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> min<span class="token punctuation">(</span>leftMin<span class="token punctuation">,</span> rightMin<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 递归结束的条件:没有左右孩子</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        leftMin <span class="token operator">=</span> self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        rightMin <span class="token operator">=</span> self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>left <span class="token operator">and</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">elif</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>left <span class="token operator">or</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>            <span class="token keyword">return</span> leftMin <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">else</span> rightMin <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> min<span class="token punctuation">(</span>leftMin<span class="token punctuation">,</span> rightMin<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：回溯算法解题套路框架</title>
      <link href="/2020/07/24/labuladong/di-ling-zhang-hui-su-suan-fa-jie-ti-tao-lu-kuang-jia/"/>
      <url>/2020/07/24/labuladong/di-ling-zhang-hui-su-suan-fa-jie-ti-tao-lu-kuang-jia/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban" target="_blank" rel="noopener">回溯算法解题套路框架</a></p><p>解决一个回溯问题，实际上就是一个<strong>决策树的遍历</strong>过程。主要考虑的问题有：</p><blockquote><ol><li>路径：也就是已经做出的选择。</li><li>选择列表：也就是你当前可以做的选择。</li><li>结束条件：也就是到达决策树底层，无法再做选择的条件。</li></ol></blockquote><p>回溯算法的框架：<br>（在想这个框架时，心里先建立一个N叉递归决策树，在每个决策点做选择）</p><pre class="line-numbers language-python"><code class="language-python">result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> 满足结束条件<span class="token punctuation">:</span>        result<span class="token punctuation">.</span>add<span class="token punctuation">(</span>路径<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">for</span> 选择 <span class="token keyword">in</span> 选择列表<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 做选择, 类似前序遍历</span>        将该选择从选择列表移除        路径<span class="token punctuation">.</span>add<span class="token punctuation">(</span>选择<span class="token punctuation">)</span>        backtrack<span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 撤销选择，类似后序遍历</span>        路径<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>选择<span class="token punctuation">)</span>        将该选择再加入选择列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>其核心就是 for 循环里面的递归，在递归<strong>调用之前「做选择」</strong>，在递归<strong>调用之后「撤销选择」</strong>。</li><li>for循环的一开始，往往先<strong>用<code>if ...continue</code>语句跳过不合法的选择</strong>（来更新选择列表）</li><li>可以<strong>把「路径」和「选择」列表</strong>作为决策树上<strong>每个节点的属性</strong>。<blockquote><p>以全排列为例，这张图（<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban#yi-quan-pai-lie-wen-ti" target="_blank" rel="noopener">图片来源</a>）非常清晰地说明了路径和选择列表的关系（加入路径后，选择也相应减少）。<br>backtrack 函数其实就<strong>像一个指针</strong>，在这棵树上游走，同时要<strong>正确维护每个节点的属性</strong>，每当走到树的底层，其「路径」就是一个全排列。<br><img src="https://img-blog.csdnimg.cn/20200724135038705.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt></p></blockquote><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></h1></li><li>res保存整体结果，visited保存已经走过的路径</li><li><strong>for 循环的一开始，利用 <code>if num in visited:  continue</code> 可巧妙地更新选择列表（通过continue跳出此次循环，避免选择到重复元素，达到剪枝的效果）</strong> （非常常用！！！）</li><li>利用<code>visited.append(num)</code> 和 <code>visited.pop()</code> 可更新路径（添加/回退选择）</li><li><code>res.append(visited[:])</code>   利用<strong>visited[:]</strong> 才可完整复制添加单个排列结果</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">permute</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[List[int]]        """</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>visited<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 选择列表和路径</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>visited<span class="token punctuation">)</span><span class="token operator">==</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>visited<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>                <span class="token keyword">if</span> num <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    visited<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>                    backtrack<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>visited<span class="token punctuation">)</span>                    visited<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        backtrack<span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></h1><ul><li>与全排列类似，<strong>决策树的每一层表示棋盘上的每一行</strong>；每个节点可以做出的<strong>选择是</strong>，在该行的<strong>任意一列</strong>放置一个皇后。</li><li><code>backtrack(board,row)</code> 就是标准的回溯框架，只是在做选择时， 通过<code>isvalid()</code> 函数进行剪枝（continue 跳出当次循环），得到符合条件的排列<ul><li><code>isvalid()</code> 函数检查当列，左上，右上 是否与皇后有冲突</li><li><code>tmp_res.append(&#39;&#39;.join(b))</code> 的作用是得到符合输出格式的皇后摆放</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        board<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'.'</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 路径：board, 选择列表：row中的每一列</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#     if 满足条件:</span>            <span class="token comment" spellcheck="true">#         res.append(路径)</span>            <span class="token comment" spellcheck="true">#         return</span>            <span class="token comment" spellcheck="true"># 触底，添加</span>            <span class="token keyword">if</span> row<span class="token operator">==</span>n<span class="token punctuation">:</span>                tmp_res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                <span class="token keyword">for</span> b <span class="token keyword">in</span> board<span class="token punctuation">:</span>                    tmp_res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp_res<span class="token punctuation">)</span>                <span class="token keyword">return</span> res            <span class="token comment" spellcheck="true">#     for 选择 in 选择列表:</span>            <span class="token comment" spellcheck="true">#         做选择</span>            <span class="token comment" spellcheck="true">#         backtrack(路径,选择列表)</span>            <span class="token comment" spellcheck="true">#         撤销选择</span>            <span class="token comment" spellcheck="true"># 判断row行，col列是否可以放Q</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token operator">not</span> isvalid<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'Q'</span>                backtrack<span class="token punctuation">(</span>board<span class="token punctuation">,</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'.'</span>        <span class="token keyword">def</span> <span class="token function">isvalid</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 检查列是否有皇后互相冲突</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'Q'</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token comment" spellcheck="true"># 检查左上方是否有皇后互相冲突</span>            l_row<span class="token punctuation">,</span>l_col<span class="token operator">=</span>row<span class="token punctuation">,</span>col            <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span>l_row<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>n <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span>l_col<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>n<span class="token punctuation">:</span>                l_row<span class="token operator">-=</span><span class="token number">1</span>                l_col<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>l_row<span class="token punctuation">]</span><span class="token punctuation">[</span>l_col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'Q'</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token comment" spellcheck="true"># 检查右上方是否有皇后互相冲突</span>            r_row<span class="token punctuation">,</span>r_col<span class="token operator">=</span>row<span class="token punctuation">,</span>col            <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span>r_row<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>n <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span>r_col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>n<span class="token punctuation">:</span>                r_row<span class="token operator">-=</span><span class="token number">1</span>                r_col<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>r_row<span class="token punctuation">]</span><span class="token punctuation">[</span>r_col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'Q'</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        backtrack<span class="token punctuation">(</span>board<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：动态规划解题套路框架</title>
      <link href="/2020/07/24/labuladong/di-ling-zhang-dong-tai-gui-hua-jie-ti-tao-lu-kuang-jia/"/>
      <url>/2020/07/24/labuladong/di-ling-zhang-dong-tai-gui-hua-jie-ti-tao-lu-kuang-jia/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie" target="_blank" rel="noopener">动态规划解题套路框架</a></p><hr><p>动态规划之背包汇总</p><p><a href="https://ismxue.github.io/2020/07/24/labuladong/di-ling-zhang-dong-tai-gui-hua-jie-ti-tao-lu-kuang-jia/">第零章：动态规划解题套路框架</a><br><a href="https://ismxue.github.io/2020/07/27/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-0-1-bei-bao-wen-ti/">第一章：经典动态规划：0-1 背包问题</a><br><a href="https://ismxue.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-zi-ji-bei-bao-wen-ti/">第零章：经典动态规划：子集背包问题</a><br><a href="https://ismxue.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-wan-quan-bei-bao-wen-ti/">第零章：经典动态规划：完全背包问题</a></p><hr><p>求解动态规划的核心问题是穷举,但是穷举过程中会存在<strong>重叠子问题</strong>，所以加上<strong>备忘录</strong>来优化过程<br>dp 三要素：</p><ol><li>明确 <strong>base case</strong></li><li>明确「状态」-&gt; 明确「选择」, 即<strong>状态转移方程</strong><ul><li>确定「<strong>状态</strong>」，也就是原问题和子问题中会变化的变量</li><li>确定「<strong>选择</strong>」，也就是导致「状态」产生变化的行为</li></ul></li><li>明确 <strong>dp 数组/函数的含义</strong></li></ol><p>因此，dp 框架可写成：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 初始化 base case</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token operator">=</span> base<span class="token comment" spellcheck="true"># 进行状态转移</span><span class="token keyword">for</span> 状态<span class="token number">1</span> <span class="token keyword">in</span> 状态<span class="token number">1</span>的所有取值：    <span class="token keyword">for</span> 状态<span class="token number">2</span> <span class="token keyword">in</span> 状态<span class="token number">2</span>的所有取值：        <span class="token keyword">for</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            dp<span class="token punctuation">[</span>状态<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>状态<span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token operator">=</span> 求最值<span class="token punctuation">(</span>选择<span class="token number">1</span>，选择<span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></h1><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type N: int        :rtype: int        """</span>        <span class="token keyword">if</span> N<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h1><ul><li>明确 base case：dp[0]=0。 初始化时dp[i] 设为<code>float(&quot;inf&quot;)</code> 最大值</li><li>明确状态：零钱大小</li><li>明确选择：硬币。 <code>if i&gt;=coin</code> 时才做选择（零钱大小至少要比硬币值大）</li><li>明确dp数组含义：凑好当前零钱数的最小硬币数量<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> coins<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">:</span>      dp<span class="token operator">=</span><span class="token punctuation">[</span>float<span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>      dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">for</span> coin <span class="token keyword">in</span> coins<span class="token punctuation">:</span>              <span class="token keyword">if</span> i<span class="token operator">>=</span>coin<span class="token punctuation">:</span>                  dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>coin<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">!=</span>float<span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：学习算法和刷题的框架思维</title>
      <link href="/2020/07/23/labuladong/di-ling-zhang-xue-xi-suan-fa-he-shua-ti-de-kuang-jia-si-wei/"/>
      <url>/2020/07/23/labuladong/di-ling-zhang-xue-xi-suan-fa-he-shua-ti-de-kuang-jia-si-wei/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa" target="_blank" rel="noopener">学习算法和刷题的框架思维</a></p><h1 id="124-二叉树中的最大路径和-后序遍历"><a href="#124-二叉树中的最大路径和-后序遍历" class="headerlink" title="124. 二叉树中的最大路径和_后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/er-cha-shu-zhong-de-zui-da-lu-jing-he-by-ikaruga/" target="_blank" rel="noopener">124. 二叉树中的最大路径和_后序遍历</a></h1><ul><li><code>maxVal</code> 记录的是全局最大路径和（可以不返回，因为它始终在递归过程中更新即可）。</li><li><code>dfs()</code>函数<strong>返回</strong>的是<strong>包含root</strong>在内的<strong>单边</strong>最大路径和。这样做的好处是<code>self.maxVal=max(self.maxVal,root.val+l+r)</code>可以包括全部的路径和情况（（1）根，（2）根+左，（3）根+右，（4）根+左+右），<code>l</code>或<code>r</code>可能为0）</li><li>若root的左节点对应的最大路径和是负数（在拖后腿，所以抛弃），则最大路径和为0，因此有<code>l=max(0,dfs(root.left))</code>。右节点同理</li><li>记得写<strong>递归结束</strong>的条件</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: int        """</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token number">0</span>            l<span class="token operator">=</span>max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>            r<span class="token operator">=</span>max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>maxVal<span class="token operator">=</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxVal<span class="token punctuation">,</span>root<span class="token punctuation">.</span>val<span class="token operator">+</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span>            <span class="token keyword">return</span> root<span class="token punctuation">.</span>val<span class="token operator">+</span>max<span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxVal<span class="token operator">=</span>float<span class="token punctuation">(</span><span class="token string">"-inf"</span><span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxVal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类似题目104-二叉树的最大深度-后序遍历"><a href="#类似题目104-二叉树的最大深度-后序遍历" class="headerlink" title="类似题目104. 二叉树的最大深度_后序遍历"></a>类似题目<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度_后序遍历</a></h2><ul><li><code>dfs()</code>函数返回包含<code>root</code>在内的二叉树最大深度</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: int        """</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>            l<span class="token operator">=</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            r<span class="token operator">=</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">return</span> max<span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="105-从前序与中序遍历序列构造二叉树-前序遍历"><a href="#105-从前序与中序遍历序列构造二叉树-前序遍历" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树_前序遍历"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/dong-hua-yan-shi-105-cong-qian-xu-yu-zhong-xu-bian/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树_前序遍历</a></h1><ul><li>前序遍历的第一个元素是根节点</li><li>在中序遍历中找到根节点的位置，其左边的元素就是左子树，右边的元素就是右子树</li><li>然后递归处理左右子树</li><li>注意写上递归结束条件（左右子树为空时）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type preorder: List[int]        :type inorder: List[int]        :rtype: TreeNode        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token punctuation">(</span>preorder <span class="token operator">and</span> inorder<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> None        root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 根节点</span>        midIdx<span class="token operator">=</span>inorder<span class="token punctuation">.</span>index<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 递归处理左右子树</span>        root<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>buildTree<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span>midIdx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>inorder<span class="token punctuation">[</span><span class="token punctuation">:</span>midIdx<span class="token punctuation">]</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>buildTree<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>midIdx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>inorder<span class="token punctuation">[</span>midIdx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="99-恢复二叉搜索树-中序遍历"><a href="#99-恢复二叉搜索树-中序遍历" class="headerlink" title="99. 恢复二叉搜索树_中序遍历"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/solution/san-chong-jie-fa-xiang-xi-tu-jie-99-hui-fu-er-cha-/" target="_blank" rel="noopener">99. 恢复二叉搜索树_中序遍历</a></h1><p>题目说二叉搜索树，中序遍历后应该是升序排列。否则若出现非递增的元素，说明这个地方有错误</p><ul><li>先中序遍历二叉搜索树，保存在nodes列表中（列表中的元素是节点）</li><li>x保存第一个错误节点，y保存第二个错误节点，pre保存遍历过程中的前一个节点</li><li>找到错误节点x、y后，交换x与y的值</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">recoverTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[int]        """</span>        nodes<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># nodes 中保存节点</span>        <span class="token comment" spellcheck="true"># 中序遍历二叉树,得到递增序列</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span>            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 如果出现非递增的元素，说明这个地方有错误</span>        x<span class="token operator">=</span>None        y<span class="token operator">=</span>None        pre<span class="token operator">=</span>nodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> pre<span class="token punctuation">.</span>val<span class="token operator">></span>nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token punctuation">:</span>                y<span class="token operator">=</span>nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token keyword">if</span> <span class="token operator">not</span> x<span class="token punctuation">:</span>                    x<span class="token operator">=</span>pre            pre<span class="token operator">=</span>nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 交换x与y的值</span>        <span class="token keyword">if</span> x <span class="token operator">and</span> y<span class="token punctuation">:</span>            x<span class="token punctuation">.</span>val<span class="token punctuation">,</span>y<span class="token punctuation">.</span>val<span class="token operator">=</span>y<span class="token punctuation">.</span>val<span class="token punctuation">,</span>x<span class="token punctuation">.</span>val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python经典排序算法</title>
      <link href="/2020/07/22/leetcode/python-jing-dian-pai-xu-suan-fa/"/>
      <url>/2020/07/22/leetcode/python-jing-dian-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-an-array/solution/python-shi-xian-de-shi-da-jing-dian-pai-xu-suan-fa/" target="_blank" rel="noopener">Python经典排序算法</a></p><p><img src="https://img-blog.csdnimg.cn/20200722182404772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><ul><li>对每一个nums[i], 寻找 $range(i,n)$ 范围内比nums[i]大的数，并与之交换</li><li>以此类推，位置 i 处就是 第i 小的数</li></ul><blockquote><p>两次for循环，时间复杂度为 $O(n^2)$</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">selection_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="==冒泡排序=="></a>==冒泡排序==</h1><ul><li>最坏的情况是: 原始的nums是倒序，从倒序转顺序</li><li>对每一个nums[i], 需要比较n-i次<strong>相邻元素</strong><blockquote><p>两次for循环，时间复杂度为 $O(n^2)$</p></blockquote></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="==插入排序=="></a>==插入排序==</h1><ul><li>对每一个nums[i], 将其插入到符合大小顺序的位置处</li><li>随着i的增加，需要比较的次数也增加。比较时，从最近的相邻元素开始，倒序比<blockquote><p>时间复杂度为 $O(n^2)$</p></blockquote></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>                i<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                    i<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="希尔排序（了解）"><a href="#希尔排序（了解）" class="headerlink" title="希尔排序（了解）"></a>希尔排序（了解）</h1><ul><li>希尔排序是插入排序的优化，通过<code>gap</code>减少排序过程中交换的次数<blockquote><p>时间复杂度为 $O(n^2)$</p></blockquote></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        gap<span class="token operator">=</span>n<span class="token operator">//</span><span class="token number">2</span>        <span class="token keyword">while</span> gap<span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>gap<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> i<span class="token operator">-</span>gap<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">:</span>                                nums<span class="token punctuation">[</span>i<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span>gap<span class="token punctuation">]</span>                    i<span class="token operator">-=</span>gap            gap<span class="token operator">=</span>gap<span class="token operator">//</span><span class="token number">2</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="==归并排序=="></a>==归并排序==</h1><p>归并排序是理解<strong>递归方法</strong>的一个很好的例子</p><ul><li><strong>不要跳进</strong>递归里面去 （<del>跳进去没任何用处，反而会更混乱</del> ）。归并排序就是先把数组分左右两个子数组并<strong>对子数组排序</strong>，然后<strong>合并</strong></li><li>递归是逐步缩小子问题，主要是理解<strong>函数的作用及返回的内容</strong><ul><li><code>sortArray()</code> 函数的作用是排序，返回排好序的列表<ul><li>如 [7,5,3] -&gt; 返回[3,5,7]    </li></ul></li><li><code>merge()</code> 函数的作用是对两个有序数组按照由小到大的顺序合并<ul><li>如 left=[2,4,6],right=[3,5,7]-&gt; 合并后返回[2,3,4,5,6,7]</li></ul></li></ul></li></ul><blockquote><p>时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$。参考<a href="https://blog.csdn.net/touch_2011/article/details/6785881" target="_blank" rel="noopener">漫谈经典排序算法</a></p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 函数的作用是排序，不要跳进递归中</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> nums        mid<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>        <span class="token comment" spellcheck="true"># 分成有序的左右两个子列</span>        left<span class="token operator">=</span>self<span class="token punctuation">.</span>sortArray<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>        right<span class="token operator">=</span>self<span class="token punctuation">.</span>sortArray<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 合并</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 按照大小顺序，合并两个子数组</span>    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> len<span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> len<span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 从while条件中跳出后，左右子数组中可能仍有未pop出的元素</span>        <span class="token comment" spellcheck="true"># 所以将其连接到res后面即可</span>        res<span class="token operator">+=</span>left        res<span class="token operator">+=</span>right        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="==快速排序=="></a>==快速排序==</h1><ul><li>将列表的第一个（或最后一个）元素设为pivot，然后在<code>range(1,len(nums))</code>中，小于等于pivot的元素放l，大于pivot的元素放r</li><li>对l和r列表分别递归调用排序函数，并通过<code>left+[pivot]+right</code> 将其连起开，返回最终结果</li><li>注意递归终止的条件及特判<code>if len(nums)&lt;=0:return nums</code><blockquote><p>时间复杂度为 $O(n^2)$</p></blockquote></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 递归终止的条件及特判</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token keyword">return</span> nums        <span class="token comment" spellcheck="true"># 将列表的第一个元素设为pivot，后面的元素中，小于pivot</span>        l<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        r<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        pivot<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">:</span>                l<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        left<span class="token operator">=</span>self<span class="token punctuation">.</span>sortArray<span class="token punctuation">(</span>l<span class="token punctuation">)</span>        right<span class="token operator">=</span>self<span class="token punctuation">.</span>sortArray<span class="token punctuation">(</span>r<span class="token punctuation">)</span>        <span class="token keyword">return</span> left<span class="token operator">+</span><span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token operator">+</span>right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索旋转排序数组系列</title>
      <link href="/2020/07/17/leetcode/sou-suo-xuan-zhuan-pai-xu-shu-zu-xi-lie/"/>
      <url>/2020/07/17/leetcode/sou-suo-xuan-zhuan-pai-xu-shu-zu-xi-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></h1><ul><li><p>二分查找过程中，比较mid与right（而非left）的原因：<br><strong>以 [1,2,3,4,5,6,7] 为例</strong>，分以下<strong>情况</strong></p><ol><li>若[1,2,3,<strong>4</strong>,5,6,7] 左&lt;中，<strong>中&lt;右</strong>。最小值在最左边， 所以更新 <strong>右指针</strong></li><li>若[6,7,1,<strong>2</strong>,3,4,5] 左&gt;中，<strong>中&lt;右</strong>。最小值在mid左边，所以更新 <strong>右指针</strong></li><li>若[4,5,6,<strong>7</strong>,1,2,3] 左&lt;中，<em>中&gt;右</em>。最小值在mid右边，所以更新 <em>左指针</em></li></ol></li><li><p>可见，当中&lt;右时（情况1,2），都是更新右指针，中&gt;右时 （情况3），都是更新左指针（<strong>因为是找最小值，最小值偏左，所以mid和右指针进行比较，更有区分度</strong>）。 但是左&lt;中时 （情况1,3）,指针更新不统一，讨论起来较麻烦。</p></li></ul><blockquote><p>循环条件<strong>l&lt;r</strong>:</p><ul><li>若<code>nums[mid]&gt;nums[r]</code>,说明mid在第一个递增序列，最小值在mid右边，所以l=mid+1 （情况3）</li><li>若<code>nums[mid]&lt;=nums[r]</code>,说明mid在第二个递增序列，最小值在mid处或mid左边，所以r=mid （情况2, 或者如[3,4,0,1,2]）</li></ul></blockquote><pre class="line-numbers language-python"><code class="language-python">  <span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> left<span class="token operator">&lt;</span>right<span class="token punctuation">:</span>            mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                right<span class="token operator">=</span>mid        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/er-fen-fa-python3-by-zhu_shi_fu/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></h1><p>此题与上一题的区别是，增加了重复元素,所以循环条件略有区别，增加了<code>nums[mid]==nums[r]</code>等于时的特判，用right-=1跳过重复元素，使得right慢慢向左跳</p><blockquote><p>循环条件<strong>l&lt;r</strong>:</p><ul><li>若<code>nums[mid]&gt;nums[r]</code>,说明mid在第一个递增序列，最小值在mid右边，所以l=mid+1 （情况3）</li><li>若<code>nums[mid]&lt;nums[r]</code>,说明mid在第二个递增序列，最小值在mid处或mid左边，所以r=mid （情况2, 或者如[3,4,0,1,2]）</li><li>若<code>nums[mid]=nums[r]</code>,r 向左慢慢跳，所以r-=1 （如[1,0,1,1,1]）</li></ul></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> left<span class="token operator">&lt;</span>right<span class="token punctuation">:</span>            mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                right<span class="token operator">=</span>mid            <span class="token keyword">else</span><span class="token punctuation">:</span>                right<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/duo-tu-yan-shi-33-sou-suo-xuan-zhuan-pai-xu-shu-zu/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></h1><p>方法1：找到数组中的最小值后，在第一或第二递增区域内找目标值</p><p>根据上题”153. 寻找旋转排序数组中的最小值” 可以得到最小值，若将最小值<code>minIdx</code>作为旋转点，则有</p><blockquote><ul><li>若最小值下标为0，说明序列是单调递增的，所以在<code>0 - n-1</code> 范围内进行二分查找</li><li>若<code>target&gt;=nums[0]</code>,说明target在第一段递增序列内，所以在<code>nums[0:minIdx]</code> 范围内进行二分查找</li><li>若<code>target&lt;nums[0]</code>,说明target需要在第二段递增序列内找，所以在<code>nums[minIdx:]</code> 范围内进行二分查找<ul><li>如果目标值不在第二递增序列中，则返回-1（如<code>[4,5,6,7,0,1,2]</code>中找target 3），否则返回 <code>minIdx+binarySearch(nums[minIdx:],target)</code>的结果</li></ul></li></ul></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type target: int        :rtype: int        """</span>        <span class="token comment" spellcheck="true"># 找到最小值的下标</span>        <span class="token keyword">def</span> <span class="token function">findMin</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            l<span class="token operator">=</span><span class="token number">0</span>            r<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">:</span>                mid<span class="token operator">=</span>l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                    l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    r<span class="token operator">=</span>mid            <span class="token keyword">return</span> l        <span class="token comment" spellcheck="true"># 普通的二分查找，用于确定目标值下标</span>        <span class="token keyword">def</span>  <span class="token function">binarySearch</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>            l<span class="token operator">=</span><span class="token number">0</span>            r<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> l<span class="token operator">&lt;=</span>r<span class="token punctuation">:</span>                mid<span class="token operator">=</span>l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                    <span class="token keyword">return</span> mid                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                    r<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        minIdx<span class="token operator">=</span>findMin<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> minIdx<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#单调递增，在整个范围内寻找</span>            <span class="token keyword">return</span> binarySearch<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span>        <span class="token keyword">elif</span> target<span class="token operator">>=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 在第一个递增序列内找</span>            <span class="token keyword">return</span> binarySearch<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>minIdx<span class="token punctuation">]</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># target&lt;nums[0]: # 在第二个递增序列内找</span>            <span class="token comment" spellcheck="true"># 如果目标值不在第二递增序列中，则返回-1，否则返回 minIdx+tmp</span>            tmp<span class="token operator">=</span>binarySearch<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>minIdx<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> tmp<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">else</span> minIdx<span class="token operator">+</span>tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法2：直接二分查找,在<strong>严格的递增序列内</strong>找target，其余情况取反</p><ul><li>设置左右指针</li><li><code>nums[mid]==target</code>时，说明已找到目标值，返回 mid （也是while的结束条件）</li><li><code>当nums[mid]&gt;=nums[l]</code> 时（注意这里要取等号，使得满足递增序列只有一个元素的情况也符合(如<code>[3,1]</code>)），说明左边是递增序列，<ul><li>若<strong>target在递增序列内</strong>，则更新右指针</li><li>其他情况更新左指针 （target 在mid的右边，所以更新左指针）</li></ul></li><li>否则当<code>nums[mid]&lt;nums[l]</code>时，说明右边是递增序列<ul><li>若<strong>target在递增序列内</strong>，则更新左指针</li><li>其他情况更新右指针 （target 在mid的左边，所以更新右指针）</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type target: int        :rtype: int        """</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        l<span class="token operator">=</span><span class="token number">0</span>        r<span class="token operator">=</span>n<span class="token number">-1</span>        <span class="token keyword">while</span> l<span class="token operator">&lt;=</span>r<span class="token punctuation">:</span>            mid<span class="token operator">=</span>l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token comment" spellcheck="true"># 找到后，结束循环，跳出</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> mid            <span class="token comment" spellcheck="true"># 左边是递增序列</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">>=</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># target 若在递增序列内，则更新右指针</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">:</span>                    r<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 剩余情况更新左指针</span>                    l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># 右边是递增序列</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># target 若在递增序列内，则更新左指针</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                    l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 剩余情况更新右指针</span>                    r<span class="token operator">=</span>mid<span class="token number">-1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment" spellcheck="true"># 不满足条件时，返回-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/er-fen-by-powcai/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></h1><p>与上题相比，本题增加了重复元素。因此，若检测到重复元素，则左（右）指针要跳，直到不重复：</p><blockquote><p>如[1,1,1,1,2,1], 可保证跳过相邻的相同元素<br>与上题相比，增加如下判断：</p><pre><code>        if nums[mid]==nums[l]==nums[r]:            l+=1            r-=1</code></pre></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type target: int        :rtype: int        """</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        l<span class="token operator">=</span><span class="token number">0</span>        r<span class="token operator">=</span>n<span class="token number">-1</span>        <span class="token keyword">while</span> l<span class="token operator">&lt;=</span>r<span class="token punctuation">:</span>            mid<span class="token operator">=</span>l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token comment" spellcheck="true"># 找到后，结束循环，跳出</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token comment" spellcheck="true"># ******与上题相比，增加的部分****** #</span>            <span class="token triple-quoted-string string">"""            如[1,1,1,1,2,1], 可保证跳过相邻的相同元素            """</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                l<span class="token operator">+=</span><span class="token number">1</span>                r<span class="token operator">-=</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># ******与上题相比，增加的部分****** #</span>            <span class="token comment" spellcheck="true"># 左边是递增序列</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">>=</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># target 若在递增序列内，则更新右指针</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">:</span>                    r<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 剩余情况更新左指针</span>                    l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># 右边是递增序列</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># target 若在递增序列内，则更新左指针</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                    l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 剩余情况更新右指针</span>                    r<span class="token operator">=</span>mid<span class="token number">-1</span>        <span class="token keyword">return</span> <span class="token boolean">False</span> <span class="token comment" spellcheck="true"># 不满足条件时，返回-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个函数秒杀 2Sum 3Sum 问题</title>
      <link href="/2020/07/16/labuladong/yi-ge-han-shu-miao-sha-2sum-3sum-wen-ti/"/>
      <url>/2020/07/16/labuladong/yi-ge-han-shu-miao-sha-2sum-3sum-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://mp.weixin.qq.com/s/fSyJVvggxHq28a0SdmZm6Q" target="_blank" rel="noopener">一个函数秒杀 2Sum 3Sum 4Sum 问题</a></p><h1 id="方法1：利用字典去重的2Sum和3Sum"><a href="#方法1：利用字典去重的2Sum和3Sum" class="headerlink" title="方法1：利用字典去重的2Sum和3Sum"></a>方法1：利用字典去重的2Sum和3Sum</h1><h2 id="2Sum-问题"><a href="#2Sum-问题" class="headerlink" title="2Sum 问题"></a>2Sum 问题</h2><ul><li>利用字典保存遍历过程变量，若满足条件，则返回结果<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token triple-quoted-string string">"""      :type nums: List[int]      :type target: int      :rtype: List[int]      """</span>      dic<span class="token operator">=</span>dict<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> i<span class="token punctuation">,</span>j <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">if</span> target<span class="token operator">-</span>j <span class="token keyword">in</span> dic<span class="token punctuation">:</span>              <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> dic<span class="token punctuation">[</span>target<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span>          dic<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3Sum-问题"><a href="#3Sum-问题" class="headerlink" title="3Sum 问题"></a>3Sum 问题</h2></li><li>在2Sum 的基础上(- 如    <code>[-10,4,4,5,5,6]</code>,对-10 而言，<code>res=[[4,6],[5,5]]</code>)，逐个遍历<code>nums</code> ,求满足target为<code>-nums[i]</code> 的结果</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            dic <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> target <span class="token operator">-</span> j <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>j<span class="token punctuation">,</span> target <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span>                dic<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i            <span class="token comment" spellcheck="true"># 去重，如[[1,2],[1,2],[0,3]] -> [[1,2],[0,3]] (假设target为3)</span>            resAll<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token punctuation">[</span>resAll<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> res <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> resAll<span class="token punctuation">]</span>            <span class="token keyword">return</span> resAll        all <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        nums<span class="token operator">=</span>sorted<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token keyword">continue</span>  <span class="token comment" spellcheck="true"># 若有相等元素，则跳过</span>            target<span class="token operator">=</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            cur<span class="token operator">=</span>twoSum<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 若没有满足条件的twoSum，对结果也没影响.</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> cur<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 对cur中的每组列表都添加当前的nums[i]</span>                c<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                all<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">return</span> all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="方法2：排序后双指针逼近"><a href="#方法2：排序后双指针逼近" class="headerlink" title="方法2：排序后双指针逼近"></a>方法2：排序后双指针逼近</h1><h2 id="2Sum-双指针逼近"><a href="#2Sum-双指针逼近" class="headerlink" title="2Sum 双指针逼近"></a>2Sum 双指针逼近</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type target: int        :rtype: List[int]        """</span>        <span class="token keyword">import</span> copy        nums1<span class="token operator">=</span>copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        nums1<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            cur <span class="token operator">=</span> nums1<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span>            <span class="token keyword">if</span> cur <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> cur <span class="token operator">></span> target<span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>        id1<span class="token operator">=</span>nums<span class="token punctuation">.</span>index<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 使得nums与nums1 的下标相对应</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>id1<span class="token punctuation">)</span>        nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>id1<span class="token punctuation">)</span>        id2<span class="token operator">=</span>nums<span class="token punctuation">.</span>index<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> id2<span class="token operator">>=</span>id1<span class="token punctuation">:</span>            id2<span class="token operator">=</span>id2<span class="token operator">+</span><span class="token number">1</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>id2<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3Sum双指针逼近"><a href="#3Sum双指针逼近" class="headerlink" title="3Sum双指针逼近"></a>3Sum双指针逼近</h2><ul><li><code>sorted(nums)</code>先对列表进行排序, 然后用双指针逼近</li><li>利用twoSum函数返回满足条件的所有列表 <ul><li>如    <code>[-10,4,4,5,5,6]</code>,对-10 而言，<code>res=[[4,6],[5,5]]</code></li><li>设置<code>left</code>，保证<code>nums[l]</code>可以与其左边的元素比较是否相等（<code>right</code>同理）</li><li><code>for i in range(len(nums))</code>  对每一次遍历，就是求满足<code>target</code> 为<code>-nums[i]</code> 的 结果</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[List[int]]        """</span>        <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>                cur <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                left <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                right <span class="token operator">=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                <span class="token keyword">if</span> cur <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> left<span class="token punctuation">:</span> l <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">elif</span> cur <span class="token operator">></span> target<span class="token punctuation">:</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> right<span class="token punctuation">:</span> r <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># 设置left，保证nums[l]可以与其左边的元素比较是否相等（right 同理）</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> left<span class="token punctuation">:</span> l <span class="token operator">+=</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># 一直向右跳，直到不相等</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> right<span class="token punctuation">:</span> r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>            <span class="token keyword">return</span> res        all <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        nums<span class="token operator">=</span>sorted<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token keyword">continue</span>  <span class="token comment" spellcheck="true"># 若有相等元素，则跳过</span>            target<span class="token operator">=</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            cur<span class="token operator">=</span>twoSum<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 若没有满足条件的twoSum，则 不执行下面语句.因为cur为[].</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> cur<span class="token punctuation">:</span>                c<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                all<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">return</span> all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：一个方法团灭 nSum 问题</title>
      <link href="/2020/07/16/labuladong/di-ling-zhang-yi-ge-fang-fa-tuan-mie-nsum-wen-ti/"/>
      <url>/2020/07/16/labuladong/di-ling-zhang-yi-ge-fang-fa-tuan-mie-nsum-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://mp.weixin.qq.com/s/fSyJVvggxHq28a0SdmZm6Q" target="_blank" rel="noopener">一个方法团灭 nSum 问题</a></p><h1 id="方法1：利用字典去重的2Sum和3Sum"><a href="#方法1：利用字典去重的2Sum和3Sum" class="headerlink" title="方法1：利用字典去重的2Sum和3Sum"></a>方法1：利用字典去重的2Sum和3Sum</h1><h2 id="2Sum-问题"><a href="#2Sum-问题" class="headerlink" title="2Sum 问题"></a>2Sum 问题</h2><ul><li>利用字典保存遍历过程变量，若满足条件，则返回结果</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type target: int        :rtype: List[int]        """</span>        dic<span class="token operator">=</span>dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span>j <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> target<span class="token operator">-</span>j <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> dic<span class="token punctuation">[</span>target<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span>            dic<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3Sum-问题"><a href="#3Sum-问题" class="headerlink" title="3Sum 问题"></a>3Sum 问题</h2><ul><li>在2Sum 的基础上(- 如    <code>[-10,4,4,5,5,6]</code>,对-10 而言，<code>res=[[4,6],[5,5]]</code>)，逐个遍历<code>nums</code> ,求满足target为<code>-nums[i]</code> 的结果</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            dic <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> target <span class="token operator">-</span> j <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>j<span class="token punctuation">,</span> target <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span>                dic<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i            <span class="token comment" spellcheck="true"># 去重，如[[1,2],[1,2],[0,3]] -> [[1,2],[0,3]] (假设target为3)</span>            resAll<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token punctuation">[</span>resAll<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> res <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> resAll<span class="token punctuation">]</span>            <span class="token keyword">return</span> resAll        all <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        nums<span class="token operator">=</span>sorted<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token keyword">continue</span>  <span class="token comment" spellcheck="true"># 若有相等元素，则跳过</span>            target<span class="token operator">=</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            cur<span class="token operator">=</span>twoSum<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 若没有满足条件的twoSum，对结果也没影响.</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> cur<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 对cur中的每组列表都添加当前的nums[i]</span>                c<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                all<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">return</span> all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="方法2：排序后双指针逼近"><a href="#方法2：排序后双指针逼近" class="headerlink" title="方法2：排序后双指针逼近"></a>方法2：排序后双指针逼近</h1><h2 id="2Sum-双指针逼近"><a href="#2Sum-双指针逼近" class="headerlink" title="2Sum 双指针逼近"></a>2Sum 双指针逼近</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type target: int        :rtype: List[int]        """</span>        <span class="token keyword">import</span> copy        nums1<span class="token operator">=</span>copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        nums1<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            cur <span class="token operator">=</span> nums1<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span>            <span class="token keyword">if</span> cur <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> cur <span class="token operator">></span> target<span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>        id1<span class="token operator">=</span>nums<span class="token punctuation">.</span>index<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 使得nums与nums1 的下标相对应</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>id1<span class="token punctuation">)</span>        nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>id1<span class="token punctuation">)</span>        id2<span class="token operator">=</span>nums<span class="token punctuation">.</span>index<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> id2<span class="token operator">>=</span>id1<span class="token punctuation">:</span>            id2<span class="token operator">=</span>id2<span class="token operator">+</span><span class="token number">1</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>id2<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3Sum双指针逼近"><a href="#3Sum双指针逼近" class="headerlink" title="3Sum双指针逼近"></a>3Sum双指针逼近</h2><ul><li><code>sorted(nums)</code>先对列表进行排序, 然后用双指针逼近</li><li>利用twoSum函数返回满足条件的所有列表 <ul><li>如    <code>[-10,4,4,5,5,6]</code>,对-10 而言，<code>res=[[4,6],[5,5]]</code></li><li>设置<code>left</code>，保证<code>nums[l]</code>可以与其左边的元素比较是否相等（<code>right</code>同理）</li><li><code>for i in range(len(nums))</code>  对每一次遍历，就是求满足<code>target</code> 为<code>-nums[i]</code> 的 结果</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[List[int]]        """</span>        <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>                cur <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                left <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                right <span class="token operator">=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                <span class="token keyword">if</span> cur <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> left<span class="token punctuation">:</span> l <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">elif</span> cur <span class="token operator">></span> target<span class="token punctuation">:</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> right<span class="token punctuation">:</span> r <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># 设置left，保证nums[l]可以与其左边的元素比较是否相等（right 同理）</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> left<span class="token punctuation">:</span> l <span class="token operator">+=</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># 一直向右跳，直到不相等</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> right<span class="token punctuation">:</span> r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>            <span class="token keyword">return</span> res        all <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        nums<span class="token operator">=</span>sorted<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token keyword">continue</span>  <span class="token comment" spellcheck="true"># 若有相等元素，则跳过</span>            target<span class="token operator">=</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            cur<span class="token operator">=</span>twoSum<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 若没有满足条件的twoSum，则 不执行下面语句.因为cur为[].</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> cur<span class="token punctuation">:</span>                c<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                all<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">return</span> all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="nSum的变体"><a href="#nSum的变体" class="headerlink" title="nSum的变体"></a>nSum的变体</h1><p>nums中可能有多对元素之和都等于 target，请返回所有和为 target 的元素对，且不能出现重复。</p><p>比如输入为 nums = [1,3,1,2,2,3], target = 4，那么算法返回的结果就是：[[1,3],[2,2]]</p><ul><li>排序</li><li>通过左右指针更新，若有相同元素，则跳过。<code>left = nums[l]</code>和<code>right = nums[r]</code> 的作用是记录当前位置，从而便于后续跳过相同的元素</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>    l <span class="token operator">=</span> <span class="token number">0</span>    r <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    nums <span class="token operator">=</span> sorted<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>        sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>        left <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>        right <span class="token operator">=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 便于后续跳过相同的元素</span>        <span class="token keyword">if</span> sum <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>            l <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> sum <span class="token operator">></span> target<span class="token punctuation">:</span>            r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> left<span class="token punctuation">:</span> l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> right<span class="token punctuation">:</span> r <span class="token operator">-=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>target <span class="token operator">=</span> <span class="token number">4</span>twoSum<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 结果为：[[1, 3], [2, 2]]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何判断回文链表</title>
      <link href="/2020/07/13/labuladong/di-si-zhang-ru-he-pan-duan-hui-wen-lian-biao/"/>
      <url>/2020/07/13/labuladong/di-si-zhang-ru-he-pan-duan-hui-wen-lian-biao/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/pan-duan-hui-wen-lian-biao" target="_blank" rel="noopener">如何判断回文链表</a></p><h1 id="方法1：链表转列表，双指针逼近"><a href="#方法1：链表转列表，双指针逼近" class="headerlink" title="方法1：链表转列表，双指针逼近"></a>方法1：链表转列表，双指针逼近</h1><p>将链表转化为列表，然后利用左右双指针技巧，从两端到中间逼近</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: bool        """</span>        <span class="token comment" spellcheck="true"># 转成列表</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> head<span class="token punctuation">:</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            head<span class="token operator">=</span>head<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true"># 左右双指针逼近</span>        l<span class="token operator">=</span><span class="token number">0</span>        r<span class="token operator">=</span>len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> l<span class="token operator">&lt;=</span>r<span class="token punctuation">:</span>            <span class="token keyword">if</span>  stack<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">!=</span>stack<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                l<span class="token operator">+=</span><span class="token number">1</span>                r<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="方法2：反转后半部分链表后，逐个比较节点值"><a href="#方法2：反转后半部分链表后，逐个比较节点值" class="headerlink" title="方法2：反转后半部分链表后，逐个比较节点值"></a>方法2：反转后半部分链表后，逐个比较节点值</h1><p><strong>思路</strong></p><ul><li>边界条件（如[] 或者 [2]）直接返回</li><li>快慢指针找中点</li><li>反转以slow为开头的链表</li><li>只需判断p2存在时，p1是否等于p2</li></ul><p><strong>步骤</strong></p><p>以偶数为例（奇数类似）</p><p>链表：<code>1-&gt;2-&gt;2-&gt;1</code><br>下标：[0] [1] [2] [3]</p><ol><li>快慢指针后，slow指向第二个2(下标为[2])，fast已跳出链表</li><li>此时slow后面的链表为<code>2-&gt;1</code>。反转时，2(下标为[2])指向prev的None,1指向2。最后有<code>None&lt;-2&lt;-1</code>（此时prev在下标[3]处）。（注意：此时前半段中，<strong>下标为[1]的节点2仍然指向下标为[2]的节点2</strong>）</li><li>此时，以head开头的p1为<code>1-&gt;2-&gt;2-&gt;None</code>,以prev开头的p2为<code>None&lt;-2&lt;-1</code>,所以只需判断p2存在时，p1是否等于p2。</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: bool        """</span>        <span class="token comment" spellcheck="true"># 边界条件，直接跳出,如[] 或者 [2]</span>        <span class="token comment" spellcheck="true"># if not head or not head.next: return True</span>        <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token punctuation">(</span>head <span class="token operator">and</span> head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span> <span class="token comment" spellcheck="true"># 必须有括号，and后取其反</span>        <span class="token comment" spellcheck="true"># 快慢指针找中点</span>        slow<span class="token operator">=</span>head        fast<span class="token operator">=</span>head        <span class="token keyword">while</span> fast <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true"># 反转以slow开始的后半部分链表</span>        prev <span class="token operator">=</span> None        cur<span class="token operator">=</span>slow        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>            cur<span class="token punctuation">.</span>next<span class="token punctuation">,</span>prev<span class="token punctuation">,</span>cur<span class="token operator">=</span>prev<span class="token punctuation">,</span>cur<span class="token punctuation">,</span>cur<span class="token punctuation">.</span>next        p1<span class="token operator">=</span>head        p2<span class="token operator">=</span>prev        <span class="token comment" spellcheck="true"># 只需判断p2存在时，p1是否等于p2</span>        <span class="token keyword">while</span> p2<span class="token punctuation">:</span>            <span class="token keyword">if</span> p1<span class="token punctuation">.</span>val<span class="token operator">!=</span>p2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            p1<span class="token operator">=</span>p1<span class="token punctuation">.</span>next            p2<span class="token operator">=</span>p2<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何同时寻找缺失和重复的元素</title>
      <link href="/2020/07/13/labuladong/di-si-zhang-ru-he-tong-shi-xun-zhao-que-shi-he-chong-fu-de-yuan-su/"/>
      <url>/2020/07/13/labuladong/di-si-zhang-ru-he-tong-shi-xun-zhao-que-shi-he-chong-fu-de-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/que-shi-he-zhong-fu-de-yuan-su" target="_blank" rel="noopener">如何同时寻找缺失和重复的元素</a></p><p><a href="https://leetcode-cn.com/problems/set-mismatch/" target="_blank" rel="noopener">645. 错误的集合</a></p><ul><li>利用set去重，并记录重复的元素</li><li>遍历一遍<code>range(1,len(nums)+1)</code>,找到并记录不存在的于set中的元素</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findErrorNums</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[int]        """</span>        se<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> se<span class="token punctuation">:</span>                se<span class="token punctuation">.</span>add<span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 利用set去重</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 顺便记录重复的元素</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> se<span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 找到并记录不存在的于set中的元素</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何寻找缺失的元素</title>
      <link href="/2020/07/13/labuladong/di-si-zhang-ru-he-xun-zhao-que-shi-de-yuan-su/"/>
      <url>/2020/07/13/labuladong/di-si-zhang-ru-he-xun-zhao-que-shi-de-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/xiao-shi-de-yuan-su" target="_blank" rel="noopener">如何寻找缺失的元素</a></p><p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a></p><ul><li>先遍历列表，并加到set中。利用 HashSet 去重</li><li>若元素不在列表中，则表示该元素缺失</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findDisappearedNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[int]        """</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        se<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            se<span class="token punctuation">.</span>add<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> se<span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何判定括号合法性</title>
      <link href="/2020/07/13/labuladong/di-si-zhang-ru-he-pan-ding-gua-hao-he-fa-xing/"/>
      <url>/2020/07/13/labuladong/di-si-zhang-ru-he-pan-ding-gua-hao-he-fa-xing/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/he-fa-kuo-hao-pan-ding" target="_blank" rel="noopener">如何判定括号合法性</a></p><p><strong>解题思路</strong>：遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号（栈顶元素），看是否匹配。</p><p>Krahets的<a href="https://leetcode-cn.com/problems/valid-parentheses/solution/valid-parentheses-fu-zhu-zhan-fa-by-jin407891080/" target="_blank" rel="noopener">极简思路及实现</a></p><blockquote><p><strong>栈 stack 为空： 此时 stack.pop() 操作会报错</strong>；因此，我们采用一个取巧方法，给 stack 赋初值 ?? ，并在哈希表 dic 中建立 key: ‘?’，value:’?’key: ′ ? ′ ，value: ′ ? ′  的对应关系予以配合。</p></blockquote><ul><li>建立哈希表 dic 构建左右括号对应关系：keykey 左括号，valuevalue 右括号</li><li>如果 <code>c</code> 是左括号，则入栈 push</li><li>否则通过哈希表判断括号对应关系，若 stack 栈顶出栈括号 stack.pop() 与当前遍历括号 <code>c</code>不对应，则提前返回 False</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: bool        """</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'('</span><span class="token punctuation">:</span><span class="token string">')'</span><span class="token punctuation">,</span><span class="token string">'{'</span><span class="token punctuation">:</span><span class="token string">'}'</span><span class="token punctuation">,</span><span class="token string">'['</span><span class="token punctuation">:</span><span class="token string">']'</span><span class="token punctuation">,</span><span class="token string">'?'</span><span class="token punctuation">:</span><span class="token string">'?'</span><span class="token punctuation">}</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'?'</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>            <span class="token keyword">elif</span> c<span class="token operator">==</span>dic<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何寻找最长回文子串</title>
      <link href="/2020/07/13/labuladong/di-si-zhang-ru-he-xun-zhao-zui-chang-hui-wen-zi-chuan/"/>
      <url>/2020/07/13/labuladong/di-si-zhang-ru-he-xun-zhao-zui-chang-hui-wen-zi-chuan/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.md" target="_blank" rel="noopener">如何寻找最长回文子串</a></p><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></p><ul><li>回文串的长度可能是奇数也可能是偶数，如果是 abba这种情况，没有一个中心字符。所以可以：<ul><li>找到以 s[i] 为中心的回文串（对奇数回文串），<br>找到以 s[i] 和 s[i+1] 为中心的回文串（对偶数回文串），<br>更新答案</li></ul></li><li>选择最长的回文串，保存在res中</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: str        """</span>        <span class="token keyword">def</span> <span class="token function">palindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 若左右指针没越界，且元素相等，则指针向两边扩散</span>            <span class="token keyword">while</span> l<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> r<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                    l<span class="token operator">-=</span><span class="token number">1</span>                    r<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">return</span> s<span class="token punctuation">[</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token string">""</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            s1<span class="token operator">=</span>palindrome<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span>            s2<span class="token operator">=</span>palindrome<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#这里越界无所谓，因为调用palindrome时已经不满足while条件，可直接跳出</span>            <span class="token comment" spellcheck="true"># 选择最长的回文串保存在res中</span>            res<span class="token operator">=</span>res <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">></span>len<span class="token punctuation">(</span>s1<span class="token punctuation">)</span> <span class="token keyword">else</span> s1            res<span class="token operator">=</span>res <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">></span>len<span class="token punctuation">(</span>s2<span class="token punctuation">)</span> <span class="token keyword">else</span> s2        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何k个一组反转链表</title>
      <link href="/2020/07/13/labuladong/di-si-zhang-ru-he-k-ge-yi-zu-fan-zhuan-lian-biao/"/>
      <url>/2020/07/13/labuladong/di-si-zhang-ru-he-k-ge-yi-zu-fan-zhuan-lian-biao/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/k-ge-yi-zu-fan-zhuan-lian-biao" target="_blank" rel="noopener">如何k个一组反转链表</a></p><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a></p><p>利用栈先进后出，反转k个一组的链表</p><ul><li>stack中存放的是ListNode<ul><li>虽然存放在stack中，但ListNode之间的指向关系仍然保留</li></ul></li></ul><p>以 1-&gt;2-&gt;3-&gt;4-&gt;5 为例，</p><ul><li>先在最左边加一个dummy头(-1)便于操作。</li><li>注意：大循环 <code>while cur</code>里面的while n&gt;0 <strong>and cur</strong> 一定要有，确保不够k个Node时n&gt;0，及时跳出。</li><li>第一次while时，stack中存放 [3,2,1],pre产生的结果是： -1-&gt;3-&gt;2-&gt;1 。此时cur 指向4，pre指向3。<code>pre.next=cur</code>后现在的结果是-1-&gt;3-&gt;2-&gt;1-&gt;4-&gt;5</li><li>第二次while时，stack中存放[5,4],但是由于n！=0，直接break出循环（即<code>pre.next=cur</code>不执行）。此时cur已经指向5后面的None，但是现在已经跳出while循环了，<strong>不必理会cur</strong>。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>head<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        dummy<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        dummy<span class="token punctuation">.</span>next<span class="token operator">=</span>head        pre<span class="token operator">=</span>dummy        cur<span class="token operator">=</span>head        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># while True：</span>            n<span class="token operator">=</span>k            <span class="token keyword">while</span> n<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> cur<span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>                cur<span class="token operator">=</span>cur<span class="token punctuation">.</span>next                n<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> stack<span class="token punctuation">:</span>                    pre<span class="token punctuation">.</span>next<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                    pre<span class="token operator">=</span>pre<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>            pre<span class="token punctuation">.</span>next<span class="token operator">=</span>cur        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何运用贪心思想玩跳跃游戏</title>
      <link href="/2020/07/12/labuladong/di-si-zhang-ru-he-yun-yong-tan-xin-si-xiang-wan-tiao-yue-you-xi/"/>
      <url>/2020/07/12/labuladong/di-si-zhang-ru-he-yun-yong-tan-xin-si-xiang-wan-tiao-yue-you-xi/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/tiao-yue-you-xi" target="_blank" rel="noopener">如何运用贪心思想玩跳跃游戏</a></p><p>有关动态规划的问题，大多是让你求最值的，比如<strong>最长子序列，最小编辑距离，最长公共子串等等等</strong>。</p><p>那么贪心算法作为特殊的动态规划也是一样，也一定是让你求个最值。这道题就是让求：请问通过题目中的跳跃规则，<strong>最多能跳多远</strong>？如果能够越过最后一格，返回 true，否则返回 false。</p><p>两道题都注意，在 <code>for i in range (len(nums)-1)</code>    处就停止，不考虑最后一个元素的下标及元素的大小。因为nums[-1] 不会再用到，若加入，反而会干扰部分结果，产生错误 （如<code>[2,0,0]</code>）。</p><p><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏1</a></p><p><code>farthest</code>表示到达最远距离的下标</p><ul><li>每一步都计算一下从当前位置最远能够跳到哪里，然后和一个全局最优的最远位置 farthest 做对比，通过每一步的最优解，更新全局最优解，这就是贪心。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canJump</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: bool        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token comment" spellcheck="true"># 到达最远距离的下标</span>        farthest<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            farthest<span class="token operator">=</span>max<span class="token punctuation">(</span>farthest<span class="token punctuation">,</span>i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 到达不了</span>            <span class="token keyword">if</span> farthest<span class="token operator">&lt;=</span>i<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> farthest<span class="token operator">>=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏2</a></p><ul><li>我们不需要【递归地】计算出所有选择的具体结果然后比较求最值，而只需要做出那个最有【潜力】，看起来最优的选择即可。</li><li>i 和 end 标记了可以选择的跳跃步数，farthest 标记了所有选择 [i..end] 中能够跳到的最远距离，step记录了跳跃次数。</li><li>当i遍历到end处时，把end更新为更远的farthest，步数+1</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">jump</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        farthest<span class="token punctuation">,</span>end<span class="token punctuation">,</span>step<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            farthest<span class="token operator">=</span>max<span class="token punctuation">(</span>farthest<span class="token punctuation">,</span>i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> i<span class="token operator">==</span>end<span class="token punctuation">:</span>                end<span class="token operator">=</span>farthest                step<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> step<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
