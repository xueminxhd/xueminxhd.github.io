<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面经整理发布版</title>
      <link href="/2020/08/29/ji-suan-ji-ji-chu/mian-jing-yuan-wen-jian/mian-jing-zheng-li-fa-bu-ban/"/>
      <url>/2020/08/29/ji-suan-ji-ji-chu/mian-jing-yuan-wen-jian/mian-jing-zheng-li-fa-bu-ban/</url>
      
        <content type="html"><![CDATA[<h1 id="1-语言基础-C-C"><a href="#1-语言基础-C-C" class="headerlink" title="1. 语言基础 (C/C++)"></a>1. 语言基础 (C/C++)</h1><h4 id="（0）-指针和引用的区别"><a href="#（0）-指针和引用的区别" class="headerlink" title="（0） 指针和引用的区别"></a>（0） 指针和引用的区别</h4><ul><li>指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作</li><li>指针可以有多级，引用只有一级</li><li>传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改</li><li>指针的大小一般是4个字节，引用的大小取决于被引用对象的大小</li><li>指针可以为空，引用不可以。</li></ul><h4 id="（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"><a href="#（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？" class="headerlink" title="（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"></a>（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？</h4><ul><li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li><li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li><li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式<h4 id="（2）-堆和栈有什么区别"><a href="#（2）-堆和栈有什么区别" class="headerlink" title="（2） 堆和栈有什么区别"></a>（2） 堆和栈有什么区别</h4></li><li>从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。</li><li>堆空间因为会有频繁的分配释放操作，会产生内存碎片</li><li>堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小<h4 id="（3）堆快一点还是栈快一点？（字节提前批一面）"><a href="#（3）堆快一点还是栈快一点？（字节提前批一面）" class="headerlink" title="（3）堆快一点还是栈快一点？（字节提前批一面）"></a>（3）堆快一点还是栈快一点？（字节提前批一面）</h4>栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。<h4 id="（4）-new和delete是如何实现的，new-与-malloc的异同处"><a href="#（4）-new和delete是如何实现的，new-与-malloc的异同处" class="headerlink" title="（4） new和delete是如何实现的，new 与 malloc的异同处"></a>（4） new和delete是如何实现的，new 与 malloc的异同处</h4>在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。delete会调用对象的析构函数，然后调用free回收内存。</li></ul><p>new与malloc都会分配空间，但是new还会调用对象的构造函数进行初始化，malloc需要给定空间大小，而new只需要对象名</p><h4 id="（5）既然有了malloc-free，C-中为什么还需要new-delete呢？"><a href="#（5）既然有了malloc-free，C-中为什么还需要new-delete呢？" class="headerlink" title="（5）既然有了malloc/free，C++中为什么还需要new/delete呢？"></a>（5）既然有了malloc/free，C++中为什么还需要new/delete呢？</h4><p><a href="https://blog.csdn.net/leikun153/article/details/80612130" target="_blank" rel="noopener">https://blog.csdn.net/leikun153/article/details/80612130</a></p><ul><li><p>malloc/free和new/delete都是用来申请内存和回收内存的。</p></li><li><p>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free。</p><h4 id="（6）-C和C-的区别"><a href="#（6）-C和C-的区别" class="headerlink" title="（6） C和C++的区别"></a>（6） C和C++的区别</h4><p>包括但不限于：</p></li><li><p>C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性。封装隐藏了实现细节，使得代码模块化。继承通过子类继承父类的方法和属性，实现了代码重用。多态则是“一个接口，多个实现”，通过子类重写父类的虚函数，实现了接口重用。</p></li><li><p>C和C++内存管理的方法不一样，C使用malloc/free，C++除此之外还用new/delete</p></li><li><p>C++中还有函数重载和引用等概念，C中没有</p><h4 id="（7）delete和delete-的区别"><a href="#（7）delete和delete-的区别" class="headerlink" title="（7）delete和delete[]的区别"></a>（7）delete和delete[]的区别</h4></li><li><p>delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数</p></li><li><p>用new分配的内存用delete释放，用new[]分配的内存用delete[]释放</p></li></ul><h4 id="（8）-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"><a href="#（8）-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）" class="headerlink" title="（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"></a>（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</h4><p>包括但不限于：</p><ul><li>C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高。</li><li>C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法</li><li>C++有指针，Java没有指针，只有引用</li><li>JAVA和C++都有构造函数，但是C++有析构函数但是Java没有<h4 id="（9）C-和python的区别"><a href="#（9）C-和python的区别" class="headerlink" title="（9）C++和python的区别"></a>（9）C++和python的区别</h4>包括但不限于：</li></ul><ol><li>python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。</li><li>python使用缩进来区分不同的代码块，C++使用花括号来区分</li><li>C++中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等等</li><li>python的库函数比C++的多，调用起来很方便<h4 id="（10）-Struct和class的区别"><a href="#（10）-Struct和class的区别" class="headerlink" title="（10） Struct和class的区别"></a>（10） Struct和class的区别</h4></li></ol><ul><li><p>使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的</p></li><li><p>struct的继承默认是public继承，而class的继承默认是private继承</p></li><li><p>class可以用作模板，而struct不能</p><h4 id="（11）-define-和const的联系与区别（编译阶段、安全性、内存占用等）"><a href="#（11）-define-和const的联系与区别（编译阶段、安全性、内存占用等）" class="headerlink" title="（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）"></a>（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）</h4><p>联系：它们都是定义常量的一种方法。</p><p>区别：</p></li><li><p>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。</p></li><li><p>define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</p></li><li><p>define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。</p></li><li><p>const可以定义函数而define不可以。</p><h4 id="（12）-在C-中const的用法（定义，用途）"><a href="#（12）-在C-中const的用法（定义，用途）" class="headerlink" title="（12） 在C++中const的用法（定义，用途）"></a>（12） 在C++中const的用法（定义，用途）</h4></li><li><p>const修饰类的成员变量时，表示常量不能被修改</p></li><li><p>const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数</p></li></ul><h4 id="（13）-C-中的static用法和意义"><a href="#（13）-C-中的static用法和意义" class="headerlink" title="（13） C++中的static用法和意义"></a>（13） C++中的static用法和意义</h4><p>static的意思是静态的，可以用来修饰变量，函数和类成员。</p><ul><li><p>变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件里。</p></li><li><p>函数：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突。</p></li><li><p>类：而在类中，被static修饰的成员变量是类静态成员，这个静态成员会被类的多个对象共用。被static修饰的成员函数也属于静态成员，不是属于某个对象的，访问这个静态函数不需要引用对象名，而是通过引用类名来访问。</p></li></ul><p>【note】静态成员函数要访问非静态成员时，要用过对象来引用。局部静态变量在函数调用结束后也不会被回收，会一直在程序内存中，直到该函数再次被调用，它的值还是保持上一次调用结束后的值。</p><p>注意和const的区别。const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用。</p><h4 id="（14）-计算下面几个类的大小："><a href="#（14）-计算下面几个类的大小：" class="headerlink" title="（14） 计算下面几个类的大小："></a>（14） 计算下面几个类的大小：</h4><pre class="line-numbers language-C++"><code class="language-C++">class A {};int main(){  cout<<sizeof(A)<<endl;// 输出 1;  A a;   cout<<sizeof(a)<<endl;// 输出 1;  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。</p><p>空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。</p><pre class="line-numbers language-C++"><code class="language-C++">class A { virtual Fun(){} };int main(){  cout<<sizeof(A)<<endl;// 输出 4(32位机器)/8(64位机器);  A a;   cout<<sizeof(a)<<endl;// 输出 4(32位机器)/8(64位机器);  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节<br></p><pre class="line-numbers language-C++"><code class="language-C++">class A { static int a; };int main(){  cout<<sizeof(A)<<endl;// 输出 1;  A a;   cout<<sizeof(a)<<endl;// 输出 1;  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</p><pre class="line-numbers language-C++"><code class="language-C++">class A { int a; };int main(){  cout<<sizeof(A)<<endl;// 输出 4;  A a;   cout<<sizeof(a)<<endl;// 输出 4;  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++"><code class="language-C++">class A { static int a; int b; };;int main(){  cout<<sizeof(A)<<endl;// 输出 4;  A a;   cout<<sizeof(a)<<endl;// 输出 4;  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节</p><h4 id="（15）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"><a href="#（15）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等" class="headerlink" title="（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"></a>（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</h4><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p><ul><li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li><li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li><li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。<h4 id="（16）-STL源码中的hash表的实现"><a href="#（16）-STL源码中的hash表的实现" class="headerlink" title="（16） STL源码中的hash表的实现"></a>（16） STL源码中的hash表的实现</h4>STL中的hash表就unordered_map。使用的是哈希进行实现（注意与map的区别）。它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。</li></ul><p>unordered_map的底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，当桶的大小超过8时，就自动转为红黑树进行组织。</p><h4 id="（17）解决哈希冲突的方式？"><a href="#（17）解决哈希冲突的方式？" class="headerlink" title="（17）解决哈希冲突的方式？"></a>（17）解决哈希冲突的方式？</h4><ol><li>线性探查。该元素的哈希值对应的桶不能存放元素时，循序往后一一查找，直到找到一个空桶为止，在查找时也一样，当哈希值对应位置上的元素与所要寻找的元素不同时，就往后一一查找，直到找到吻合的元素，或者空桶。</li><li>二次探查。该元素的哈希值对应的桶不能存放元素时，就往后寻找1^2,2^2,3^2,4^2…..i^2个位置。</li><li>双散列函数法。当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长。</li><li>开链法。在每一个桶中维护一个链表，由元素哈希值寻找到这个桶，然后将元素插入到对应的链表中，STL的hashtable就是采用这种实现方式。</li><li>建立公共溢出区。当发生冲突时，将所有冲突的数据放在公共溢出区。<h4 id="（18）-STL中unordered-map和map的区别"><a href="#（18）-STL中unordered-map和map的区别" class="headerlink" title="（18） STL中unordered_map和map的区别"></a>（18） STL中unordered_map和map的区别</h4></li></ol><ul><li>unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现==操作符。</li><li>map底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(&lt;)。<h4 id="（19）-STL中vector的实现"><a href="#（19）-STL中vector的实现" class="headerlink" title="（19） STL中vector的实现"></a>（19） STL中vector的实现</h4>STL中的vector是封装了动态数组的顺序容器。不过与动态数组不同的是，vector可以根据需要自动扩大容器的大小。具体策略是每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。</li></ul><p>在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。</p><h4 id="（20）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。"><a href="#（20）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。" class="headerlink" title="（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。"></a>（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</h4><p>如果需要频繁插入，最好先指定vector的大小，因为vector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用push_back()会使得程序花费很多时间在vector扩容上，会变得很慢。这种情况可以考虑使用list。</p><h4 id="（21）C-中vector和list的区别"><a href="#（21）C-中vector和list的区别" class="headerlink" title="（21）C++中vector和list的区别"></a>（21）C++中vector和list的区别</h4><p>vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。</p><p>list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。</p><p>vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+=”，“&lt;”等操作符。</p><p>list的内存空间可以是不连续，它不支持随机访问，因此list::iterator则不支持“+”、“+=”、“&lt;”等</p><p>vector::iterator和list::iterator都重载了“++”运算符。</p><p>总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;</p><p>如果需要大量的插入和删除，而不关心随机存取，则应使用list。</p><h4 id="（22）-C-中的重载和重写的区别："><a href="#（22）-C-中的重载和重写的区别：" class="headerlink" title="（22） C++中的重载和重写的区别："></a>（22） C++中的重载和重写的区别：</h4><ul><li>重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。</li><li>重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。</li></ul><p>详见：<a href="https://blog.csdn.net/weixin_30379911/article/details/99497160" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30379911/article/details/99497160</a></p><h4 id="（23）-C-内存管理（热门问题）"><a href="#（23）-C-内存管理（热门问题）" class="headerlink" title="（23） C ++内存管理（热门问题）"></a>（23） C ++内存管理（热门问题）</h4><p><a href="https://blog.csdn.net/qq_43152052/article/details/98889139" target="_blank" rel="noopener">https://blog.csdn.net/qq_43152052/article/details/98889139</a></p><p>在C++中，内存分成5个区，他们分别是堆、栈、全局/静态存储区和常量存储区和代码区。</p><ul><li>栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li><li>堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</li><li>全局/静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。</li><li>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。</li><li>代码区，存放程序的二进制代码</li></ul><p>关于这个有很多种说法，有的会增加一个自由存储区，存放malloc分配得到的内存，与堆相似。</p><h4 id="（24）-介绍面向对象的三大特性，并且举例说明每一个。"><a href="#（24）-介绍面向对象的三大特性，并且举例说明每一个。" class="headerlink" title="（24） 介绍面向对象的三大特性，并且举例说明每一个。"></a>（24） 介绍面向对象的三大特性，并且举例说明每一个。</h4><p>面向对象的三大特性是：封装，继承和多态。</p><ul><li><p>封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public；</p></li><li><p>继承使得子类可以复用父类的成员和方法，实现了代码重用；</p></li><li><p>多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。</p><h4 id="（25）-多态的实现（和下个问题一起回答）"><a href="#（25）-多态的实现（和下个问题一起回答）" class="headerlink" title="（25） 多态的实现（和下个问题一起回答）"></a>（25） 多态的实现（和下个问题一起回答）</h4><p>C++ 多态包括编译时多态和运行时多态，编译时多态体现在函数重载和模板上，运行时多态体现在虚函数上。</p></li><li><p>虚函数：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.</p><h4 id="（26）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"><a href="#（26）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）" class="headerlink" title="（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"></a>（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</h4><p>C++的虚函数是实现多态的机制。它是通过虚函数表实现的，虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。</p></li></ul><p>详见：<a href="https://blog.csdn.net/lihao21/article/details/50688337" target="_blank" rel="noopener">C++虚函数表剖析</a></p><ul><li>如果多重继承和多继承的话，子类的虚函数表长什么样子？<br>多重继承的情况下越是祖先的父类的虚函数更靠前，多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前。详见：<a href="https://blog.csdn.net/qq_36359022/article/details/81870219" target="_blank" rel="noopener">https://blog.csdn.net/qq_36359022/article/details/81870219</a></li></ul><h4 id="（27）-实现编译器处理虚函数表应该如何处理"><a href="#（27）-实现编译器处理虚函数表应该如何处理" class="headerlink" title="（27） 实现编译器处理虚函数表应该如何处理"></a>（27） 实现编译器处理虚函数表应该如何处理</h4><p>编译器处理虚函数的方法是：<br>如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。<br>为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。<br>详见：<a href="https://blog.csdn.net/iFuMI/article/details/51088091" target="_blank" rel="noopener">虚函数的作用及其底层实现机制</a></p><h4 id="（28）-基类的析构函数一般写成虚函数的原因"><a href="#（28）-基类的析构函数一般写成虚函数的原因" class="headerlink" title="（28） 基类的析构函数一般写成虚函数的原因"></a>（28） 基类的析构函数一般写成虚函数的原因</h4><p>首先析构函数可以为虚函数，当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。</p><p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。</p><h4 id="（29）-构造函数为什么一般不定义为虚函数"><a href="#（29）-构造函数为什么一般不定义为虚函数" class="headerlink" title="（29） 构造函数为什么一般不定义为虚函数"></a>（29） 构造函数为什么一般不定义为虚函数</h4><p>1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，<strong>由于对象还未创建成功，编译器无法知道对象的实际类型</strong>，是类本身还是类的派生类等等</p><p>2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了</p><h4 id="（30）-构造函数或者析构函数中调用虚函数会怎样"><a href="#（30）-构造函数或者析构函数中调用虚函数会怎样" class="headerlink" title="（30） 构造函数或者析构函数中调用虚函数会怎样"></a>（30） 构造函数或者析构函数中调用虚函数会怎样</h4><p>在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。</p><p>在析构函数中调用虚函数，此时调用的是子类的函数实现方式。</p><h4 id="（31）-纯虚函数"><a href="#（31）-纯虚函数" class="headerlink" title="（31） 纯虚函数"></a>（31） 纯虚函数</h4><p>纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承</p><p>包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象</p><p>使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。</p><h4 id="（32）-静态绑定和动态绑定的介绍"><a href="#（32）-静态绑定和动态绑定的介绍" class="headerlink" title="（32） 静态绑定和动态绑定的介绍"></a>（32） 静态绑定和动态绑定的介绍</h4><p><a href="https://www.cnblogs.com/lizhenghn/p/3657717.html" target="_blank" rel="noopener">C++中的静态绑定和动态绑定</a></p><p>静态绑定也就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。</p><p>动态绑定就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。</p><h4 id="（33）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"><a href="#（33）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）" class="headerlink" title="（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"></a>（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h4><p>浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。</p><p>而深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。</p><p>深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。</p><h4 id="（34）-对象复用的了解，零拷贝的了解"><a href="#（34）-对象复用的了解，零拷贝的了解" class="headerlink" title="（34） 对象复用的了解，零拷贝的了解"></a>（34） 对象复用的了解，零拷贝的了解</h4><p>对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是继承和组合模式了。</p><p>零拷贝指的是在进行操作时，避免CPU从一处存储拷贝到另一处存储。在Linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read调用。</p><blockquote><p>用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。</p></blockquote><h4 id="（35）-介绍C-所有的构造函数"><a href="#（35）-介绍C-所有的构造函数" class="headerlink" title="（35） 介绍C++所有的构造函数"></a>（35） 介绍C++所有的构造函数</h4><p>C++中的构造函数主要有三种类型：默认构造函数、重载构造函数和拷贝构造函数</p><ul><li>默认构造函数是当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。</li><li>重载构造函数也称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。</li><li>拷贝构造函数是在发生对象复制的时候调用的。 <h4 id="（36）-什么情况下会调用拷贝构造函数（三种情况）"><a href="#（36）-什么情况下会调用拷贝构造函数（三种情况）" class="headerlink" title="（36） 什么情况下会调用拷贝构造函数（三种情况）"></a>（36） 什么情况下会调用拷贝构造函数（三种情况）</h4></li><li>对象以值传递的方式传入函数参数 <blockquote><p>如 <code>void func(Dog dog){};</code></p></blockquote></li><li>对象以值传递的方式从函数返回<blockquote><p>如 <code>Dog func(){ Dog d; return d;}</code></p></blockquote></li><li>对象需要通过另外一个对象进行初始化</li></ul><p>详见：<a href="https://blog.csdn.net/lwbeyond/article/details/6202256" target="_blank" rel="noopener">C++拷贝构造函数详解</a></p><h4 id="（37）-结构体内存对齐方式和为什么要进行内存对齐？"><a href="#（37）-结构体内存对齐方式和为什么要进行内存对齐？" class="headerlink" title="（37） 结构体内存对齐方式和为什么要进行内存对齐？"></a>（37） 结构体内存对齐方式和为什么要进行内存对齐？</h4><p>因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。</p><p>对齐规则：</p><ul><li>第一个成员在与结构体变量偏移量为0的地址</li><li>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。</li><li>对齐数=编译器默认的一个对齐数 与 该成员大小的较小值。</li><li>linux 中默认为4</li><li>vs 中的默认值为8<br>结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）</li></ul><h4 id="（38）-内存泄露的定义，如何检测与避免？"><a href="#（38）-内存泄露的定义，如何检测与避免？" class="headerlink" title="（38） 内存泄露的定义，如何检测与避免？"></a>（38） 内存泄露的定义，如何检测与避免？</h4><p>动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。</p><p>造成内存泄漏的几种原因：</p><p>1）类的构造函数和析构函数中new和delete没有配套</p><p>2）在释放对象数组时没有使用delete[]，使用了delete</p><p>3）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</p><p>4）没有正确的清楚嵌套的对象指针</p><p>避免方法：</p><ol><li>malloc/free要配套</li><li>使用智能指针；</li><li>将基类的析构函数设为虚函数；<h4 id="（39）-C-的智能指针有哪些"><a href="#（39）-C-的智能指针有哪些" class="headerlink" title="（39） C++的智能指针有哪些"></a>（39） C++的智能指针有哪些</h4>C++中的智能指针有auto_ptr,shared_ptr,weak_ptr和unique_ptr。智能指针其实是将指针进行了封装，可以像普通指针一样进行使用，同时可以自行进行释放，避免忘记释放指针指向的内存地址造成内存泄漏。</li></ol><ul><li><p>auto_ptr是较早版本的智能指针，在进行指针拷贝和赋值的时候，新指针直接接管旧指针的资源并且将旧指针指向空，但是这种方式在需要访问旧指针的时候，就会出现问题。</p></li><li><p>unique_ptr是auto_ptr的一个改良版，不能赋值也不能拷贝，保证一个对象同一时间只有一个智能指针。</p></li><li><p>shared_ptr可以使得一个对象可以有多个智能指针，当这个对象所有的智能指针被销毁时就会自动进行回收。（内部使用计数机制进行维护）</p></li><li><p>weak_ptr是为了协助shared_ptr而出现的。它不能访问对象，只能观测shared_ptr的引用计数，防止出现死锁。</p><h4 id="（40）-调试程序的方法"><a href="#（40）-调试程序的方法" class="headerlink" title="（40） 调试程序的方法"></a>（40） 调试程序的方法</h4></li><li><p>通过设置断点进行调试</p></li><li><p>打印log进行调试</p></li><li><p>打印中间结果进行调试</p><h4 id="（41）-遇到coredump要怎么调试"><a href="#（41）-遇到coredump要怎么调试" class="headerlink" title="（41） 遇到coredump要怎么调试"></a>（41） 遇到coredump要怎么调试</h4><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p></li><li><p>使用gdb命令对core文件进行调试</p></li></ul><p>以下例子在Linux上编写一段代码并导致segment fault 并产生core文件</p><pre><code>mkdir coredumpTestvim coredumpTest.cpp</code></pre><p>在编辑器内键入</p><pre><code>#include&lt;stdio.h&gt;int main(){    int i;    scanf(&quot;%d&quot;,i);//正确的应该是&amp;i,这里使用i会导致segment fault    printf(&quot;%d\n&quot;,i);    return 0;}</code></pre><p>编译</p><pre><code>g++ coredumpTest.cpp -g -o coredumpTest</code></pre><p>运行</p><pre><code>./coredumpTest</code></pre><p>使用gdb调试coredump</p><pre><code>gdb [可执行文件名] [core文件名]</code></pre><h4 id="（42）-inline关键字说一下-和宏定义有什么区别"><a href="#（42）-inline关键字说一下-和宏定义有什么区别" class="headerlink" title="（42） inline关键字说一下 和宏定义有什么区别"></a>（42） inline关键字说一下 和宏定义有什么区别</h4><p>inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。</p><p>1、内联函数在编译时展开，而宏在预编译时展开</p><p>2、在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</p><p>3、内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。</p><p>4、宏不是函数，而inline是函数</p><p>5、宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。</p><p>6、inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</p><p>7、宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</p><h4 id="（43）-模板的用法与适用场景-实现原理"><a href="#（43）-模板的用法与适用场景-实现原理" class="headerlink" title="（43） 模板的用法与适用场景 实现原理"></a>（43） 模板的用法与适用场景 实现原理</h4><p>用template \&lt;typename T&gt;关键字进行声明，接下来就可以进行模板函数和模板类的编写了</p><p>编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，这次编译只会进行一个语法检查，并不会生成具体的代码。在运行时对代码进行参数替换后再进行编译，生成具体的函数代码。</p><h4 id="（44）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"><a href="#（44）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？" class="headerlink" title="（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"></a>（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</h4><p>成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。如下：</p><pre><code>class A{int id;string name;FaceImage face;A(int&amp; inputID,string&amp; inputName,FaceImage&amp; inputFace):id(inputID),name(inputName),face(inputFace){} // 成员初始化列表};</code></pre><p>因为使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程，否则会调用一次传入参数的默认构造函数。所以使用成员初始化列表效率会高一些。<br><br>另外，有三种情况是必须使用成员初始化列表进行初始化的：</p><ul><li>常量成员的初始化，因为常量成员只能初始化不能赋值</li><li>引用类型</li><li>没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化</li></ul><p>详见<a href="https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html" target="_blank" rel="noopener">C++ 初始化列表</a></p><h4 id="（45）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"><a href="#（45）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）" class="headerlink" title="（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"></a>（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</h4><ul><li><p>自动类型推导auto：auto的自动类型推导用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作</p></li><li><p>nullptr<br>：nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，而nullptr是void*类型的</p></li><li><p>lambda表达式：它类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：<br><code>[函数对象参数](操作符重载函数参数)mutable或exception声明-&gt;返回值类型{函数体}</code></p></li><li><p>thread类和mutex类</p></li><li><p>新的智能指针 unique_ptr和shared_ptr</p></li></ul><ul><li>更多详见：<a href="https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279" target="_blank" rel="noopener">https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279</a><h4 id="（46）-C-的调用惯例（简单一点C-函数调用的压栈过程）"><a href="#（46）-C-的调用惯例（简单一点C-函数调用的压栈过程）" class="headerlink" title="（46） C++的调用惯例（简单一点C++函数调用的压栈过程）"></a>（46） C++的调用惯例（简单一点C++函数调用的压栈过程）</h4>函数的调用过程：</li></ul><p>1）从栈空间分配存储空间</p><p>2）从实参的存储空间复制值到形参栈空间</p><p>3）进行运算</p><p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p><p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。</p><p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。</p><h4 id="（47）-C-的四种强制转换"><a href="#（47）-C-的四种强制转换" class="headerlink" title="（47） C++的四种强制转换"></a>（47） C++的四种强制转换</h4><p>四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast</p><ul><li>1）static_cast ：<br>用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。<blockquote><p>特性与要点：</p><ol><li>它没有运行时类型检查，所以是有安全隐患的。</li><li>在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。</li><li>static_cast不能转换const，volatile等属性</li></ol></blockquote></li><li>2）dynamic_cast：<br>用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。<br>dynamic_cast能够提供运行时类型检查，只用于含有虚函数的类。<br>dynamic_cast如果不能转换返回NULL。</li><li>3）const_cast：<br>用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。</li><li>4）reinterpret_cast<br>几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等。但是不够安全。<h4 id="（48）string的底层实现"><a href="#（48）string的底层实现" class="headerlink" title="（48）string的底层实现"></a>（48）string的底层实现</h4>string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。</li></ul><p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</p><h4 id="（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的"><a href="#（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的" class="headerlink" title="（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的"></a>（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的</h4><p>预处理，编译，汇编，链接</p><ul><li>预处理： 对预处理命令进行替换等预处理操作</li><li>编译：代码优化和生成汇编代码</li><li>汇编：将汇编代码转化为机器语言</li><li>链接：将目标文件彼此链接起来<h4 id="（50）set，map和vector的插入复杂度"><a href="#（50）set，map和vector的插入复杂度" class="headerlink" title="（50）set，map和vector的插入复杂度"></a>（50）set，map和vector的插入复杂度</h4>set,map的插入复杂度就是红黑树的插入复杂度，是log(N)。</li></ul><p>unordered_set,unordered_map的插入复杂度是常数，最坏是O(N).</p><p>vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝</p><h4 id="（51）定义和声明的区别"><a href="#（51）定义和声明的区别" class="headerlink" title="（51）定义和声明的区别"></a>（51）定义和声明的区别</h4><ul><li><p>声明是告诉编译器变量的类型和名字，不会为变量分配空间</p></li><li><p>定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次</p><h4 id="（52）typdef和define区别"><a href="#（52）typdef和define区别" class="headerlink" title="（52）typdef和define区别"></a>（52）typdef和define区别</h4></li></ul><p>#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查</p><p>typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名</p><h4 id="（53）被free回收的内存是立即返还给操作系统吗？为什么"><a href="#（53）被free回收的内存是立即返还给操作系统吗？为什么" class="headerlink" title="（53）被free回收的内存是立即返还给操作系统吗？为什么"></a>（53）被free回收的内存是立即返还给操作系统吗？为什么</h4><p><a href="https://blog.csdn.net/YMY_mine/article/details/81180168" target="_blank" rel="noopener">https://blog.csdn.net/YMY_mine/article/details/81180168</a></p><p>不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p><h4 id="（54）引用作为函数参数以及返回值的好处"><a href="#（54）引用作为函数参数以及返回值的好处" class="headerlink" title="（54）引用作为函数参数以及返回值的好处"></a>（54）引用作为函数参数以及返回值的好处</h4><p>对比值传递，引用传参的好处：</p><p>1）在函数内部可以对此参数进行修改</p><p>2）提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）</p><p>如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</p><p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。</p><p>但是有以下的限制：</p><p>1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁</p><p>2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</p><p>3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。 </p><h4 id="（55）友元函数和友元类"><a href="#（55）友元函数和友元类" class="headerlink" title="（55）友元函数和友元类"></a>（55）友元函数和友元类</h4><p><a href="https://www.cnblogs.com/zhuguanhao/p/6286145.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuguanhao/p/6286145.html</a></p><p>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</p><p>1）友元函数</p><p>有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。</p><pre><code>#include &lt;iostream&gt;using namespace std;class A{public:    friend void set_show(int x, A &amp;a);      //该函数是友元函数的声明private:    int data;};void set_show(int x, A &amp;a)  //友元函数定义，为了访问类A中的成员{    a.data = x;    cout &lt;&lt; a.data &lt;&lt; endl;}int main(void){    class A a;    set_show(1, a);    return 0;}</code></pre><p>一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。</p><p>2）友元类</p><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。<br>但是另一个类里面也要相应的进行声明</p><pre><code> #include &lt;iostream&gt;using namespace std;class A{public:    friend class C;                         //这是友元类的声明private:    int data;};class C             //友元类定义，为了访问类A中的成员{public:    void set_show(int x, A &amp;a) { a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;}};int main(void){    class A a;    class C c;    c.set_show(1, a);    return 0;}</code></pre><p>使用友元类时注意： </p><p>(1) 友元关系不能被继承。 </p><p>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 </p><p>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p><h5 id="（56）-说一下volatile关键字的作用"><a href="#（56）-说一下volatile关键字的作用" class="headerlink" title="（56） 说一下volatile关键字的作用"></a>（56） 说一下volatile关键字的作用</h5><p>volatile的意思是“脆弱的”，表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而提供稳定的访问。每次读取volatile的变量时，系统总是会从内存中读取这个变量，并且将它的值立刻保存。</p><h4 id="（57）-STL中的sort-算法是用什么实现的，stable-sort-呢"><a href="#（57）-STL中的sort-算法是用什么实现的，stable-sort-呢" class="headerlink" title="（57） STL中的sort()算法是用什么实现的，stable_sort()呢"></a>（57） STL中的sort()算法是用什么实现的，stable_sort()呢</h4><p>STL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。</p><h4 id="（58）vector会迭代器失效吗？什么情况下会迭代器失效？"><a href="#（58）vector会迭代器失效吗？什么情况下会迭代器失效？" class="headerlink" title="（58）vector会迭代器失效吗？什么情况下会迭代器失效？"></a>（58）vector会迭代器失效吗？什么情况下会迭代器失效？</h4><p><a href="https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html" target="_blank" rel="noopener">https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html</a></p><ul><li>会</li><li>当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效</li><li>当vector在插入的时候，end迭代器肯定会失效</li><li>当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。</li></ul><h4 id="（58）为什么C-没有实现垃圾回收？"><a href="#（58）为什么C-没有实现垃圾回收？" class="headerlink" title="（58）为什么C++没有实现垃圾回收？"></a>（58）为什么C++没有实现垃圾回收？</h4><ul><li>首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。  </li><li>垃圾回收会使得C++不适合进行很多底层的操作。</li></ul><h1 id="2-计网相关"><a href="#2-计网相关" class="headerlink" title="2. 计网相关"></a>2. 计网相关</h1><h4 id="（1）-建立TCP服务器的各个系统调用"><a href="#（1）-建立TCP服务器的各个系统调用" class="headerlink" title="（1） 建立TCP服务器的各个系统调用"></a>（1） 建立TCP服务器的各个系统调用</h4><p>建立TCP服务器连接的过程中主要通过以下系统调用序列来获取某些函数，这些系统调用主要包括：socket（），bind（），listen（），accept（），send（）和recv（）。<br>详见：<a href="https://blog.csdn.net/qq_37964547/article/details/81429627" target="_blank" rel="noopener">建立TCP 服务器的系统调用</a></p><h4 id="（2）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"><a href="#（2）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？" class="headerlink" title="（2） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"></a>（2） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？</h4><pre><code>socket()    创建套接字   bind()      绑定本机端口    connect()   建立连接     （TCP三次握手在调用这个函数时进行）listen()    监听端口accept()    接受连接recv(), read(), recvfrom()  数据接收send(), write(), sendto()   数据发送close(), shutdown() 关闭套接字</code></pre><p>使用close()时，只有当套接字的引用计数为0的时候才会终止连接，而用shutdown()就可以直接关闭连接</p><p>详见：<a href="https://blog.csdn.net/junjun150013652/article/details/37994907" target="_blank" rel="noopener">网络编程Socket之TCP之close/shutdown详解</a></p><p>TCP连接与断开详解： <a href="https://www.cnblogs.com/felixzh/p/8359066.html" target="_blank" rel="noopener">https://www.cnblogs.com/felixzh/p/8359066.html</a></p><h4 id="（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP"><a href="#（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP" class="headerlink" title="（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP."></a>（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP.</h4><ul><li><p>RIP“路由信息协议(Route Information Protocol)”的简写，主要传递路由信息，通过每隔30秒广播一次路由表，维护相邻路由器的位置关系，同时根据收到的路由表信息使用动态规划的方式计算自己的路由表信息。RIP是一个距离矢量路由协议,最大跳数为16跳,16跳以及超过16跳的网络则认为目标网络不可达。</p></li><li><p>OSPF：详见：<a href="https://zhuanlan.zhihu.com/p/41341540" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41341540</a></p></li></ul><h4 id="（4）-UDP如何实现可靠传输"><a href="#（4）-UDP如何实现可靠传输" class="headerlink" title="（4） UDP如何实现可靠传输"></a>（4） UDP如何实现可靠传输</h4><p>因为UDP是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，只能从应用层实现。需要实现seq/ack机制，重传机制和窗口确认机制。</p><p>就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。</p><p>作者：姚冬<br>链接：<a href="https://www.zhihu.com/question/283995548/answer/661809748" target="_blank" rel="noopener">https://www.zhihu.com/question/283995548/answer/661809748</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h4 id="（5）-TCP和UDP的区别"><a href="#（5）-TCP和UDP的区别" class="headerlink" title="（5） TCP和UDP的区别"></a>（5） TCP和UDP的区别</h4><ul><li>TCP是面向连接的协议，提供的是可靠传输，在收发数据前需要通过三次握手建立连接，使用ACK对收发的数据进行正确性检验。而UDP是无连接的协议，不管对方有没有收到或者收到的数据是否正确。</li><li>TCP提供流量控制和拥塞控制，而UDP没有。</li><li>TCP对系统资源的要求高于UDP，所以速度也比UDP慢。</li><li>TCP数据包是没有边界的，会出现粘包的问题，UDP包是独立的，不会出现粘包问题。</li><li>所以在应用方面，如果强调数据的完整性和正确性用TCP，当要求性能和速度的时候，使用UDP更加合适。</li></ul><p>注：单凭TCP是不能保证完整性的，要是有黑客伪造TCP包，是无法识别的。</p><h4 id="（6）-TCP和UDP相关的协议与端口号"><a href="#（6）-TCP和UDP相关的协议与端口号" class="headerlink" title="（6） TCP和UDP相关的协议与端口号"></a>（6） TCP和UDP相关的协议与端口号</h4><p>TCP族的协议有HTTP，HTTPS，SMTP，TelNet，FTP等，UDP族的协议有DNS，DHCP等等。<br>详见：<a href="https://blog.csdn.net/qq_22080999/article/details/81105051" target="_blank" rel="noopener">https://blog.csdn.net/qq_22080999/article/details/81105051</a></p><h4 id="（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）"><a href="#（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）" class="headerlink" title="（7） TCP（UDP，IP）等首部的认识（http请求报文构成）"></a>（7） TCP（UDP，IP）等首部的认识（http请求报文构成）</h4><p>TCP的头部大致包括：源端口，目的端口，序号，确认号，偏移位，标志位，校验和等等</p><p>UDP的头部则包括：源端口，目的端口，长度，校验和。</p><p>IP数据包的头部包括：源IP地址，目的IP地址，协议，校验和，总长度等等</p><p>详见：<a href="https://blog.csdn.net/zhangliangzi/article/details/52554439" target="_blank" rel="noopener">https://blog.csdn.net/zhangliangzi/article/details/52554439</a></p><h4 id="（8）-网页解析的过程与实现方法"><a href="#（8）-网页解析的过程与实现方法" class="headerlink" title="（8） 网页解析的过程与实现方法"></a>（8） 网页解析的过程与实现方法</h4><p>这里仅展示浏览器解析服务器响应的过程，URL解析和交互的完整过程在(9)</p><ul><li>首先是html文档解析，浏览器会将html文档生成解析树，也就是DOM树，它由dom元素以及属性节点组成。</li><li>然后浏览器加载过程中如果遇到了外部css文件或者图片资源，还会另外发送请求来获取css文件和资源，这个请求通常是异步的，不会影响html文档的加载。</li><li>不过如果浏览器在加载时遇到了js文件，则会挂起渲染的线程，等待js文件加载解析完毕才恢复html的渲染线程。</li><li>然后是css解析，将css文件解析为样式表对象来渲染DOM树。<h4 id="（9）-在浏览器中输入URL后执行的全部过程（如www-baidu-com）"><a href="#（9）-在浏览器中输入URL后执行的全部过程（如www-baidu-com）" class="headerlink" title="（9）    在浏览器中输入URL后执行的全部过程（如www.baidu.com）"></a>（9）    在浏览器中输入URL后执行的全部过程（如<a href="http://www.baidu.com）" target="_blank" rel="noopener">www.baidu.com）</a></h4></li></ul><ol><li>首先是域名解析，客户端使用DNS协议将URL解析为对应的IP地址；</li><li>然后建立TCP连接，客户端与服务器通过三次握手建立TCP连接；</li><li>接着是http连接，客户端向服务器发送http连接请求； （http连接无需额外连接，直接通过已经建立的TCP连接发送）</li><li>服务器对客户端发来的http请求进行处理，并返回响应；</li><li>客户端接收到http响应，将结果渲染展示给用户。<h4 id="（10）-网络层分片的原因与具体实现"><a href="#（10）-网络层分片的原因与具体实现" class="headerlink" title="（10） 网络层分片的原因与具体实现"></a>（10） 网络层分片的原因与具体实现</h4>因为在链路层中帧的大小通常都有限制，比如在以太网中帧的最大大小（MTU）就是1500字节。如果IP数据包加上头部后大小超过1500字节，就需要分片。</li></ol><p>IP分片和完整IP报文差不多拥有相同的IP头，16位ID域对于每个分片都是一致的，这样才能在重新组装的时候识别出来自同一个IP报文的分片。在IP头里面，16位识别号唯一记录了一个IP包的ID，具有同一个ID的IP分片将会重新组装；而13位片偏移则记录了某IP片相对整个包的位置；而这两个表中间的3位标志则标志着该分片后面是否还有新的分片。这三个标志就组成了IP分片的所有信息(将在后面介绍)，接受方就可以利用这些信息对IP数据进行重新组织。<br>详见：<a href="https://blog.csdn.net/gettogetto/article/details/72851734" target="_blank" rel="noopener">https://blog.csdn.net/gettogetto/article/details/72851734</a></p><h4 id="（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"><a href="#（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）" class="headerlink" title="（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"></a>（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）</h4><ul><li>三次握手</li></ul><p>第一次握手：首先client给server发送连接请求报文，在这个报文中，包含了SYN=1，client_seq=任意值i，发送之后处于SYN-SENT状态，这是第一次握手</p><p>第二次握手：server端接收到了这个请求，并分配资源，同时给client返回一个ACK报文，这个报文中呢包含了这些字段，标志位SYN和ACK都为1，而小ack为i+1，此时位于SYN-RCVD状态，这是第二次握手</p><p>第三次握手：client收到server发来的ACK信息后呢，他会看到server发过来的小ack是i+1，这时他知道了server收到了消息，也给server回一个ACK报文，报文中同样包含了ACK=1这样的消息，同时呢，还包括了client_ack=k+1这样的字段，这样呢三次握手之后，连接就建立了，client进入established（已建立连接）状态<br><img src="fig/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手.png"></p><ul><li>四次挥手断开连接：</li></ul><p>TCP断开连接通常是由一方主动，一方被动的，这里我们假设client主动，server被动<br>第一次挥手：当client没有数据要发送给server了，他会给server发送一个FIN报文，告诉server：“我已经没有数据要发给你了，但是你要是还想给我发数据的话，你就接着发，但是你得告诉我你收到我的关闭信息了”，这是第一次挥手，挥手之后client进入FIN_WAIT_1的第一阶段</p><p>第二次挥手：当server收到client发来的FIN报文后，告诉client：“我收到你的FIN消息了，但是你等我发完的”此时给client返回一个ACK信息，并且呢ack=seq+1，这是第二次挥手，挥手之后呢server进入CLOSE_WAIT阶段，而client收到之后处于FIN_WAIT_2第二阶段</p><p>第三次挥手：当server发完所有数据时，他会给client发送一个FIN报文，告诉client说“我传完数据了，现在要关闭连接了”，然后呢server变成LAST_ACK状态，等着client最后的ACK信息，这是第三次挥手</p><p>第四次挥手：当client收到这个FIN报文时，他会对这个消息进行确认，即给server发ACK信息，但是它不相信网络，怕server收不到信息，它会进入TIME_WAIT状态，万一server没收到ACK消息它可以可以重传，而当server收到这个ACK信息后，就正式关闭了tcp连接，处于CLOSED状态，而client等待了2MSL这样长时间后还没等到消息，它知道server已经关闭连接了，于是乎他自己也断开了，这是第四次挥手，这样tcp连接就断开了<br><img src="fig/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="fig/四次挥手.png"></p><h4 id="（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态"><a href="#（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态" class="headerlink" title="（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态"></a>（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态</h4><p>见上</p><h4 id="（13）-为什么使用三次握手，两次握手可不可以？"><a href="#（13）-为什么使用三次握手，两次握手可不可以？" class="headerlink" title="（13） 为什么使用三次握手，两次握手可不可以？"></a>（13） 为什么使用三次握手，两次握手可不可以？</h4><p>如果使用两次握手的话，三次握手中的最后一次缺失，服务器不能确认客户端的接收能力。</p><p>举两个例子，第一种是黑客会伪造大量SYN请求发送给服务器，服务器立即确认并建立连接，分配资源，但是这一系列连接并不是真实存在的，这大大浪费了服务器的资源并且阻塞了正常用户的连接，这种也叫SYN洪泛攻击。第二种是服务器返回给客户端的ACK数据包可能会在传输的过程中丢失，而客户端没有收到该ACK数据包而拒绝接收服务器接下来发送的数据，于是服务器一直在发送，客户端一直在拒绝，形成死锁。</p><h4 id="（14）-TIME-WAIT的意义（为什么要等于2MSL）"><a href="#（14）-TIME-WAIT的意义（为什么要等于2MSL）" class="headerlink" title="（14） TIME_WAIT的意义（为什么要等于2MSL）"></a>（14） TIME_WAIT的意义（为什么要等于2MSL）</h4><p>TIME_WAIT是指四次挥手中客户端接收了服务端的FIN报文并发送ACK报文给服务器后，仍然需要等待2MSL时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。如果客户端发送的ACK发生丢失，服务器会再次发送FIN报文给客户端，所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><h4 id="（15）-超时重传机制（不太高频）"><a href="#（15）-超时重传机制（不太高频）" class="headerlink" title="（15） 超时重传机制（不太高频）"></a>（15） 超时重传机制（不太高频）</h4><h4 id="（16）-TCP怎么保证可靠性？"><a href="#（16）-TCP怎么保证可靠性？" class="headerlink" title="（16） TCP怎么保证可靠性？"></a>（16） TCP怎么保证可靠性？</h4><p><strong>（校序重流拥）</strong></p><ul><li><p>校验和<br>发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 </p></li><li><p>确认应答+序列号<br>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </p></li><li><p>超时重传<br>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </p></li><li><p>流量控制<br>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。<br>接收方有即时窗口（滑动窗口），随ACK报文发送</p></li><li><p>拥塞控制<br>当网络拥塞时，减少数据的发送。<br>发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小</p></li></ul><p>慢启动、拥塞避免、快速重传、快速恢复 </p><h4 id="（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"><a href="#（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？" class="headerlink" title="（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"></a>（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？</h4><p>所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用TCP报文段中的窗口大小字段来控制发送方的发送窗口不大于接收方发回的窗口大小就可以实施流量控制。</p><p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。</p><p>解决这个问题，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。</p><h4 id="（18）-tcp滑动窗口协议"><a href="#（18）-tcp滑动窗口协议" class="headerlink" title="（18） tcp滑动窗口协议"></a>（18） tcp滑动窗口协议</h4><p>详见 <a href="https://blog.csdn.net/wdscq1234/article/details/52444277" target="_blank" rel="noopener">TCP-IP详解：滑动窗口SlidingWindow</a>和<a href="https://www.cnblogs.com/alifpga/p/7675850.html" target="_blank" rel="noopener">TCP滑动窗口</a></p><p>TCP的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。</p><p>接收方会在每个ACK数据包中附带自己当前的接受窗口（滑动窗口）的大小，方便发送方进行控制。</p><h4 id="（19）-拥塞控制和流量控制的区别"><a href="#（19）-拥塞控制和流量控制的区别" class="headerlink" title="（19） 拥塞控制和流量控制的区别"></a>（19） 拥塞控制和流量控制的区别</h4><p>拥塞控制是防止过多的数据注入到网络中，导致网络发生拥塞；而流量控制是防止发送方一下子发送过多的数据到接收方，导致接收方缓存放不下。两种算法都是对发送方的行为进行控制的。</p><h4 id="（20）-TCP拥塞控制，算法名字？（极其重要）"><a href="#（20）-TCP拥塞控制，算法名字？（极其重要）" class="headerlink" title="（20） TCP拥塞控制，算法名字？（极其重要）"></a>（20） TCP拥塞控制，算法名字？（极其重要）</h4><p><img src="fig/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png" alt="拥塞控制"><br>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载，拥塞控制自然也是控制发送者的流量，拥塞控制有四种算法，<strong>慢启动、拥塞避免，快速重传和快速恢复</strong></p><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口和接受窗口的较小值。</p><p>（1）<strong>慢启动</strong>。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即1、2、4、8、16<br>*为了防止拥塞窗口cwnd增长过大引起网络拥塞，还要另外设置一个慢启动阈值ssthresh状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ cwnd &gt; ssthresh 时），停止使用慢开始算法而改用拥塞避免算法</p><p>（2）<strong>拥塞避免</strong>。拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。</p><p>（3）<strong>快速重传</strong>。当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。此时慢启动阈值ssth变为原来一半，拥塞窗口cwnd变为ssth+3，然后+1+1的发（每一轮rtt+1）</p><p>（4）<strong>快速恢复</strong>。当超过设定的时间没有收到某个报文段的ack时，表示网络拥塞，慢启动阈值ssth变为原来一半，拥塞窗口cwnd=1，进入慢启动阶段</p><h4 id="（21）-http协议与TCP的区别与联系"><a href="#（21）-http协议与TCP的区别与联系" class="headerlink" title="（21） http协议与TCP的区别与联系"></a>（21） http协议与TCP的区别与联系</h4><p>联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。</p><p>区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。<br>建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。</p><h4 id="（22）-http-1-0和http-1-1的区别"><a href="#（22）-http-1-0和http-1-1的区别" class="headerlink" title="（22） http/1.0和http/1.1的区别"></a>（22） http/1.0和http/1.1的区别</h4><p>HTTP 协议老的标准是 HTTP/1.0 ，目前最通用的标准是 HTTP/1.1 。<br>HTTP1.0 只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，但是最新的http/1.0加入了长连接，只需要在客户端给服务器发送的http报文头部加入Connection:keep-alive<br>HTTP 1.1 支持持久连接，默认进行持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p><h4 id="（23）-http的请求方法有哪些？get和post的区别。"><a href="#（23）-http的请求方法有哪些？get和post的区别。" class="headerlink" title="（23） http的请求方法有哪些？get和post的区别。"></a>（23） http的请求方法有哪些？get和post的区别。</h4><p>HTTP的请求方法包括GET，POST，PUT，DELETE四种基本方法。（四种方法中只有POST不是操作幂等性的）</p><p>get和post的区别：</p><ol><li>get方法不会修改服务器上的资源，它的查询是没有副作用的，而post有可能会修改服务器上的资源</li><li>get可以保存为书签，可以用缓存来优化，而post不可以</li><li>get把请求附在url上，而post把参数附在http包的包体中</li><li>浏览器和服务器一般对get方法所提交的url长度有限制，一般是1k或者2k，而对post方法所传输的参数大小限制为80k到4M不等</li><li>post可以传输二进制编码的信息，get的参数一般只支持ASCII<h4 id="（24）-http的状态码-403-201等等是什么意思"><a href="#（24）-http的状态码-403-201等等是什么意思" class="headerlink" title="（24） http的状态码 403 201等等是什么意思"></a>（24） http的状态码 403 201等等是什么意思</h4>详见 <a href="https://blog.csdn.net/u011630575/article/details/46636535" target="_blank" rel="noopener">HTTP状态码的含义</a></li></ol><p>常见的状态码有：</p><blockquote><ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li><li>400 - 请求无效 </li><li>403 - 禁止访问 </li></ul></blockquote><h4 id="（25）-http和https的区别，由http升级为https需要做哪些操作"><a href="#（25）-http和https的区别，由http升级为https需要做哪些操作" class="headerlink" title="（25） http和https的区别，由http升级为https需要做哪些操作"></a>（25） http和https的区别，由http升级为https需要做哪些操作</h4><p>http 是超文本传输协议，信息是明文传输， https 则是具有安全性的 ssl 加密传输协议<br>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 ，后者是 443<br>http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比http 协议安全。<br>https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用<br><a href="https://www.cnblogs.com/wqhwe/p/5407468.html" target="_blank" rel="noopener">https://www.cnblogs.com/wqhwe/p/5407468.html</a></p><h4 id="（26）-https的具体实现，怎么确保安全性"><a href="#（26）-https的具体实现，怎么确保安全性" class="headerlink" title="（26） https的具体实现，怎么确保安全性"></a>（26） https的具体实现，怎么确保安全性</h4><p><strong>SSL是传输层的协议</strong></p><p>https包括非对称加密和对称加密两个阶段，在客户端与服务器建立连接的时候使用非对称加密，连接建立以后使用的是对称加密。</p><ol><li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接</li><li>Web服务器收到客户端请求后，会将网站的公钥传送一份给客户端，私钥自己保存。</li><li>客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥，称为会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li><li>Web服务器利用自己的私钥解密出会话密钥。</li><li>Web服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。</li></ol><p>服务器第一次传给客户端的公钥其实是CA对网站信息进行加密的数字证书</p><p>客户端的对称加密密钥其实是三个随机数的哈希（1. 客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3. 客户端收到返回时的随机数）</p><h4 id="（27）-TCP三次握手时的第一次的seq序号是怎样产生的"><a href="#（27）-TCP三次握手时的第一次的seq序号是怎样产生的" class="headerlink" title="（27） TCP三次握手时的第一次的seq序号是怎样产生的"></a>（27） TCP三次握手时的第一次的seq序号是怎样产生的</h4><p>第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。</p><p>seq = C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）。</p><h4 id="（28）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"><a href="#（28）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？" class="headerlink" title="（28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"></a>（28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？</h4><p>65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16=65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。</p><p>而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。</p><h4 id="（29）-对称密码和非对称密码体系"><a href="#（29）-对称密码和非对称密码体系" class="headerlink" title="（29） 对称密码和非对称密码体系"></a>（29） 对称密码和非对称密码体系</h4><p><a href="https://blog.csdn.net/qq_29689487/article/details/81634057" target="_blank" rel="noopener">https://blog.csdn.net/qq_29689487/article/details/81634057</a></p><ul><li>对称加密：加密和解密使用的密钥是同一个<ul><li>优点：计算量小，算法速度快，加密效率高  缺点：密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲</li><li>常用算法：DES，3DES，IDEA，CR4，CR5，CR6，AES</li></ul></li><li>非对称加密：需要公钥和私钥，公钥用来加密，私钥用来解密<ul><li>优点：安全，不怕泄漏  缺点：速度慢</li><li>常用算法：RSA，ECC，DSA<h4 id="（30）-数字证书的了解（高频）"><a href="#（30）-数字证书的了解（高频）" class="headerlink" title="（30） 数字证书的了解（高频）"></a>（30） 数字证书的了解（高频）</h4><img src="fig/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.jpg" alt="fig/数字证书.jpg"></li></ul></li></ul><p>权威CA使用私钥将网站A的信息和消息摘要（签名S）进行加密打包形成数字证书。公钥给客户端。</p><p>网站A将自己的信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密，得到签名S，与手动将网站的信息进行消息摘要得到的结果S*进行对比，如果签名一致就证明网站A可以信任。</p><h4 id="（31）-服务器出现大量close-wait的连接的原因以及解决方法"><a href="#（31）-服务器出现大量close-wait的连接的原因以及解决方法" class="headerlink" title="（31） 服务器出现大量close_wait的连接的原因以及解决方法"></a>（31） 服务器出现大量close_wait的连接的原因以及解决方法</h4><p>close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：</p><ul><li>服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li><li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</li></ul><p>处理方法：</p><ul><li><p>停止应用程序</p></li><li><p>修改程序里的bug</p><h4 id="（32）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"><a href="#（32）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）" class="headerlink" title="（32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"></a>（32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）</h4></li><li><p>消息摘要算法有MD家族（MD2，MD4，MD5），SHA家族（SHA-1,SHA-256）和CRC家族（CRC8,CRC16,CRC32）等等</p></li><li><p>MD5算法介绍：<br>MD5以512位分组来处理输入的信息，且每一分组又被划分为若干个小分组（16个32位子分组），经过一些列的处理后，算法输出由四个散列值（32位分组组成的128位散列值。）</p></li></ul><ol><li>MD5首先将输入的信息分成若干个512字节长度的分组，如果不够就填充1和若干个0。</li><li>对每个512字节的分组进行循环运算。使用四个幻数对第一个分组的数据进行四轮变换，得到四个变量。</li><li>接下来对其中三个使用线性函数进行计算，与剩下一个相加，并赋值给其中某个变量，得到新的四个变量，重复16次这个过程，得到的四个变量作为幻数，与下一个分组进行相似的计算。</li><li>遍历所有分组后得到的四个变量即为结果。</li></ol><p>详见：<a href="https://blog.csdn.net/weixin_39640298/article/details/84555814" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39640298/article/details/84555814</a></p><ul><li><p>为什么不可逆：因为MD5在进行消息摘要的过程中，数据与原始数据相比发生了丢失，所以不能由结果进行恢复。</p></li><li><p>加强安全性：加盐（加随机数）</p><h4 id="（33）-单条记录高并发访问的优化"><a href="#（33）-单条记录高并发访问的优化" class="headerlink" title="（33） 单条记录高并发访问的优化"></a>（33） 单条记录高并发访问的优化</h4><p>服务器端：</p></li><li><p>使用缓存，如redis等</p></li><li><p>使用分布式架构进行处理</p></li><li><p>将静态页面和静态资源存储在静态资源服务器，需要处理的数据使用服务器进行计算后返回</p></li><li><p>将静态资源尽可能在客户端进行缓存</p></li><li><p>采用ngnix进行负载均衡 （nginx读作恩静埃克斯 = Engine X）</p></li></ul><p>数据库端：</p><ul><li>数据库采用主从赋值，读写分离措施</li><li>建立适当的索引</li><li>分库分表<h4 id="（34）-介绍一下ping的过程，分别用到了哪些协议"><a href="#（34）-介绍一下ping的过程，分别用到了哪些协议" class="headerlink" title="（34） 介绍一下ping的过程，分别用到了哪些协议"></a>（34） 介绍一下ping的过程，分别用到了哪些协议</h4>详见：<a href="https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html" target="_blank" rel="noopener">Ping原理与ICMP协议</a></li></ul><p>ping是使用ICMP协议来进行工作的。 ICMP:网络控制报文协议</p><ul><li>首先，ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。</li><li>然后IP协议就会构建一个IP数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。</li><li>然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。</li></ul><p>目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把其中的信息提取出来交给IP协议，IP协议就会将其中的信息提取出来交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。</p><h4 id="（35）-TCP-IP的粘包与避免介绍一下"><a href="#（35）-TCP-IP的粘包与避免介绍一下" class="headerlink" title="（35） TCP/IP的粘包与避免介绍一下"></a>（35） TCP/IP的粘包与避免介绍一下</h4><p>因为TCP为了减少额外开销，采取的是流式传输，所以接收端在一次接收的时候有可能一次接收多个包。而TCP粘包就是发送方的若干个数据包到达接收方的时候粘成了一个包。多个包首尾相接，无法区分。</p><p>导致TCP粘包的原因有三方面：</p><ul><li>发送端等待缓冲区满才进行发送，造成粘包</li><li>接收方来不及接收缓冲区内的数据，造成粘包</li><li>由于TCP协议在发送较小的数据包的时候，会将几个包合成一个包后发送</li></ul><p>避免粘包的措施：</p><ul><li>通过编程，强制使TCP发生数据传送，不必等到缓冲区满</li><li>优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等</li><li>设置固定长度的报文或者设置报文头部指示报文的长度。</li></ul><h4 id="（36）-说一下TCP的封包和拆包"><a href="#（36）-说一下TCP的封包和拆包" class="headerlink" title="（36） 说一下TCP的封包和拆包"></a>（36） 说一下TCP的封包和拆包</h4><p>因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p><ul><li>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</li><li>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。<h4 id="（37）-一个ip配置多个域名，靠什么识别？"><a href="#（37）-一个ip配置多个域名，靠什么识别？" class="headerlink" title="（37） 一个ip配置多个域名，靠什么识别？"></a>（37） 一个ip配置多个域名，靠什么识别？</h4></li><li>靠host主机名区分</li><li>靠端口号区分<h4 id="（38）-服务器攻击（DDos攻击）"><a href="#（38）-服务器攻击（DDos攻击）" class="headerlink" title="（38） 服务器攻击（DDos攻击）"></a>（38） 服务器攻击（DDos攻击）</h4><h4 id="（39）DNS的工作过程和原理"><a href="#（39）DNS的工作过程和原理" class="headerlink" title="（39）DNS的工作过程和原理"></a>（39）DNS的工作过程和原理</h4><img src="fig/DNS%E6%9F%A5%E8%AF%A2%E5%9B%BE%E8%A7%A3.png" alt><br>DNS解析有两种方式：递归查询和迭代查询</li><li>递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。</li><li>迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果<h4 id="（41）OSA七层协议和五层协议，分别有哪些"><a href="#（41）OSA七层协议和五层协议，分别有哪些" class="headerlink" title="（41）OSA七层协议和五层协议，分别有哪些"></a>（41）OSA七层协议和五层协议，分别有哪些</h4>OSI七层协议模型主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</li></ul><p>五层体系结构包括：应用层、传输层、网络层、数据链路层和物理层。</p><p><img src="fig/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B1%82.png" alt="(fig/网络协议层.png"></p><h4 id="（42）IP寻址和MAC寻址有什么不同，怎么实现的"><a href="#（42）IP寻址和MAC寻址有什么不同，怎么实现的" class="headerlink" title="（42）IP寻址和MAC寻址有什么不同，怎么实现的"></a>（42）IP寻址和MAC寻址有什么不同，怎么实现的</h4><p>通过MAC地址寻找主机是MAC地址寻址，通过IP地址寻找主机叫IP地址寻址。它们适用于不同的协议层，IP寻址是网络层，Mac寻址是数据链路层。</p><p><a href="http://c.biancheng.net/view/6388.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6388.html</a></p><p><a href="https://blog.csdn.net/wxy_nick/article/details/9190693" target="_blank" rel="noopener">https://blog.csdn.net/wxy_nick/article/details/9190693</a></p><p>IP寻址的过程（ARP协议）：主机A想通过IP地址寻找到目标主机，首先分析IP地址确定目标主机与自己是否为同一网段。如果是则查看ARP缓存，或者使用ARP协议发送广播。如果不是，则寻找网关发送ARP数据包</p><h1 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3. 数据库"></a>3. 数据库</h1><h4 id="（1）-关系型和非关系型数据库的区别（低频）"><a href="#（1）-关系型和非关系型数据库的区别（低频）" class="headerlink" title="（1） 关系型和非关系型数据库的区别（低频）"></a>（1） 关系型和非关系型数据库的区别（低频）</h4><ul><li>关系型数据库的优点<ol><li>容易理解。因为它采用了关系模型来组织数据。</li><li>可以保持数据的一致性。</li><li>数据更新的开销比较小。</li><li>支持复杂查询（带where子句的查询）</li></ol></li><li>非关系型数据库的优点<ol><li>不需要经过sql层的解析，读写效率高。</li><li>基于键值对，数据的扩展性很好。</li><li>可以支持多种类型数据的存储，如图片，文档等等。<h4 id="（2）-什么是非关系型数据库（低频）"><a href="#（2）-什么是非关系型数据库（低频）" class="headerlink" title="（2） 什么是非关系型数据库（低频）"></a>（2） 什么是非关系型数据库（低频）</h4>非关系型数据库也叫nosql，采用键值对的形式进行存储。它的读写性能很高，易于扩展。例如Redis,Mongodb,hbase等等。</li></ol></li></ul><p>适合使用非关系型数据库的场景：</p><ul><li>日志系统</li><li>地理位置存储</li><li>数据量巨大</li><li>高可用<h4 id="（3）-说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#（3）-说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="（3） 说一下 MySQL 执行一条查询语句的内部执行过程？"></a>（3） 说一下 MySQL 执行一条查询语句的内部执行过程？</h4></li><li>连接器：客户端先通过连接器连接到 MySQL 服务器。</li><li>缓存：连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</li><li>分析器：分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</li><li>优化器：优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</li><li>执行器：优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。<h4 id="（4）-数据库的索引类型"><a href="#（4）-数据库的索引类型" class="headerlink" title="（4） 数据库的索引类型"></a>（4） 数据库的索引类型</h4>数据库的索引类型分为逻辑分类和物理分类<br><br>逻辑分类：</li><li>主键索引 当关系表中定义主键时会自动创建主键索引。每张表中的主键索引只能有一个，要求主键中的每个值都唯一，即不可重复，也不能有空值。</li><li>唯一索引 数据列不能有重复，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有一列。如身份证，卡号等。</li><li>普通索引 一张表可以有多个普通索引，可以重复可以为空值</li><li>全文索引 可以加快模糊查询，不常用</li></ul><p>物理分类：</p><ul><li>聚集索引（聚簇索引） 数据在物理存储中的顺序跟索引中数据的逻辑顺序相同，比如以ID建立聚集索引，数据库中id从小到大排列，那么物理存储中该数据的内存地址值也按照从小到大存储。一般是表中的主键索引，如果没有主键索引就会以第一个非空的唯一索引作为聚集索引。一张表只能有一个聚集索引。</li><li>非聚集索引 数据在物理存储中的顺序跟索引中数据的逻辑顺序不同。非聚集索引因为无法定位数据所在的行，所以需要扫描两遍索引树。第一遍扫描非聚集索引的索引树，确定该数据的主键ID，然后到主键索引（聚集索引）中寻找相应的数据。<h4 id="（5）-说一下事务是怎么实现的"><a href="#（5）-说一下事务是怎么实现的" class="headerlink" title="（5） 说一下事务是怎么实现的"></a>（5） 说一下事务是怎么实现的</h4><a href="https://blog.csdn.net/u013256816/article/details/103966510" target="_blank" rel="noopener">https://blog.csdn.net/u013256816/article/details/103966510</a></li></ul><p><a href="https://www.cnblogs.com/takumicx/p/9998844.html" target="_blank" rel="noopener">https://www.cnblogs.com/takumicx/p/9998844.html</a></p><p>事务就是一组逻辑操作的集合。实现事务就是要保证可靠性和并发隔离，或者说，能够满足ACID特性的机制。而这些主要是靠日志恢复和并发控制实现的。</p><ul><li>日志恢复：数据库里有两个日志，一个是redo log，一个是undo log。redo log记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的<strong>持久性</strong>。undo log记录的是事务修改之前的数据信息，用来回滚数据，保证事务的<strong>原子性</strong>。</li><li>并发控制：并发控制主要靠读写锁和MVCC（多版本并发控制）来实现。读写锁包括共享锁和排他锁，保证事务的<strong>隔离性</strong>。MVCC通过为数据添加时间戳来实现。</li></ul><h4 id="（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"><a href="#（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？" class="headerlink" title="（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"></a>（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？</h4><p>MySQL建立索引有两种方式：用alter table或者create index。</p><pre><code>alter table table_name add primary key(column_list) #添加一个主键索引alter table table_name add index (column_list)      #添加一个普通索引alter table table_name add unique (column_list)     #添加一个唯一索引</code></pre><pre><code>create index index_name on table_name (column_list)   #创建一个普通索引create unique index_name on table_name (column_list)  #创建一个唯一索引</code></pre><p>Mysql删除索引同样也有两种方式：alter table 和 drop index</p><pre><code>alter table table_name drop index index_name    #删除一个普通索引alter table table_name drop primary key         #删除一个主键索引</code></pre><pre><code>drop index index_name on table table_name</code></pre><h4 id="（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"><a href="#（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）" class="headerlink" title="（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"></a>（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）</h4><p><a href="https://www.cnblogs.com/wezheng/p/8399305.html" target="_blank" rel="noopener">https://www.cnblogs.com/wezheng/p/8399305.html</a></p><ul><li>经常搜索的列上建索引</li><li>作为主键的列上要建索引</li><li>经常需要连接（where子句）的列上</li><li>经常需要排序的列</li><li>经常需要范围查找的列</li></ul><p>哪些列不适合建索引？</p><ul><li>很少查询的列</li><li>更新很频繁的列</li><li>数据值的取值比较少的列（比如性别）<h4 id="（8）-索引的底层实现（重点）"><a href="#（8）-索引的底层实现（重点）" class="headerlink" title="（8） 索引的底层实现（重点）"></a>（8） 索引的底层实现（重点）</h4>数据库的索引是使用B+树来实现的。</li></ul><p>（为什么要用B+树，为什么不用红黑树和B树）<br><br>B+树是一种特殊的平衡多路树，是B树的优化改进版本，它把所有的数据都存放在叶节点上，中间节点保存的是索引。这样一来相对于B树来说，减少了数据对中间节点的空间占用，使得中间节点可以存放更多的指针，使得树变得更矮，深度更小，从而减少查询的磁盘IO次数，提高查询效率。另一个是由于叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。</p><p>而红黑树是二叉的，它的深度相对B+树来说更大，更大的深度意味着查找次数更多，更频繁的磁盘IO，所以红黑树更适合在内存中进行查找。</p><h4 id="（9）-B树和B-树的区别（重点）"><a href="#（9）-B树和B-树的区别（重点）" class="headerlink" title="（9） B树和B+树的区别（重点）"></a>（9） B树和B+树的区别（重点）</h4><p><img src="./fig/Bptree.png" alt="./fig/Bptree.png"></p><p>这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。</p><ol><li>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。</li><li>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。</li><li>分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。</li><li>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</li></ol><p>B+树优点：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。</p><h4 id="（10）-索引最左前缀-最左匹配"><a href="#（10）-索引最左前缀-最左匹配" class="headerlink" title="（10） 索引最左前缀/最左匹配"></a>（10） 索引最左前缀/最左匹配</h4><p>假如我们对a b c三个字段建立了联合索引，在联合索引中，从最左边的字段开始，任何连续的索引都能匹配上，当遇到范围查询的时候停止。比如对于联合索引index(a,b,c),能匹配a,ab,abc三组索引。并且对查询时字段的顺序没有限制，也就是a,b,c; b,a,c; c,a,b; c,b,a都可以匹配。</p><h4 id="（11）-Mysql的优化（高频，索引优化，性能优化）"><a href="#（11）-Mysql的优化（高频，索引优化，性能优化）" class="headerlink" title="（11） Mysql的优化（高频，索引优化，性能优化）"></a>（11） Mysql的优化（高频，索引优化，性能优化）</h4><p>高频访问：</p><ul><li>分表分库：将数据库表进行水平拆分，减少表的长度</li><li>增加缓存： 在web和DB之间加上一层缓存层</li><li>增加数据库的索引：在合适的字段加上索引，解决高频访问的问题</li></ul><p>并发优化：</p><ul><li>主从读写分离：只在主服务器上写，从服务器上读</li><li>负载均衡集群：通过集群或者分布式的方式解决并发压力<h4 id="（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别"><a href="#（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别" class="headerlink" title="（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别"></a>（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别</h4></li><li>InnoDB ： InnoDB是mysql的默认引擎，支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表  行级锁</li><li>MyISAM ： 插入和查询速度比较高，支持大文件，但是不支持事务，适合在web和数据仓库场景下使用  表级锁</li><li>MEMORY ： memory将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景</li><li>CSV</li><li>blackhole<h4 id="（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"><a href="#（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）" class="headerlink" title="（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"></a>（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）</h4>数据库事务是指逻辑上对数据的一种操作，这个事务要么全部成功，要么全部失败。</li></ul><p><strong>A: atom 原子性</strong><br><br>数据库事务的原子性是指：事务是一个不可分割的工作单位，这组操作要么全部发生，要么全部不发生。</p><p><strong>C: consistency 一致性</strong><br><br>数据库事务的一致性是指：在事务开始以前，数据库中的数据有一个一致的状态。在事务完成后，数据库中的事务也应该保持这种一致性。事务应该将数据从一个一致性状态转移到另一个一致性状态。<br>比如在银行转账操作后两个账户的总额应当不变。</p><p><strong>I: isolation 隔离性</strong><br><br>数据库事务的隔离性要求数据库中的事务不会受另一个并发执行的事务的影响，对于数据库中同时执行的每个事务来说，其他事务要么还没开始执行，要么已经执行结束，它都感觉不到还有别的事务正在执行。</p><p><strong>D：durability 持久性</strong><br><br>数据库事务的持久性要求事务对数据库的改变是永久的，哪怕数据库发生损坏都不会影响到已发生的事务。<br>如果事务没有完成，数据库因故断电了，那么重启后也应该是没有执行事务的状态，如果事务已经完成后数据库断电了，那么重启后就应该是事务执行完成后的状态。</p><h4 id="（14）什么是脏读，不可重复读和幻读？"><a href="#（14）什么是脏读，不可重复读和幻读？" class="headerlink" title="（14）什么是脏读，不可重复读和幻读？"></a>（14）什么是脏读，不可重复读和幻读？</h4><p>详见<a href="https://blog.csdn.net/fuzhongmin05/article/details/91126936" target="_blank" rel="noopener">数据库的事务隔离级别总结</a></p><ul><li>脏读：脏读是指一个事务在处理过程中读取了另一个还没提交的事务的数据。<blockquote><p>比如A向B转账100，A的账户减少了100，而B的账户还没来得及修改，此时一个并发的事务访问到了B的账户，就是脏读</p></blockquote></li><li>不可重复读：不可重复读是对于数据库中的某一个字段，一个事务多次查询却返回了不同的值，这是由于在查询的间隔中，该字段被另一个事务修改并提交了。<blockquote><p>比如A第一次查询自己的账户有1000元，此时另一个事务给A的账户增加了1000元，所以A再次读取他的账户得到了2000的结果，跟第一次读取的不一样。<br>不可重复读与脏读的不同之处在于，脏读是读取了另一个事务没有提交的脏数据，不可重复读是读取了已经提交的数据，实际上并不是一个异常现象。</p></blockquote></li><li>幻读：事务多次读取同一个范围的时候，查询结果的记录数不一样，这是由于在查询的间隔中，另一个事务新增或删除了数据。<blockquote><p>比如A公司一共有100个人，第一次查询总人数得到100条记录，此时另一个事务新增了一个人，所以下一次查询得到101条记录。<br>不可重复度和幻读的不同之处在于，幻读是多次读取的结果行数不同，不可重复度是读取结果的值不同。</p></blockquote></li></ul><p>避免不可重复读需要锁行，避免幻读则需要锁表。</p><p>脏读，不可重复读和幻读都是数据库的读一致性问题，是在并行的过程中出现的问题，必须采用一定的隔离级别解决。<br>详见<a href="https://www.cnblogs.com/Hakuna-Matata/p/7772794.html" target="_blank" rel="noopener">脏读、不可重复读和幻读的区别</a></p><h4 id="（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"><a href="#（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）" class="headerlink" title="（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"></a>（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）</h4><p>详见<a href="https://blog.csdn.net/fuzhongmin05/article/details/91126936" target="_blank" rel="noopener">数据库的事务隔离级别总结</a>和<a href="https://blog.csdn.net/fg2006/article/details/6937413" target="_blank" rel="noopener">数据库隔离级别</a></p><p>为了保证数据库事务一致性，解决脏读，不可重复读和幻读的问题，数据库的隔离级别一共有四种隔离级别：</p><ul><li>读未提交 Read Uncommitted: 最低级别的隔离，不能解决以上问题</li><li>读已提交 Read committed:   可以避免脏读的发生 </li><li>可重复读 Reapeatable read:  确保事务可以多次从一个字段中读取相同的值，在该事务执行期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读。 通过锁行来实现 </li><li>串行化 Serializaion  最严格的事务隔离机制，要求所有事务被串行执行，可以避免以上所有问题。 通过锁表来实现</li></ul><p>Oracle的默认隔离级别是<strong>读已提交</strong>，实现了四种隔离级别中的读已提交和串行化隔离级别</p><p>MySQL的默认隔离级别是<strong>可重复读</strong>，并且实现了所有四种隔离级别</p><h4 id="（16）-数据库连接池的作用"><a href="#（16）-数据库连接池的作用" class="headerlink" title="（16） 数据库连接池的作用"></a>（16） 数据库连接池的作用</h4><h4 id="（17）-Mysql的表空间方式，各自特点"><a href="#（17）-Mysql的表空间方式，各自特点" class="headerlink" title="（17） Mysql的表空间方式，各自特点"></a>（17） Mysql的表空间方式，各自特点</h4><ul><li><p>共享表空间：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 </p></li><li><p>独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 优点：当表被删除时这部分空间可以被回收；可以更快的恢复和备份单个表；将单个表复制到另一个实例会很方便； 缺点：mysqld会维持很多文件句柄，表太多会影响性能。如果很多表都增长会导致碎片问题</p><h4 id="（18）-分布式事务"><a href="#（18）-分布式事务" class="headerlink" title="（18） 分布式事务"></a>（18） 分布式事务</h4><h4 id="（19）-数据库的范式"><a href="#（19）-数据库的范式" class="headerlink" title="（19） 数据库的范式"></a>（19） 数据库的范式</h4><p><a href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html" target="_blank" rel="noopener">https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</a></p></li><li><p><strong>第一范式(确保每列保持原子性)</strong><br><br>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p></li></ul><blockquote><p>比如 学生 选课（包括很多课程） 就不符合第一范式</p><ul><li><strong>第二范式(确保表中的每列都和主键相关)</strong><br><br>在满足第一范式的前提下，（主要针对联合主键而言）第二范式需要确保数据库表中的每一列都和主键的所有成员直接相关，由整个主键才能唯一确定，而不能只与主键的某一部分相关或者不相关。 </li></ul></blockquote><blockquote><p>比如一张学生信息表，由主键（学号）可以唯一确定一个学生的姓名，班级，年龄等信息。但是主键 （学号，班级） 与列 姓名，班主任，教室 就不符合第二范式，因为班主任跟部分主键（班级）是依赖关系</p><ul><li><strong>第三范式(确保非主键的列没有传递依赖)</strong><br><br>在满足第二范式的前提下，第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。非主键的列不能确定其他列，列与列之间不能出现传递依赖。</li></ul></blockquote><blockquote><p>比如一张学生信息表，主键是（学号）列包括 姓名，班级，班主任 就不符合第三范式，因为非主键的列中 班主任 依赖于 班级</p><ul><li><strong>BCNF范式（确保主键之间没有传递依赖）</strong><br><br>主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。</li></ul></blockquote><h4 id="（20）-数据的锁的种类，加锁的方式"><a href="#（20）-数据的锁的种类，加锁的方式" class="headerlink" title="（20） 数据的锁的种类，加锁的方式"></a>（20） 数据的锁的种类，加锁的方式</h4><p>以MYSQL为例，</p><ul><li><p>按照类型来分有乐观锁和悲观锁</p></li><li><p>根据粒度来分有行级锁，页级锁，表级锁（粒度一个比一个大） （仅BDB，Berkeley Database支持页级锁）</p></li><li><p>根据作用来分有共享锁（读锁）和排他锁（写锁）。</p><h4 id="（21）-什么是共享锁和排他锁"><a href="#（21）-什么是共享锁和排他锁" class="headerlink" title="（21） 什么是共享锁和排他锁"></a>（21） 什么是共享锁和排他锁</h4></li><li><p>共享锁是读操作的时候创建的锁，一个事务对数据加上共享锁之后，其他事务只能对数据再加共享锁，不能进行写操作直到释放所有共享锁。</p></li><li><p>排他锁是写操作时创建的锁，事务对数据加上排他锁之后其他任何事务都不能对数据加任何的锁（即其他事务不能再访问该数据）</p><p><a href="https://blog.csdn.net/qq_42743933/article/details/81236658" target="_blank" rel="noopener">https://blog.csdn.net/qq_42743933/article/details/81236658</a></p><h4 id="（22）-分库分表的理解和简介"><a href="#（22）-分库分表的理解和简介" class="headerlink" title="（22） 分库分表的理解和简介"></a>（22） 分库分表的理解和简介</h4><h4 id="（23）"><a href="#（23）" class="headerlink" title="（23）"></a>（23）</h4><h4 id="（24）数据库高并发的解决方案"><a href="#（24）数据库高并发的解决方案" class="headerlink" title="（24）数据库高并发的解决方案"></a>（24）数据库高并发的解决方案</h4></li></ul><ol><li>在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li><li>增加数据库索引。提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li><li>主从读写分离，让主服务器负责写，从服务器负责读。</li><li>将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。</li><li>使用分布式架构，分散计算压力。<h4 id="（25）乐观锁与悲观锁解释一下"><a href="#（25）乐观锁与悲观锁解释一下" class="headerlink" title="（25）乐观锁与悲观锁解释一下"></a>（25）乐观锁与悲观锁解释一下</h4>一般的数据库都会支持并发操作，在并发操作中为了避免数据冲突，所以需要对数据上锁，乐观锁和悲观锁就是两种不同的上锁方式。</li></ol><p>悲观锁假设数据在并发操作中一定会发生冲突，所以在数据开始读取的时候就把数据锁住。而乐观锁则假设数据一般情况下不会发生冲突，所以在数据提交更新的时候，才会检测数据是否有冲突。</p><h4 id="（26）乐观锁与悲观锁是怎么实现的"><a href="#（26）乐观锁与悲观锁是怎么实现的" class="headerlink" title="（26）乐观锁与悲观锁是怎么实现的"></a>（26）乐观锁与悲观锁是怎么实现的</h4><p>悲观锁有行级锁和页级锁两种形式。行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据，而页级锁则对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务并行访问。</p><p>悲观锁要求在整个过程中一直与数据库有一条连接，因为上一个事务完成后才能让下一个事务执行，这个过程是串行的。</p><p>乐观锁有三种常用的实现形式：</p><ul><li>一种是在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一摸一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。</li><li>一种是使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。</li><li>最后一种采用时间戳对数据最后修改的时间进行标记。与上一种类似。</li></ul><h4 id="（27）对数据库目前最新技术有什么了解吗"><a href="#（27）对数据库目前最新技术有什么了解吗" class="headerlink" title="（27）对数据库目前最新技术有什么了解吗"></a>（27）对数据库目前最新技术有什么了解吗</h4><h1 id="4-Linux"><a href="#4-Linux" class="headerlink" title="4. Linux"></a>4. Linux</h1><h4 id="（1）-Linux的I-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"><a href="#（1）-Linux的I-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）" class="headerlink" title="（1） Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"></a>（1） Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）</h4><p><a href="https://blog.csdn.net/sqsltr/article/details/92762279" target="_blank" rel="noopener">https://blog.csdn.net/sqsltr/article/details/92762279</a></p><p><a href="https://www.cnblogs.com/euphie/p/6376508.html" target="_blank" rel="noopener">https://www.cnblogs.com/euphie/p/6376508.html</a></p><p>（IO过程包括两个阶段：（1）内核从IO设备读写数据和（2）进程从内核复制数据）</p><ul><li>阻塞：调用IO操作的时候，如果缓冲区空或者满了，调用的进程或者线程就会处于阻塞状态直到IO可用并完成数据拷贝。</li><li>非阻塞：调用IO操作的时候，内核会马上返回结果，如果IO不可用，会返回错误，这种方式下进程需要不断轮询直到IO可用为止，但是当进程从内核拷贝数据时是阻塞的。</li><li>IO多路复用就是同时监听多个描述符，一旦某个描述符IO就绪（读就绪或者写就绪），就能够通知进程进行相应的IO操作，否则就将进程阻塞在select或者epoll语句上。</li></ul><ul><li>同步IO：同步IO模型包括阻塞IO，非阻塞IO和IO多路复用。特点就是当进程从内核复制数据的时候都是阻塞的。</li><li>异步IO：在检测IO是否可用和进程拷贝数据的两个阶段都是不阻塞的，进程可以做其他事情，当IO完成后内核会给进程发送一个信号。<h4 id="（2）-文件系统的理解（EXT4，XFS，BTRFS）"><a href="#（2）-文件系统的理解（EXT4，XFS，BTRFS）" class="headerlink" title="（2） 文件系统的理解（EXT4，XFS，BTRFS）"></a>（2） 文件系统的理解（EXT4，XFS，BTRFS）</h4><h4 id="（3）-EPOLL的介绍和了解"><a href="#（3）-EPOLL的介绍和了解" class="headerlink" title="（3） EPOLL的介绍和了解"></a>（3） EPOLL的介绍和了解</h4><a href="https://zhuanlan.zhihu.com/p/56486633" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/56486633</a> </li></ul><p><a href="https://www.jianshu.com/p/397449cadc9a" target="_blank" rel="noopener">https://www.jianshu.com/p/397449cadc9a</a></p><p><a href="https://blog.csdn.net/davidsguo008/article/details/73556811" target="_blank" rel="noopener">https://blog.csdn.net/davidsguo008/article/details/73556811</a></p><p>Epoll是Linux进行IO多路复用的一种方式，用于在一个线程里监听多个IO源，在IO源可用的时候返回并进行操作。它的特点是基于事件驱动，性能很高。</p><p>epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间，由用户程序进行处理。</p><p>Epoll有三个系统调用：epoll_create(),epoll_ctl()和epoll_wait()。</p><ul><li><p>eoll_create()函数在内核中初始化一个eventpoll对象，同时初始化红黑树和就绪链表。</p></li><li><p>epoll_ctl()用来对监听的文件描述符进行管理。将文件描述符插入红黑树，或者从红黑树中删除，这个过程的时间复杂度是log(N)。同时向内核注册文件描述符的回调函数。</p></li><li><p>epoll_wait()会将进程放到eventpoll的等待队列中，将进程阻塞，当某个文件描述符IO可用时，内核通过回调函数将该文件描述符放到就绪链表里，epoll_wait()会将就绪链表里的文件描述符返回到用户空间。</p><h4 id="（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？"><a href="#（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？" class="headerlink" title="（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？"></a>（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？</h4><p>（1）select的方法介绍：select把所有监听的文件描述符拷贝到内核中，挂起进程。当某个文件描述符可读或可写的时候，中断程序唤起进程，select将监听的文件描述符再次拷贝到用户空间，然select后遍历这些文件描述符找到IO可用的文件。下次监控的时候需要再次拷贝这些文件描述符到内核空间。select支持监听的描述符最大数量是1024.<br><img src="fig/select.png" alt="select"><br>（2）poll使用链表保存文件描述符，其他的跟select没有什么不同。</p></li></ul><p>（3）epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间。<br><img src="fig/epoll.png" alt="epoll"><br>详见 <a href="https://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">https://www.cnblogs.com/Anker/p/3265058.html</a></p><h4 id="（5）-Epoll的ET模式和LT模式（ET的非阻塞）"><a href="#（5）-Epoll的ET模式和LT模式（ET的非阻塞）" class="headerlink" title="（5） Epoll的ET模式和LT模式（ET的非阻塞）"></a>（5） Epoll的ET模式和LT模式（ET的非阻塞）</h4><ul><li>ET是边缘触发模式，在这种模式下，只有当描述符从未就绪变成就绪时，内核才会通过epoll进行通知。然后直到下一次变成就绪之前，不会再次重复通知。也就是说，如果一次就绪通知之后不对这个描述符进行IO操作导致它变成未就绪，内核也不会再次发送就绪通知。优点就是只通知一次，减少内核资源浪费，效率高。缺点就是不能保证数据的完整，有些数据来不及读可能就会无法取出。</li><li>LT是水平触发模式，在这个模式下，如果文件描述符IO就绪，内核就会进行通知，如果不对它进行IO操作，只要还有未操作的数据，内核都会一直进行通知。优点就是可以确保数据可以完整输出。缺点就是由于内核会一直通知，会不停从内核空间切换到用户空间，资源浪费严重。<h4 id="（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"><a href="#（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）" class="headerlink" title="（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"></a>（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）</h4>详见：<a href="https://blog.csdn.net/qq_36357820/article/details/76606113" target="_blank" rel="noopener">https://blog.csdn.net/qq_36357820/article/details/76606113</a></li></ul><ol><li>top命令查看linux负载：</li><li>uptime查看linux负载</li><li>w查看linux负载：</li><li>vmstat查看linux负载<h4 id="（7）-linux的其他常见命令（kill，find，cp等等）"><a href="#（7）-linux的其他常见命令（kill，find，cp等等）" class="headerlink" title="（7） linux的其他常见命令（kill，find，cp等等）"></a>（7） linux的其他常见命令（kill，find，cp等等）</h4><h4 id="（8）-shell脚本用法"><a href="#（8）-shell脚本用法" class="headerlink" title="（8） shell脚本用法"></a>（8） shell脚本用法</h4><h4 id="（9）-硬连接和软连接的区别"><a href="#（9）-硬连接和软连接的区别" class="headerlink" title="（9） 硬连接和软连接的区别"></a>（9） 硬连接和软连接的区别</h4><h4 id="（10）-文件权限怎么看（rwx）"><a href="#（10）-文件权限怎么看（rwx）" class="headerlink" title="（10） 文件权限怎么看（rwx）"></a>（10） 文件权限怎么看（rwx）</h4><h4 id="（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变"><a href="#（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变" class="headerlink" title="（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变"></a>（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变</h4><h4 id="（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"><a href="#（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令" class="headerlink" title="（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"></a>（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令</h4><h4 id="（13）Linux中线程的同步方式有哪些？"><a href="#（13）Linux中线程的同步方式有哪些？" class="headerlink" title="（13）Linux中线程的同步方式有哪些？"></a>（13）Linux中线程的同步方式有哪些？</h4><h4 id="（14）怎么修改一个文件的权限"><a href="#（14）怎么修改一个文件的权限" class="headerlink" title="（14）怎么修改一个文件的权限"></a>（14）怎么修改一个文件的权限</h4>chmod 777  (177 277 477 等，权限组合是 1 2 4，分别代表r x w )<h4 id="（15）查看文件内容常用命令"><a href="#（15）查看文件内容常用命令" class="headerlink" title="（15）查看文件内容常用命令"></a>（15）查看文件内容常用命令</h4>详见： <a href="http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html</a></li><li>cat 与 tac<pre><code>cat的功能是将文件从第一行开始连续的将内容输出在屏幕上。当文件大，行数比较多时，屏幕无法全部容下时，只能看到一部分内容。所以通常使用重定向的方式，输出满足指定格式的内容</code></pre></li></ol><p>cat语法：cat [-n]  文件名 （-n ： 显示时，连行号一起输出）</p><p>tac的功能是将文件从最后一行开始倒过来将内容数据输出到屏幕上。我们可以发现，tac实际上是cat反过来写。这个命令不常用。</p><p>tac语法：tac 文件名。</p><pre><code>2. more和less（常用）</code></pre><p>more的功能是将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容。当一页无法全部输出时，可以用“回车键”向下翻行，用“空格键”向下翻页。退出查看页面，请按“q”键。另外，more还可以配合管道符“|”（pipe）使用，例如:ls -al | more</p><p>more的语法：more 文件名</p><p>Enter 向下n行，需要定义，默认为1行； </p><p>Ctrl f 向下滚动一屏； </p><p>空格键 向下滚动一屏； </p><p>Ctrl b 返回上一屏； </p><p>= 输出当前行的行号； </p><p>:f 输出文件名和当前行的行号； </p><p>v 调用vi编辑器； </p><p>! 命令 调用Shell，并执行命令； </p><p>q 退出more</p><p>less的功能和more相似，但是使用more无法向前翻页，只能向后翻。</p><p>less可以使用【pageup】和【pagedown】键进行前翻页和后翻页，这样看起来更方便。</p><p>less的语法：less 文件名</p><pre><code>3. head和tail</code></pre><p>head和tail通常使用在只需要读取文件的前几行或者后几行的情况下使用。head的功能是显示文件的前几行内容</p><p>head的语法：head [n number] 文件名 (number 显示行数)</p><p>tail的功能恰好和head相反，只显示最后几行内容</p><p>tail的语法:tail [-n number] 文件名</p><pre><code>4. nl</code></pre><p>nl的功能和cat -n一样，同样是从第一行输出全部内容，并且把行号显示出来</p><p>nl的语法：nl 文件名</p><pre><code>5. vim这个用的太普遍了，主要是用于编辑。#### （16）怎么找出含有关键字的前后4行#### （17）Linux的GDB调试#### （18）coredump是什么 怎么才能coredumpcoredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。coredump产生的条件1. shell资源控制限制，使用 ulimit -c 命令查看shell执行程序时的资源 ，如果为0，则不会产生coredump。可以用ulimit -c unlimited设置为不限大小。2. 读写越界，包括：数组访问越界，指针指向错误的内存，字符串读写越界3. 使用了线程不安全的函数，读写未加锁保护4. 错误使用指针转换5. 堆栈溢出#### （19）tcpdump常用命令用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。实用命令实例将某端口收发的数据包保存到文件&lt;br&gt;`sudo tcpdump -i any port 端口 -w 文件名.cap`打印请求到屏幕&lt;br&gt;`sudo tcpdump -i any port 端口 -Xnlps0`默认启动&lt;br&gt;`tcpdump`普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包。监视指定网络接口的数据包&lt;br&gt;`tcpdump -i eth1`如果不指定网卡，默认tcpdump只会监视第一个网络接口，一般是eth0，下面的例子都没有指定网络接口。　#### （20） crontab命令详见：https://www.cnblogs.com/peida/archive/2013/01/08/2850483.htmlcorntab命令是用来指定用户计划任务的。用户将需要定时执行的任务写入crontab文件中，提交给crond进程定期执行。* crontab命令用来对crontab文件进行管理</code></pre><p>1．命令格式：<br>crontab [-u user] file<br>crontab [-u user] [ -e | -l | -r ]<br>2．命令功能：<br>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。<br>3．命令参数：<br>-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。<br>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。<br>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。<br>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。<br>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。<br>-i：在删除用户的crontab文件时给确认提示。</p><pre><code>* crontab文件内容crond是Linux下的周期性执行系统任务的守护进程，他会根据/etc下的crontab配置文件的内容执行。用户需要将计划任务写入crontab文件中才能执行。用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</code></pre><p>minute   hour   day   month   week   command</p><p>其中：<br>minute： 表示分钟，可以是从0到59之间的任何整数。<br>hour：表示小时，可以是从0到23之间的任何整数。<br>day：表示日期，可以是从1到31之间的任何整数。<br>month：表示月份，可以是从1到12之间的任何整数。<br>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。<br>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。<br>在以上各个字段中，还可以使用以下特殊字符：<br>星号（<em>）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。<br>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”<br>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”<br>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如</em>/10，如果用在minute字段，表示每十分钟执行一次。</p><pre><code>#### （21） 查看后台进程* jobs查看当前控制台的后台进程想要停止后台进程，使用jobs命令查看其进程号（比如为num），然后kill %num即可* ps查看后台进程* top查看所有进程和资源使用情况，类似Windows中的任务管理器停止进程：界面是交互式的，在窗口输入k 之后输入PID，会提示输入停止进程模式 有SIGTERM和 SIGKILL 如果留空不输入，就是SIGTERM（优雅停止）退出top：输入q即可# 5. 操作系统#### （1） 进程与线程的区别和联系（重点）* 区别1. 进程是对运行时程序的封装，是系统进行资源分配和调度的基本单元，而线程是进程的子任务，是CPU分配和调度的基本单元。2. 一个进程可以有多个线程，但是一个线程只能属于一个进程。3. 进程的创建需要系统分配内存和CPU，文件句柄等资源，销毁时也要进行相应的回收，所以进程的管理开销很大；但是线程的管理开销则很小。4. 进程之间不会相互影响；而一个线程崩溃会导致进程崩溃，从而影响同个进程里面的其他线程。* 联系 进程与线程之间的关系：线程是存在进程的内部，一个进程中可以有多个线程，一个线程只能存在一个进程中。#### （2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关答：32768. 因为进程的pid是用pid_t来表示的，pid_t的最大值是32768.所以理论上最多有32768个进程。至于线程。进程最多可以创建的线程数是根据分配给调用栈的大小，以及操作系统（32位和64位不同）共同决定的。Linux32位下是300多个。#### （3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）* 存储器：内存* 控制器：南桥北桥* 运算器：CPU* 输入设备：键盘* 输出设备：显示器、网卡#### （4） 进程之间的通信方法有哪几种 （重点）进程之间的通信方式主要有六种，包括**管道，信号量，消息队列，信号，共享内存，套接字**。* 管道：管道是半双工的，双方需要通信的时候，需要建立两个管道。管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。管道是最容易实现的![fig/管道通信.png](fig/管道通信.png)  匿名管道pipe和命名管道除了建立，打开，删除的方式不同外，其余都是一样的。匿名管道只允许有亲缘关系的进程之间通信，也就是父子进程之间的通信，命名管道允许具有非亲缘关系的进程间通信。  管道的底层实现 https://segmentfault.com/a/1190000009528245* 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。信号量只有等待和发送两种操作。等待(P(sv))就是将其值减一或者挂起进程，发送(V(sv))就是将其值加一或者将进程恢复运行。* 信号：信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 信号是开销最小的* 共享内存：共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，就像由malloc()分配的内存一样使用。一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。共享内存的效率最高，缺点是没有提供同步机制，需要使用锁等其他机制进行同步。* 消息队列：消息队列就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。* 套接字：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。#### （5） 进程调度方法详细介绍https://blog.csdn.net/u011080472/article/details/51217754https://blog.csdn.net/leex_brave/article/details/51638300* 先来先服务 （FCFS first come first serve）：按照作业到达任务队列的顺序调度  FCFS是非抢占式的，易于实现，效率不高，性能不好，有利于长作业（CPU繁忙性）而不利于短作业（I/O繁忙性）。* 短作业优先 （SHF short job first）：每次从队列里选择预计时间最短的作业运行。SJF是非抢占式的，优先照顾短作业，具有很好的性能，降低平均等待时间，提高吞吐量。但是不利于长作业，长作业可能一直处于等待状态，出现饥饿现象；完全未考虑作业的优先紧迫程度，不能用于实时系统。* 最短剩余时间优先 该算法首先按照作业的服务时间挑选最短的作业运行，在该作业运行期间，一旦有新作业到达系统，并且该新作业的服务时间比当前运行作业的剩余服务时间短，则发生抢占；否则，当前作业继续运行。该算法确保一旦新的短作业或短进程进入系统，能够很快得到处理。* 高响应比优先调度算法（Highest Reponse Ratio First, HRRF）是非抢占式的，主要用于作业调度。基本思想：每次进行作业调度时，先计算后备作业队列中每个作业的响应比，挑选最高的作业投入系统运行。响应比 = （等待时间 + 服务时间） / 服务时间 = 等待时间 / 服务时间 + 1。因为每次都需要计算响应比，所以比较耗费系统资源。* 时间片轮转 用于分时系统的进程调度。基本思想：系统将CPU处理时间划分为若干个时间片（q），进程按照到达先后顺序排列。每次调度选择队首的进程，执行完1个时间片q后，计时器发出时钟中断请求，该进程移至队尾。以后每次调度都是如此。该算法能在给定的时间内响应所有用户的而请求，达到分时系统的目的。* 多级反馈队列(Multilevel Feedback Queue) #### （6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？进程的执行需要经过三大步骤：编译，链接和装入。* 编译：将源代码编译成若干模块* 链接：将编译后的模块和所需要的库函数进行链接。链接包括三种形式：静态链接，装入时动态链接（将编译后的模块在链接时一边链接一边装入），运行时动态链接（在执行时才把需要的模块进行链接）* 装入：将模块装入内存运行https://blog.csdn.net/qq_38623623/article/details/78306498将进程装入内存时，通常使用分页技术，将内存分成固定大小的页，进程分为固定大小的块，加载时将进程的块装入页中，并使用页表记录。减少外部碎片。通常操作系统还会使用虚拟内存的技术将磁盘作为内存的扩充。#### （6） 操作系统的内存管理说一下https://www.cnblogs.com/peterYong/p/6556619.htmlhttps://zhuanlan.zhihu.com/p/141602175操作系统的内存管理包括物理内存管理和虚拟内存管理* 物理内存管理包括交换与覆盖，分页管理，分段管理和段页式管理等；* 虚拟内存管理包括虚拟内存的概念，页面置换算法，页面分配策略等；（面试官这样问的时候，其实是希望你能讲讲虚拟内存）#### （7） 实现一个LRU算法用到两个数据结构：哈希+双向链表 </code></pre><p>unordered_map&lt;int,list&lt;pair&lt;int,int&gt; &gt; &gt; cache ;// 存放键，迭代器<br>list&lt;pair&lt;int,int&gt;&gt; auxlist; // 存放 &lt;键，值&gt;</p><pre><code></code></pre><p>class LRUCache {<br>    int cap;<br>    list&lt;pair&lt;int,int&gt;&gt; l;// front:new back:old 存放值 新的放前面，因为前面的可以取得有效的迭代器<br>    map&lt;int,list&lt;pair&lt;int,int&gt; &gt;::iterator &gt; cache;// 存放键，迭代器<br>public:<br>    LRUCache(int capacity) {<br>        cap=capacity;<br>    }</p><pre><code>int get(int key) {    auto mapitera = cache.find(key);    if(mapitera==cache.end()){        return -1;    }else{// found        list&lt;pair&lt;int,int&gt;&gt;::iterator listItera = mapitera-&gt;second;        int value = (*listItera).second;        l.erase(listItera);        l.push_front({key,value});        cache[key]=l.begin();        return value;    }}void put(int key, int value) {    auto itera = cache.find(key);    if(itera!=cache.end()){// exist        list&lt;pair&lt;int,int&gt;&gt;::iterator listItera = itera-&gt;second;        l.erase(listItera);        l.push_front({key,value});        cache[key]=l.begin();    }else{// not exist        if(cache.size()&gt;=cap){            pair&lt;int,int&gt; oldpair = l.back();            l.pop_back();            cache.erase(oldpair.first);        }        l.push_front({key,value});        cache[key]=l.begin();    }}</code></pre><p>};</p><p>/**</p><ul><li>Your LRUCache object will be instantiated and called as such:</li><li>LRUCache* obj = new LRUCache(capacity);</li><li>int param_1 = obj-&gt;get(key);</li><li>obj-&gt;put(key,value);</li><li>/<pre><code>#### （8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）（1） 互斥：一个资源每次只能被一个进程使用。&lt;br&gt;（2） 占有并请求：一个进程因请求资源而阻塞时，对已获得的资源保持不放。&lt;br&gt;（3） 不可剥夺:进程已获得的资源，在末使用完之前，不能强行剥夺。&lt;br&gt;（4） 循环等待:若干进程之间形成一种头尾相接的循环等待资源关系。&lt;br&gt;</code></pre></li></ul><p>产生死锁的原因主要是：<br><br>（1） 因为系统资源不足。<br><br>（2） 进程运行推进的顺序不合适。<br><br>（3） 资源分配不当等。<br></p><h4 id="（8）-死锁的恢复"><a href="#（8）-死锁的恢复" class="headerlink" title="（8） 死锁的恢复"></a>（8） 死锁的恢复</h4><ol><li>重新启动：是最简单、最常用的死锁消除方法，但代价很大，因为在此之前所有进程已经完成的计算工作都将付之东流，不仅包括死锁的全部进程，也包括未参与死锁的全部进程。</li><li>终止进程(process termination)：终止参与死锁的进程并回收它们所占资源。<br> (1) 一次性全部终止；(2) 逐步终止(优先级，代价函数)</li><li>剥夺资源(resource preemption):剥夺死锁进程所占有的全部或者部分资源。<br> (1) 逐步剥夺：一次剥夺死锁进程所占有的一个或一组资源，如果死锁尚未解除再继续剥夺，直至死锁解除为止。<br> (2) 一次剥夺：一次性地剥夺死锁进程所占有的全部资源。</li><li>进程回退(rollback):让参与死锁的进程回退到以前没有发生死锁的某个点处，并由此点开始继续执行，希望进程交叉执行时不再发生死锁。但是系统开销很大：<br> (1) 要实现“回退”，必须“记住”以前某一点处的现场，而现场随着进程推进而动态变化，需要花费大量时间和空间。<br> (2) 一个回退的进程应当“挽回”它在回退点之间所造成的影响，如修改某一文件，给其它进程发送消息等，这些在实现时是难以做到的<h4 id="（8）什么是饥饿"><a href="#（8）什么是饥饿" class="headerlink" title="（8）什么是饥饿"></a>（8）什么是饥饿</h4>饥饿是由于资源分配策略不公引起的，当进程或线程无法访问它所需要的资源而不能继续执行时，就会发生饥饿现象。<h4 id="（9）-如果要你实现一个mutex互斥锁你要怎么实现？"><a href="#（9）-如果要你实现一个mutex互斥锁你要怎么实现？" class="headerlink" title="（9） 如果要你实现一个mutex互斥锁你要怎么实现？"></a>（9） 如果要你实现一个mutex互斥锁你要怎么实现？</h4><a href="https://blog.csdn.net/kid551/article/details/84338619" target="_blank" rel="noopener">https://blog.csdn.net/kid551/article/details/84338619</a></li></ol><p>实现mutex最重要的就是实现它的lock()方法和unlock()方法。我们保存一个全局变量flag，flag=1表明该锁已经锁住，flag=0表明锁没有锁住。<br>实现lock()时，使用一个while循环不断检测flag是否等于1，如果等于1就一直循环。然后将flag设置为1；unlock()方法就将flag置为0；</p><pre class="line-numbers language-C++"><code class="language-C++">static int flag=0;void lock(){  while(TestAndSet(&flag,1)==1);  //flag=1;}void unlock(){  flag=0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为while有可能被重入，所以可以用TestandSet()方法。</p><pre class="line-numbers language-C++"><code class="language-C++">int TestAndSet(int *ptr, int new) {    int old = *ptr;    *ptr = new;    return old;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（10）线程之间的通信方式有哪些？-进程之间的同步方式又哪些？"><a href="#（10）线程之间的通信方式有哪些？-进程之间的同步方式又哪些？" class="headerlink" title="（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？"></a>（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？</h4><p>线程之间通信：</p><ul><li>使用全局变量</li><li>使用信号机制</li><li>使用事件</li></ul><p>进程之间同步：<br><a href="https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html" target="_blank" rel="noopener">https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html</a></p><ul><li><p>信号量</p></li><li><p>管程</p><h4 id="（13）-什么时候用多进程，什么时候用多线程"><a href="#（13）-什么时候用多进程，什么时候用多线程" class="headerlink" title="（13） 什么时候用多进程，什么时候用多线程"></a>（13） 什么时候用多进程，什么时候用多线程</h4><p><a href="https://blog.csdn.net/yu876876/article/details/82810178" target="_blank" rel="noopener">https://blog.csdn.net/yu876876/article/details/82810178</a></p></li><li><p>频繁修改：需要频繁创建和销毁的优先使用<strong>多线程</strong></p></li><li><p>计算量：需要大量计算的优先使用<strong>多线程</strong>  因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</p></li><li><p>相关性：任务间相关性比较强的用<strong>多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。</p></li><li><p>多分布：可能要扩展到多机分布的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong>。</p></li></ul><p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。</p><h4 id="（14）-文件读写使用的系统调用"><a href="#（14）-文件读写使用的系统调用" class="headerlink" title="（14） 文件读写使用的系统调用"></a>（14） 文件读写使用的系统调用</h4><h4 id="（15）-孤儿进程和僵尸进程分别是什么，怎么形成的？"><a href="#（15）-孤儿进程和僵尸进程分别是什么，怎么形成的？" class="headerlink" title="（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？"></a>（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？</h4><p><a href="https://www.cnblogs.com/Anker/p/3271773.html" target="_blank" rel="noopener">https://www.cnblogs.com/Anker/p/3271773.html</a></p><ul><li>孤儿进程是父进程退出后它的子进程还在执行，这时候这些子进程就成为孤儿进程。孤儿进程会被init进程收养并完成状态收集。</li><li>僵尸进程是指子进程完成并退出后父进程没有使用wait()或者waitpid()对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就成为僵尸进程。<h4 id="（16）-说一下PCB-说一下进程地址空间"><a href="#（16）-说一下PCB-说一下进程地址空间" class="headerlink" title="（16） 说一下PCB/说一下进程地址空间/"></a>（16） 说一下PCB/说一下进程地址空间/</h4><a href="https://blog.csdn.net/qq_38499859/article/details/80057427" target="_blank" rel="noopener">https://blog.csdn.net/qq_38499859/article/details/80057427</a></li></ul><p>PCB就是进程控制块，是操作系统中的一种数据结构，用于表示进程状态，操作系统通过PCB对进程进行管理。</p><p>PCB中包含有：进程标识符，处理器状态，进程调度信息，进程控制信息</p><p><img src="https://img-blog.csdn.net/20140904215636015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd6aGVianV0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p>进程地址空间内有：</p><ul><li>代码段text：存放程序的二进制代码</li><li>初始化的数据Data：已经初始化的变量和数据</li><li>未初始化的数据BSS：还没有初始化的数据</li><li>栈</li><li>堆<h4 id="（17）-内核空间和用户空间是怎样区分的"><a href="#（17）-内核空间和用户空间是怎样区分的" class="headerlink" title="（17） 内核空间和用户空间是怎样区分的"></a>（17） 内核空间和用户空间是怎样区分的</h4>在Linux中虚拟地址空间范围为0到4G，最高的1G地址（0xC0000000到0xFFFFFFFF）供内核使用，称为内核空间，低的3G空间（0x00000000到0xBFFFFFFF）供各个进程使用，就是用户空间。</li></ul><p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。</p><h4 id="（18）-多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"><a href="#（18）-多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）" class="headerlink" title="（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"></a>（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）</h4><p><a href="https://blog.csdn.net/s_lisheng/article/details/74278765" target="_blank" rel="noopener">https://blog.csdn.net/s_lisheng/article/details/74278765</a></p><ul><li>临界区</li><li>信号量</li><li>事件</li><li>互斥量<h4 id="（19）-同一个进程内的线程会共享什么资源？"><a href="#（19）-同一个进程内的线程会共享什么资源？" class="headerlink" title="（19） 同一个进程内的线程会共享什么资源？"></a>（19） 同一个进程内的线程会共享什么资源？</h4></li><li>该进程的地址空间</li><li>全局变量</li><li>堆空间</li></ul><p>线程的栈空间是自己独有的</p><h4 id="（20）-异常和中断的区别"><a href="#（20）-异常和中断的区别" class="headerlink" title="（20） 异常和中断的区别"></a>（20） 异常和中断的区别</h4><h4 id="（21）-一般情况下在Linux-windows平台下栈空间的大小"><a href="#（21）-一般情况下在Linux-windows平台下栈空间的大小" class="headerlink" title="（21） 一般情况下在Linux/windows平台下栈空间的大小"></a>（21） 一般情况下在Linux/windows平台下栈空间的大小</h4><p>在Linux下栈空间通常是8M，Windows下是1M</p><h4 id="（22）虚拟内存的了解"><a href="#（22）虚拟内存的了解" class="headerlink" title="（22）虚拟内存的了解"></a>（22）虚拟内存的了解</h4><p><a href="https://www.cnblogs.com/Przz/p/6876988.html" target="_blank" rel="noopener">https://www.cnblogs.com/Przz/p/6876988.html</a></p><p>在运行一个进程的时候，它所需要的内存空间可能大于系统的物理内存容量。通常一个进程会有4G的空间，但是物理内存并没有这么大，所以这些空间都是虚拟内存，它的地址都是逻辑地址，每次在访问的时候都需要映射成物理地址。<br>当进程访问某个逻辑地址的时候，会去查看页表，如果页表中没有相应的物理地址，说明内存中没有这页的数据，发生缺页异常，这时候进程需要把数据从磁盘拷贝到物理内存中。如果物理内存已经满了，就需要覆盖已有的页，如果这个页曾经被修改过，那么还要把它写回磁盘。</p><h4 id="（23）服务器高并发的解决方案"><a href="#（23）服务器高并发的解决方案" class="headerlink" title="（23）服务器高并发的解决方案"></a>（23）服务器高并发的解决方案</h4><ol><li><p>应用数据与静态资源分离<br>将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</p></li><li><p>客户端缓存<br>因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</p></li><li><p>集群和分布式<br>（集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）<br><br>（分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）<br><br>可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</p></li><li><p>反向代理<br>在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</p><h4 id="（24）协程了解吗（高频）"><a href="#（24）协程了解吗（高频）" class="headerlink" title="（24）协程了解吗（高频）"></a>（24）协程了解吗（高频）</h4><p>协程和微线程是一个东西。</p></li></ol><p>协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。<br>这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。</p><h4 id="（25）那协程的底层是怎么实现的，怎么使用协程？"><a href="#（25）那协程的底层是怎么实现的，怎么使用协程？" class="headerlink" title="（25）那协程的底层是怎么实现的，怎么使用协程？"></a>（25）那协程的底层是怎么实现的，怎么使用协程？</h4><p>协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。</p><h4 id="（23）进程的状态以及转换图"><a href="#（23）进程的状态以及转换图" class="headerlink" title="（23）进程的状态以及转换图"></a>（23）进程的状态以及转换图</h4><ul><li><p>三态模型<br>三态模型包括三种状态：</p><ol><li>执行：进程分到CPU时间片，可以执行</li><li>就绪：进程已经就绪，只要分配到CPU时间片，随时可以执行</li><li>阻塞：有IO事件或者等待其他资源<br><img src="fig/%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt></li></ol></li><li><p>五态模型</p><ol><li>新建态：进程刚刚创建。</li><li>就绪态：</li><li>运行态：</li><li>等待态：出现等待事件</li><li>终止态：进程结束<br><img src="fig/%E4%BA%94%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt></li></ol></li><li><p>七态模型</p><ol><li>新建态</li><li>就绪挂起态</li><li>就绪态</li><li>运行态</li><li>等待态</li><li>挂起等待态</li><li>终止态<br><img src="fig/%E4%B8%83%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt></li></ol></li></ul><h4 id="（24）在执行malloc申请内存的时候，操作系统是怎么做的？-内存分配的原理说一下-malloc函数底层是怎么实现的？-进程是怎么分配内存的？"><a href="#（24）在执行malloc申请内存的时候，操作系统是怎么做的？-内存分配的原理说一下-malloc函数底层是怎么实现的？-进程是怎么分配内存的？" class="headerlink" title="（24）在执行malloc申请内存的时候，操作系统是怎么做的？/内存分配的原理说一下/malloc函数底层是怎么实现的？/进程是怎么分配内存的？"></a>（24）在执行malloc申请内存的时候，操作系统是怎么做的？/内存分配的原理说一下/malloc函数底层是怎么实现的？/进程是怎么分配内存的？</h4><p><a href="https://blog.csdn.net/yusiguyuan/article/details/39496057" target="_blank" rel="noopener">https://blog.csdn.net/yusiguyuan/article/details/39496057</a></p><p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap</p><ul><li>brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小</li><li>mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</li></ul><p>通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。</p><p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</p><h4 id="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"><a href="#（25）什么是字节序？怎么判断是大端还是小端？有什么用？" class="headerlink" title="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"></a>（25）什么是字节序？怎么判断是大端还是小端？有什么用？</h4><p><a href="https://www.cnblogs.com/broglie/p/5645200.html" target="_blank" rel="noopener">https://www.cnblogs.com/broglie/p/5645200.html</a></p><p>字节序是对象在内存中存储的方式，大端即为最高有效位在前面，小端即为最低有效位在前面。<br>判断大小端的方法：使用一个union数据结构</p><pre class="line-numbers language-C++"><code class="language-C++">union{  short s;  char c[2]; // sizeof(short)=2;}un;un.s=0x0102;if(un.c[0]==1 and un.c[1]==2) cout<<"大端";if(un.c[0]==2 and un.c[1]==1) cout<<"小端";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在网络编程中不同字节序的机器发送和接收的顺序不同。</p><h1 id="6-场景题-算法题"><a href="#6-场景题-算法题" class="headerlink" title="6. 场景题/算法题"></a>6. 场景题/算法题</h1><h4 id="（0）-leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！"><a href="#（0）-leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！" class="headerlink" title="（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！"></a>（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！</h4><p>面试中90%的算法题都从leetcode hot100和剑指offer中出 刷两遍非常有必要</p><h4 id="（1）-介绍熟悉的设计模式（单例，简单工厂模式）"><a href="#（1）-介绍熟悉的设计模式（单例，简单工厂模式）" class="headerlink" title="（1） 介绍熟悉的设计模式（单例，简单工厂模式）"></a>（1） 介绍熟悉的设计模式（单例，简单工厂模式）</h4><h4 id="（2）-写单例模式，线程安全版本"><a href="#（2）-写单例模式，线程安全版本" class="headerlink" title="（2） 写单例模式，线程安全版本"></a>（2） 写单例模式，线程安全版本</h4><pre class="line-numbers language-C++"><code class="language-C++">class Singleton{  private:    static Singleton* instance;    Singleton(){      // initialize    }  public:    static Singleton* getInstance(){      if(instance==nullptr) instance=new Singleton();      return instance;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（3）-写三个线程交替打印ABC"><a href="#（3）-写三个线程交替打印ABC" class="headerlink" title="（3） 写三个线程交替打印ABC"></a>（3） 写三个线程交替打印ABC</h4><pre class="line-numbers language-C++"><code class="language-C++">#include<iostream>#include<thread>#include<mutex>#include<condition_variable>using namespace std;mutex mymutex;condition_variable cv;int flag=0;void printa(){    unique_lock<mutex> lk(mymutex);    int count=0;    while(count<10){        while(flag!=0) cv.wait(lk);        cout<<"thread 1: a"<<endl;        flag=1;        cv.notify_all();        count++;    }    cout<<"my thread 1 finish"<<endl;}void printb(){    unique_lock<mutex> lk(mymutex);    for(int i=0;i<10;i++){        while(flag!=1) cv.wait(lk);        cout<<"thread 2: b"<<endl;        flag=2;        cv.notify_all();    }    cout<<"my thread 2 finish"<<endl;}void printc(){    unique_lock<mutex> lk(mymutex);    for(int i=0;i<10;i++){        while(flag!=2) cv.wait(lk);        cout<<"thread 3: c"<<endl;        flag=0;        cv.notify_all();    }    cout<<"my thread 3 finish"<<endl;}int main(){    thread th2(printa);    thread th1(printb);    thread th3(printc);    th1.join();    th2.join();    th3.join();    cout<<" main thread "<<endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（4）-二维码登录的实现过程-场景题"><a href="#（4）-二维码登录的实现过程-场景题" class="headerlink" title="（4） 二维码登录的实现过程 场景题"></a>（4） 二维码登录的实现过程 场景题</h4><p><img src="fig/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png" alt></p><h4 id="（5）-不使用临时变量实现swap函数"><a href="#（5）-不使用临时变量实现swap函数" class="headerlink" title="（5） 不使用临时变量实现swap函数"></a>（5） 不使用临时变量实现swap函数</h4><ul><li>使用异或/加减等方式，下面给出使用异或的实现方法<pre class="line-numbers language-C++"><code class="language-C++">void swap(int& a,int& b){a=a^b;b=a^b;a=a^b;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（6）-实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"><a href="#（6）-实现一个strcpy函数（或者memcpy），如果内存可能重叠呢" class="headerlink" title="（6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"></a>（6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢</h4><h4 id="（7）-实现快排"><a href="#（7）-实现快排" class="headerlink" title="（7） 实现快排"></a>（7） 实现快排</h4><pre class="line-numbers language-C++"><code class="language-C++">void swap(vector<int>& vec,int a,int b){  vec[a]=vec[a]^vec[b];  vec[b]=vec[a]^vec[b];  vec[a]=vec[a]^vec[b];}int partition(vector<int>& vec,int start,int end){  int pivot=vec[start+(end-start)/2];  while(start<end){      while(start<end and vec[start]<pivot) start++;      while(start<end and vec[end]>pivot) end--;      if(start<end) swap(vec,start,end);  }  return start;}void quickSort(vector<int>& vec,int start,int end){  if(start>end) return;  int pivot=partition(vec,start,end);  quickSort(vec,start,pivot-1);  quickSort(vec,pivot+1,end);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（8）-实现一个堆排序"><a href="#（8）-实现一个堆排序" class="headerlink" title="（8） 实现一个堆排序"></a>（8） 实现一个堆排序</h4>堆排序的基本过程：</li><li>将n个元素的序列构建一个大顶堆或小顶堆</li><li>将堆顶的元素放到序列末尾</li><li>将前n-1个元素重新构建大顶堆或小顶堆，重复这个过程，直到所有元素都已经排序</li></ul><p>整体时间复杂度为nlogn</p><pre class="line-numbers language-C++"><code class="language-C++">#include<iostream>#include<vector>using namespace std;void swap(vector<int>& arr, int a,int b){    arr[a]=arr[a]^arr[b];    arr[b]=arr[a]^arr[b];    arr[a]=arr[a]^arr[b];}void adjust(vector<int>& arr,int len,int index){    int maxid=index;    // 计算左右子节点的下标   left=2*i+1  right=2*i+2  parent=(i-1)/2    int left=2*index+1,right=2*index+2;    // 寻找当前以index为根的子树中最大/最小的元素的下标    if(left<len and arr[left]<arr[maxid]) maxid=left;    if(right<len and arr[right]<arr[maxid]) maxid=right;    // 进行交换，记得要递归进行adjust,传入的index是maxid    if(maxid!=index){        swap(arr,maxid,index);        adjust(arr,len,maxid);    }}void heapsort(vector<int>&arr,int len){    // 初次构建堆，i要从最后一个非叶子节点开始，所以是(len-1-1)/2，0这个位置要加等号    for(int i=(len-1-1)/2;i>=0;i--){        adjust(arr,len,i);    }    // 从最后一个元素的下标开始往前遍历，每次将堆顶元素交换至当前位置，并且缩小长度（i为长度），从0处开始adjust    for(int i=len-1;i>0;i--){        swap(arr,0,i);        adjust(arr,i,0);// 注意每次adjust是从根往下调整，所以这里index是0！    }}int main(){    vector<int> arr={3,4,2,1,5,8,7,6};    cout<<"before: "<<endl;    for(int item:arr) cout<<item<<" ";    cout<<endl;    heapsort(arr,arr.size());    cout<<"after: "<<endl;    for(int item:arr)cout<<item<<" ";    cout<<endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（8）-实现一个插入排序"><a href="#（8）-实现一个插入排序" class="headerlink" title="（8） 实现一个插入排序"></a>（8） 实现一个插入排序</h4><p><a href="https://blog.csdn.net/left_la/article/details/8656425" target="_blank" rel="noopener">https://blog.csdn.net/left_la/article/details/8656425</a></p><pre class="line-numbers language-C++"><code class="language-C++">void insertSort(vector<int>& nums){  int len=nums.size();  for(int i=1;i<len;i++){    int key=nums[i];    int j=i-1;    while(j>=0 and nums[j]>key){      nums[j+1]=nums[j];      j--;    }    nums[j+1]=key;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（9）-快排存在的问题，如何优化"><a href="#（9）-快排存在的问题，如何优化" class="headerlink" title="（9） 快排存在的问题，如何优化"></a>（9） 快排存在的问题，如何优化</h4><ul><li>3 种快排基准选择方法：</li></ul><p>随机（rand函数）、固定（队首、队尾）、三数取中（队首、队中和队尾的中间数）</p><ul><li>4种优化方式：</li></ul><p>优化1：当待排序序列的长度分割到一定大小后，使用插入排序</p><p>优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割</p><p>优化3：优化递归操作</p><p>优化4：使用并行或多线程处理子序列</p><h4 id="（10）-反转一个链表（招银网络二面）"><a href="#（10）-反转一个链表（招银网络二面）" class="headerlink" title="（10） 反转一个链表（招银网络二面）"></a>（10） 反转一个链表（招银网络二面）</h4><pre class="line-numbers language-C++"><code class="language-C++">ListNode* reverse(ListNode* root){  ListNode* pre=nullptr,cur=root,nxt;  while(cur!=nullptr){    nxt=cur->next;    cur->next=pre;    pre=cur;cur=nxt;  }  return pre;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（11）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）"><a href="#（11）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）" class="headerlink" title="（11） Top K问题（可以采取的方法有哪些，各自优点？）（重点）"></a>（11） Top K问题（可以采取的方法有哪些，各自优点？）（重点）</h4><p><em>Top K 问题的常见形式：</em></p><blockquote><p>给定10000个整数，找第K大（第K小）的数<br><br> 给定10000个整数，找出最大（最小）的前K个数<br><br>给定100000个单词，求前K词频的单词<br></p></blockquote><p><em>解决Top K问题若干种方法</em></p><ul><li>使用最大最小堆。求最大的数用最小堆，求最小的数用最大堆。</li><li>Quick Select算法。使用类似快排的思路，根据pivot划分数组。</li><li>使用排序方法，排序后再寻找top K元素。</li><li>使用选择排序的思想，对前K个元素部分排序。</li><li>将1000…..个数分成m组，每组寻找top K个数，得到m×K个数，在这m×k个数里面找top K个数。</li></ul><ol><li>使用最大最小堆的思路 （以top K 最大元素为例）<br><br>按顺序扫描这10000个数，先取出K个元素构建一个大小为K的最小堆。每扫描到一个元素，如果这个元素大于堆顶的元素（这个堆最小的一个数），就放入堆中，并删除堆顶的元素，同时整理堆。如果这个元素小于堆顶的元素，就直接pass。最后堆中剩下的元素就是最大的前Top K个元素，最右的叶节点就是Top 第K大的元素。</li></ol><blockquote><p>note：最小堆的插入时间复杂度为log(n)，n为堆中元素个数，在这里是K。最小堆的初始化时间复杂度是nlog(n)</p></blockquote><p>C++中的最大最小堆要用标准库的priority_queue来实现。</p><pre class="line-numbers language-C++"><code class="language-C++">struct Node {    int value;    int idx;    Node (int v, int i): value(v), idx(i) {}    friend bool operator < (const struct Node &n1, const struct Node &n2) ; };inline bool operator < (const struct Node &n1, const struct Node &n2) {    return n1.value < n2.value;}priority_queue<Node> pq; // 此时pq为最大堆<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>使用Quick Select的思路（以寻找第K大的元素为例）<br><br>Quick Select脱胎于快速排序，提出这两个算法的都是同一个人。算法的过程是这样的：<br>首先选取一个枢轴，然后将数组中小于该枢轴的数放到左边，大于该枢轴的数放到右边。<br>此时，如果左边的数组中的元素个数大于等于K，则第K大的数肯定在左边数组中，继续对左边数组执行相同操作；<br>如果左边的数组元素个数等于K-1，则第K大的数就是pivot；<br>如果左边的数组元素个数小于K，则第K大的数肯定在右边数组中，对右边数组执行相同操作。</li></ol><p>这个算法与快排最大的区别是，每次划分后只处理左半边或者右半边，而快排在划分后对左右半边都继续排序。</p><pre><code>//此为Java实现public int findKthLargest(int[] nums, int k) {  return quickSelect(nums, k, 0, nums.length - 1);}// quick select to find the kth-largest elementpublic int quickSelect(int[] arr, int k, int left, int right) {  if (left == right) return arr[right];  int index = partition(arr, left, right);  if (index - left + 1 &gt; k)    return quickSelect(arr, k, left, index - 1);  else if (index - left + 1 == k)    return arr[index];  else    return quickSelect(arr, k - (index - left + 1), index + 1, right);}</code></pre><ol start="3"><li>使用选择排序的思想对前K个元素排序 （ 以寻找前K大个元素为例）<br><br>扫描一遍数组，选出最大的一个元素，然后再扫描一遍数组，找出第二大的元素，再扫描一遍数组，找出第三大的元素。。。。。以此类推，找K个元素，时间复杂度为O(N*K)<h4 id="（12）-8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"><a href="#（12）-8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）" class="headerlink" title="（12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"></a>（12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）</h4>我们可以使用外部排序来对它进行处理。首先将整个文件分成许多份，比如说m份，划分的依据就是使得每一份的大小都能放到内存里。然后我们用快速排序或者堆排序等方法对每一份数据进行一个内部排序，变成有序子串。接着对这m份有序子串进行m路归并排序。取这m份数据的最小元素，进行排序，输出排序后最小的元素到结果中，同时从该元素所在子串中读入一个元素，直到所有数据都被输出到结果中为止。</li></ol><p><a href="https://blog.csdn.net/ailunlee/article/details/84548950" target="_blank" rel="noopener">https://blog.csdn.net/ailunlee/article/details/84548950</a></p><h4 id="（13）-自己构建一棵二叉树，使用带有null标记的前序遍历序列"><a href="#（13）-自己构建一棵二叉树，使用带有null标记的前序遍历序列" class="headerlink" title="（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列"></a>（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列</h4><p>在写二叉树相关算法的时候，如果需要自己构造测试用例（自己构造一棵二叉树），往往是一件很麻烦的事情，我们可以用一个带有null标记的前序遍历序列来进行构造。 <strong>需要注意的是vec2tree()参数中的start是引用传递，而不是简单的参数值传递</strong>。</p><pre class="line-numbers language-C++"><code class="language-C++">#include<iostream>#include<vector>#include<queue>using namespace std;struct treeNode{    string val;    treeNode* left,*right;    treeNode(string val):val(val){        left=nullptr;        right=nullptr;    }};treeNode* vec2tree(vector<string>& vec,int& start){    treeNode* root;    if(vec[start]=="null"){        start+=1;        root=nullptr;    }else{        root=new treeNode(vec[start]);        start+=1;        root->left=vec2tree(vec,start);        root->right=vec2tree(vec,start);    }    return root;}void tree2vec(treeNode *root,vector<string>& vec){    if(root==nullptr){        vec.push_back("null");    }else{        vec.push_back(root->val);        tree2vec(root->left,vec);        tree2vec(root->right,vec);    }}int main(){    vector<string> vec={"2","4","5","7","null","null","null","null","3","6","null","null","2","null","null"};    int index=0,&start=index;    treeNode* root=vec2tree(vec,start);    //displaytree(root);    vector<string> mvec;    tree2vec(root,mvec);    for(string item:mvec) cout<<item<<" ";    cout<<endl;    return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（14）-介绍一下b树和它的应用场景有哪些"><a href="#（14）-介绍一下b树和它的应用场景有哪些" class="headerlink" title="（14） 介绍一下b树和它的应用场景有哪些"></a>（14） 介绍一下b树和它的应用场景有哪些</h4><p>B树也叫做B-树，或者平衡多路树，它是每个节点最多有m个子树的<strong>平衡树</strong>。一个m阶的B树具有如下几个特征：</p><ol><li>根结点至少有两个子女。</li><li>每个中间节点都包含至多m个子树 ， 每个节点包含的元素个数是其子树个数-1（其中 m/2 &lt;= k &lt;= m）</li><li>所有的叶子结点都位于同一层。</li><li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个子树包含的元素的值域分划。</li></ol><p>b树主要应用于文件系统中，在数据库中（mongoDB）也有应用，与B+树相比好处应该是有时不需要访问到叶节点就可以获取数据。</p><p>查询时间复杂度是logN</p><h4 id="（15）-介绍一下b-树和它的应用场景有哪些"><a href="#（15）-介绍一下b-树和它的应用场景有哪些" class="headerlink" title="（15） 介绍一下b+树和它的应用场景有哪些"></a>（15） 介绍一下b+树和它的应用场景有哪些</h4><p>B+树是一种特殊的B树，它把数据都存储在叶子节点，并且叶节点间有指针连接。内部只存关键字（其中叶子节点的最小值作为索引）和孩子指针，简化了内部节点。</p><p>应用场景主要是数据库的索引</p><p>查询时间复杂度也是logN<br><a href="https://zhuanlan.zhihu.com/p/110202102" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110202102</a></p><p><a href="https://blog.csdn.net/hguisu/article/details/7786014" target="_blank" rel="noopener">https://blog.csdn.net/hguisu/article/details/7786014</a></p><h4 id="（16）-介绍一下红黑树和它的应用场景有哪些"><a href="#（16）-介绍一下红黑树和它的应用场景有哪些" class="headerlink" title="（16） 介绍一下红黑树和它的应用场景有哪些"></a>（16） 介绍一下红黑树和它的应用场景有哪些</h4><p>红黑树是一种特殊的二叉查找树，它在每一个节点上都使用红色或黑色进行标记，通过一些性质确保它是始终平衡的。<br>它的性质是这样的：</p><ol><li>每个节点不是红色就是黑色。</li><li>根节点是黑色的。</li><li>叶节点的空节点是黑色的。</li><li>如果一个节点是红色的，那么它的两个子节点是黑色的。</li><li>对于任意节点，从它到叶节点的每条路径上都有相同数目的黑色节点。</li></ol><p>红黑树的插入，查询，删除在一般情况和最坏情况下的时间复杂度都是O(log(n))</p><p>应用场景主要是STL中map，set的实现，优点在于支持频繁的修改，因为查询删除插入时间复杂度都是logN</p><h4 id="（17）-怎么写sql取表的前1000行数据（招银网络二面）"><a href="#（17）-怎么写sql取表的前1000行数据（招银网络二面）" class="headerlink" title="（17） 怎么写sql取表的前1000行数据（招银网络二面）"></a>（17） 怎么写sql取表的前1000行数据（招银网络二面）</h4><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">limit</span> <span class="token number">1000</span><span class="token keyword">from</span> t1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="（18）-N个骰子出现和为m的概率"><a href="#（18）-N个骰子出现和为m的概率" class="headerlink" title="（18） N个骰子出现和为m的概率"></a>（18） N个骰子出现和为m的概率</h4><h4 id="（19）-海量数据问题（可参考左神的书）"><a href="#（19）-海量数据问题（可参考左神的书）" class="headerlink" title="（19） 海量数据问题（可参考左神的书）"></a>（19） 海量数据问题（可参考左神的书）</h4><h4 id="（20）-一致性哈希"><a href="#（20）-一致性哈希" class="headerlink" title="（20） 一致性哈希"></a>（20） 一致性哈希</h4><h4 id="（21）希尔排序说一下-手撕"><a href="#（21）希尔排序说一下-手撕" class="headerlink" title="（21）希尔排序说一下/手撕"></a>（21）希尔排序说一下/手撕</h4><p><a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6104371.html</a><br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><h4 id="（22）Dijkstra算法说一下"><a href="#（22）Dijkstra算法说一下" class="headerlink" title="（22）Dijkstra算法说一下"></a>（22）Dijkstra算法说一下</h4><h4 id="（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"><a href="#（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）" class="headerlink" title="（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"></a>（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）</h4><p>模拟STL中vector的实现即可，去看一下vector的源码。</p><h4 id="（24）最小生成树算法说一下"><a href="#（24）最小生成树算法说一下" class="headerlink" title="（24）最小生成树算法说一下"></a>（24）最小生成树算法说一下</h4><h4 id="（25）-海量数据的bitmap使用原理"><a href="#（25）-海量数据的bitmap使用原理" class="headerlink" title="（25） 海量数据的bitmap使用原理"></a>（25） 海量数据的bitmap使用原理</h4><p>bitmap算法就是使用一个比特映射一个值，它可以用在整数排序和数据压缩上，因为使用一个比特位去存储一个数，所以它可以大大节省空间。</p><p>它的具体过程是：先根据数组中元素最大的数N计算需要分配多大的空间。<br>如果使用int型数组的形式来保存的话，一个int = 4字节  =4*8比特 = 32比特。也就是一个int数可以映射32个数据（图1），然后需要找到最大的数Max，表示最多需要的位数，所以需要开辟的数组空间为int a[1+Max/32]。<br>然后需要推导一个整数a内如何映射32个数据，方法是将待存储的数据模32，然后将a中相应位置的比特置为1。<br>依此方法映射每一个元素，待读取的时候扫描每个比特位，遇到值为1的就还原该数字。<br><img src="fig/bitmap1.png" alt></p><p><strong>移位计算公式：</strong><br>N/32就是将N的二进制右移log32（也就是5）位 ： N&gt;&gt;5<br><br>N%32就是求N的后5位：N&amp; 0x1F  (0x1F = 00011111)<br><br>模32然后相应位置置为1： a[i] |= 1&lt;&lt; N &amp; 0x1F<br></p><p>所以总的公式为： a[ N&gt;&gt;5 ] |= 1&lt;&lt; N &amp; 0x1F<br></p><p><strong>BitMap算法评价</strong></p><ul><li>优点：<ol><li>运算效率高，不进行比较和移位；</li><li>占用内存少，比如最大的数MAX=10000000；只需占用内存为MAX/8=1250000Byte=1.25M。</li></ol></li><li>缺点：<ol><li>所有的数据不能重复，即不可对重复的数据进行排序。（少量重复数据查找还是可以的，用2-bitmap）。</li><li>所需要的空间随着最大元素的增大而增大，当数据类似（1，1000，10万）只有3个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。</li></ol></li></ul><h4 id="（26）-布隆过滤器原理与优点"><a href="#（26）-布隆过滤器原理与优点" class="headerlink" title="（26） 布隆过滤器原理与优点"></a>（26） 布隆过滤器原理与优点</h4><p>布隆过滤器是一个比特向量或者比特数组，它本质上是一种概率型数据结构，用来查找一个元素是否在集合中，支持高效插入和查询某条记录。常作为针对超大数据量下高效查找数据的一种方法。</p><p><strong>它的具体工作过程是这样子的：</strong><br>假设布隆过滤器的大小为m（比特向量的长度为m），有k个哈希函数，它对每个数据用这k个哈希函数计算哈希，得到k个哈希值，然后将向量中相应的位设为1。在查询某个数据是否存在的时候，对这个数据用k个哈希函数得到k个哈希值，再在比特向量中相应的位查找是否为1，如果某一个相应的位不为1，那这个数据就肯定不存在。但是如果全找到了，则这个数据有可能存在。</p><p><strong>为什么说有可能存在呢？</strong><br>因为不同的数据经过哈希后可能有相同的哈希值，在比特向量上某个位置查找到1也可能是由于某个另外的数据映射得到的。</p><p><strong>支持删除操作吗</strong><br>目前布隆过滤器只支持插入和查找操作，不支持删除操作，如果要支持删除，就要另外使用一个计数变量，每次将相应的位置为1则计数加一，删除则减一。</p><p>布隆过滤器中哈希函数的个数需要选择。如果太多则很快所有位都置为1，如果太少会容易误报。</p><p><strong>布隆过滤器的大小以及哈希函数的个数怎么选择？</strong><br>k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率<br><img src="fig/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt></p><h4 id="（27）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"><a href="#（27）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题" class="headerlink" title="（27） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"></a>（27） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</h4><h4 id="（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"><a href="#（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）" class="headerlink" title="（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"></a>（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）</h4><pre class="line-numbers language-C++"><code class="language-C++">//评测题目: class FIFOQueue{vector<int> vec(initCap,0);int start=0,end=0;condition_variable cv;mutex m;bool flag=false;// isFull  bool enqueue(int v) {      unique_lock<mutex></mutex> lk(m);    while(flag==true) cv.wait(lk);        end=(end+1)%initCap;        vec[end]=v;        cv.notifyall();        return true;    }  }  int dequeue() {  unique_lock<mutex></mutex> lk(m);      if(start!=end){        int val = vec[start];        start=(start+1)%initCap;        flag=false;        cv.notifyall();        return val;    }else{        flag=false;        cv.notifyall();        return -1;      }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码是面试时写的，并没有运行，也许有错误，请客观参考</p><h1 id="7-智力题"><a href="#7-智力题" class="headerlink" title="7. 智力题"></a>7. 智力题</h1><h4 id="（1）-100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）"><a href="#（1）-100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）" class="headerlink" title="（1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）"></a>（1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）</h4><ul><li>（给定了楼层数和鸡蛋数的情况）二分法+线性查找  从100/2=50楼扔起，如果破了就用另一个从0扔起直到破。如果没破就从50/2=25楼扔起，重复。</li><li>动态规划<h4 id="（2）-毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠"><a href="#（2）-毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠" class="headerlink" title="（2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠"></a>（2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠</h4>用二进制的思路解决问题。2的十次方是1024，使用十只小鼠喝一次即可。方法是先将每瓶水编号，同时10个小鼠分别表示二进制中的一个位。将每瓶水混合到水瓶编号中二进制为1的小鼠对应的水中。喝完后统计，将死亡小鼠对应的位置为1，没死的置为0，根据死亡小鼠的编号确定有毒的是哪瓶水，如0000001010表示10号水有毒。<h4 id="（3）"><a href="#（3）" class="headerlink" title="（3）"></a>（3）</h4><h4 id="（4）-先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿"><a href="#（4）-先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿" class="headerlink" title="（4） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿"></a>（4） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿</h4>寻找每个回合固定的拿取模式。最后一次是我拿，那么上个回合最少剩下6本。那么只要保持每个回合结束后都剩下6的倍数，并且在这个回合中我拿的和对方拿的加起来为6（这样这个回合结束后剩下的还是6的倍数），就必胜。关键是第一次我必须先手拿（100%6=4）本（这不算在第一回合里面）。<h4 id="（5）-放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。"><a href="#（5）-放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。" class="headerlink" title="（5） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。"></a>（5） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。</h4>碰到就当没发生，继续走，相当于碰到的两个蚂蚁交换了一下身体。其实就是每个蚂蚁从当前位置一直走直到停止的总距离或者时间。<h4 id="（6）-瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶"><a href="#（6）-瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶" class="headerlink" title="（6） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶"></a>（6） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶</h4>拿走3瓶，换回1瓶，相当于减少2瓶。但是最后剩下4瓶的时候例外，这时只能换1瓶。所以我们计算1000减2能减多少次，直到剩下4.（1000-4=996，996/2=498）所以1000减2能减498次直到剩下4瓶，最后剩下的4瓶还可以换一瓶，所以总共是1000+498+1=1499瓶。<h4 id="（7）在24小时里面时针分针秒针可以重合几次"><a href="#（7）在24小时里面时针分针秒针可以重合几次" class="headerlink" title="（7）在24小时里面时针分针秒针可以重合几次"></a>（7）在24小时里面时针分针秒针可以重合几次</h4>24小时中时针走2圈，而分针走24圈，时针和分针重合24-2=22次，而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次<h4 id="（8）-有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？"><a href="#（8）-有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？" class="headerlink" title="（8） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？"></a>（8） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？</h4>至少2次：第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个；<br>第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个；<h4 id="（9）-有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？"><a href="#（9）-有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？" class="headerlink" title="（9） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？"></a>（9） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？</h4>砝码分组1~10，第一组拿一个，第二组拿两个以此类推。。第十组拿十个放到秤上称出克数x，则y = 550 - x，第y组就是轻的那组<h4 id="（10）生成随机数问题：给定生成1到5的随机数Rand5-，如何得到生成1到7的随机数函数Rand7-？"><a href="#（10）生成随机数问题：给定生成1到5的随机数Rand5-，如何得到生成1到7的随机数函数Rand7-？" class="headerlink" title="（10）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？"></a>（10）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？</h4>思路：由大的生成小的容易，比如由Rand7()生成Rand5()，所以我们先构造一个大于7的随机数生成函数。<br>记住下面这个式子：<pre><code>RandNN= N( RandN()-1 ) + RandN() ;// 生成1到N^2之间的随机数可以看作是在数轴上撒豆子。N是跨度/步长，是RandN()生成的数的范围长度，RandN()-1的目的是生成0到N-1的数，是跳数。后面+RandN()的目的是填满中间的空隙</code></pre>比如<code>Rand25= 5( Rand5()-1 ) + Rand5()</code>可以生成1到25之间的随机数。我们可以只要1到21（3*7）之间的数字，所以可以这么写<pre><code>int rand7(){int x=INT_MAX;while(x&gt;21){  x=5*(rand5()-1)+rand5();}return x%7+1;}</code></pre><h4 id="赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？"><a href="#赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？" class="headerlink" title="赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？"></a>赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？</h4></li><li>第一次，分成5个赛道ABCDE，每个赛道5匹马，每个赛道比赛一场，每个赛道的第12345名记为 A1,A2,A3,A4,A5  B1,B2,B3,B4,B5等等，这一步要赛5场。 </li><li>第二次，我们将每个赛道的前三名，共15匹。分成三组，然后每组进行比赛。这一步要赛3场。</li><li>第三次，我们取每组的前三名。共9匹，第一名赛道的马编号为1a,1b,1c，第二名赛道的马编号为2a,2b,2c，第三名赛道的马编号为3a,3b,3c。这时进行分析，1a表示第一名里面的第一名，绝对是所有马中的第一，所以不用再比了。2c表示第二名的三匹里头的最后一匹，3b和3c表示第三名里面的倒数两匹，不可能是所有马里面的前三名，所以也直接排除，剩下1b,1c,2a,2b,,3a，共5匹，再赛跑一次取第一第二名，加上刚筛选出来的1a就是所有马里面的最快3匹了。这一步要赛1场。</li><li>所以一共是5+3+1=9场。<h4 id="烧-香-绳子-其他-确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？"><a href="#烧-香-绳子-其他-确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？" class="headerlink" title="烧 香/绳子/其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？"></a>烧 香/绳子/其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？</h4>（说了求15分钟，没说开始的15分钟还是结束的15分钟，这里是可以求最后的15分钟）点燃一根A，同时点燃另一根B的两端，当另一根B烧完的时候就是半小时，这是再将A的另一端也点燃，从这时到A燃烧完就正好15分钟。</li></ul><h4 id="掰巧克力问题-NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）"><a href="#掰巧克力问题-NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）" class="headerlink" title="掰巧克力问题 NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）"></a>掰巧克力问题 N<em>M块巧克力，每次掰一块的一行或一列，掰成1</em>1的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）</h4><p>每次拿起一块巧克力，掰一下（无论横着还是竖着）都会变成两块，因为所有的巧克力共有N*M块，所以要掰N*M-1次，-1是因为最开始的一块是不用算进去的。</p><p>每一场辩论赛参加两个人，消失一个人，所以可以看作是每一场辩论赛减少一个人，直到最后剩下1个人，所以是1000-1=999场。</p><h1 id="8-大数据"><a href="#8-大数据" class="headerlink" title="8. 大数据"></a>8. 大数据</h1><h4 id="1-介绍一下Hadoop"><a href="#1-介绍一下Hadoop" class="headerlink" title="1. 介绍一下Hadoop"></a>1. 介绍一下Hadoop</h4><p>Hadoop是一套大数据解决方案，提供了一套分布式的系统基础架构，包括HDFS，MapReduce和YARN。</p><ul><li>HDFS提供分布式的数据存储</li><li>MapReduce负责进行数据运算 </li><li>YARN负责任务调度</li></ul><p>HDFS是主从架构的，包括namenode，secondarynamenode和datanode。datanode负责存储数据，namenode负责管理HDFS的目录树和文件元信息。<br><br>MapReduce包括jobtracker,tasktracker和client。Jobtracker负责进行资源调度和作业监控。tasktracker会周期性的通过心跳向jobtracker汇报资源使用情况。</p><h4 id="2-说一下MapReduce的运行机制"><a href="#2-说一下MapReduce的运行机制" class="headerlink" title="2. 说一下MapReduce的运行机制"></a>2. 说一下MapReduce的运行机制</h4><p>MapReduce包括输入分片、map阶段、combine阶段、shuffle阶段和reduce阶段。分布式计算框架包括client，jobtracker和tasktracker和调度器。</p><ul><li>输入分片阶段，mapreduce会根据输入文件计算分片，每个分片对应一个map任务</li><li>map阶段会根据mapper方法的业务逻辑进行计算，映射成键值对</li><li>combine阶段是在节点本机进行一个reduce，减少传输结果对带宽的占用</li><li>shuffle阶段是对map阶段的结果进行分区，排序，溢出然后写入磁盘。将map端输出的无规则的数据整理成为有一定规则的数据，方便reduce端进行处理，有点像洗牌的逆过程。  <a href="https://blog.csdn.net/ASN_forever/article/details/81233547" target="_blank" rel="noopener">https://blog.csdn.net/ASN_forever/article/details/81233547</a></li><li>reduce阶段是根据reducer方法的业务逻辑进行计算，最终结果会存在hdfs上。</li></ul><h4 id="3-介绍一下kafka"><a href="#3-介绍一下kafka" class="headerlink" title="3. 介绍一下kafka"></a>3. 介绍一下kafka</h4><p><a href="https://blog.csdn.net/qq_29186199/article/details/80827085" target="_blank" rel="noopener">https://blog.csdn.net/qq_29186199/article/details/80827085</a></p><p><a href="https://blog.csdn.net/student__software/article/details/81486431" target="_blank" rel="noopener">https://blog.csdn.net/student__software/article/details/81486431</a></p><p>kafka是一个分布式消息队列，包括producer、broker和consumer。kafka会对每个消息根据topic进行归类，每个topic又会分成多个partition，消息会根据先进先出的方式存储。消费者通过offset进行消费。 </p><p>kafka的特点是吞吐量高，可以进行持久化，高可用。</p><h4 id="4-为什么kafka吞吐量高？-介绍一下零拷贝"><a href="#4-为什么kafka吞吐量高？-介绍一下零拷贝" class="headerlink" title="4. 为什么kafka吞吐量高？/介绍一下零拷贝"></a>4. 为什么kafka吞吐量高？/介绍一下零拷贝</h4><p>kafka吞吐量高是因为一个利用了磁盘顺序读写的特性，速度比随机读写要快很多，另一个是使用了零拷贝，数据直接在内核进行输入和输出，减少了用户空间和内核空间的切换。</p><p>零拷贝：传统文件读取并发送至网络的步骤是：先将文件从磁盘拷贝到内核空间，然后内核空间拷贝到用户空间的缓冲区，再从用户空间拷贝到内核空间的socket缓冲区，最后拷贝到网卡并发送。而零拷贝技术是先将文件从磁盘空间拷贝到内核缓冲区，然后直接拷贝至网卡进行发送，减少了重复拷贝操作。</p><h4 id="5-介绍一下spark"><a href="#5-介绍一下spark" class="headerlink" title="5. 介绍一下spark"></a>5. 介绍一下spark</h4><p><a href="https://blog.csdn.net/u011204847/article/details/51010205" target="_blank" rel="noopener">https://blog.csdn.net/u011204847/article/details/51010205</a></p><p>spark是一个通用内存并行计算框架。它可以在内存中对数据进行计算，效率很高，spark的数据被抽象成RDD（弹性分布式数据集）并且拥有DAG执行引擎，兼容性和通用性很好。可以和Hadoop协同工作。</p><h4 id="6-介绍一下spark-streaming"><a href="#6-介绍一下spark-streaming" class="headerlink" title="6. 介绍一下spark-streaming"></a>6. 介绍一下spark-streaming</h4><p><a href="https://blog.csdn.net/yu0_zhang0/article/details/80569946" target="_blank" rel="noopener">https://blog.csdn.net/yu0_zhang0/article/details/80569946</a></p><p>spark-streaming是spark的核心组件之一。主要提供高效的流计算能力。spark-streaming的原理是将输入数据流以时间片进行拆分，然后经过spark引擎以类似批处理的方式处理每个时间片数据。</p><p>spark-streaming将输入根据时间片划分成一段一段的Dstream（也就是离散数据流），然后将每一段数据转换成RDD进行操作。 </p><h4 id="7-spark的transformation和action有什么区别"><a href="#7-spark的transformation和action有什么区别" class="headerlink" title="7. spark的transformation和action有什么区别"></a>7. spark的transformation和action有什么区别</h4><p>spark的算子分成transformation和action两类</p><ul><li>transformation是变换算子，这类算子不会触发提交，是延迟执行的。也就是说执行到transformation算子的时候数据并没有马上进行计算，只是记住了对RDD的逻辑操作 </li><li>action算子是执行算子，会出发spark提交作业，并将数据输出到spark<h4 id="8-spark常用的算子说几个"><a href="#8-spark常用的算子说几个" class="headerlink" title="8. spark常用的算子说几个"></a>8. spark常用的算子说几个</h4>spark的算子分为两类：transformation和action</li></ul><p>常用的transformation算子：</p><pre class="line-numbers language-scala"><code class="language-scala"><span class="token comment" spellcheck="true">// union 求并集</span><span class="token keyword">val</span> rdd8 <span class="token operator">=</span> rdd6<span class="token punctuation">.</span>union<span class="token punctuation">(</span>rdd7<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// intersection 求交集 </span><span class="token keyword">val</span> rdd9 <span class="token operator">=</span> rdd6<span class="token punctuation">.</span>intersection<span class="token punctuation">(</span>rdd7<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// join 将rdd进行聚合连接，类似数据库的join </span><span class="token keyword">val</span> rdd3 <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>join<span class="token punctuation">(</span>rdd2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// map flatMap mapPartition 传入一个函数对数据集中的每一个数据进行操作 </span><span class="token keyword">val</span> arr1 <span class="token operator">=</span> Array<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">val</span> arr2 <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// countByKey reduceByKey partitionByKey 统计每个key有多少个键值对 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常用的action算子</p><pre class="line-numbers language-scala"><code class="language-scala"><span class="token comment" spellcheck="true">// reduce 按照一定的方法将元素进行合并 </span><span class="token keyword">val</span> rdd2 <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>reduce<span class="token punctuation">(</span>_<span class="token operator">+</span>_<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// collect 将RDD转换为数组</span>rdd1<span class="token punctuation">.</span>collect<span class="token comment" spellcheck="true">// top 返回最大的k个元素</span>rdd1<span class="token punctuation">.</span>top<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="9-如何保证kafka的消息不丢失"><a href="#9-如何保证kafka的消息不丢失" class="headerlink" title="9. 如何保证kafka的消息不丢失"></a>9. 如何保证kafka的消息不丢失</h4><p><a href="https://blog.csdn.net/liudashuang2017/article/details/88576274" target="_blank" rel="noopener">https://blog.csdn.net/liudashuang2017/article/details/88576274</a></p><p>我们可以从三个方面保证kafka不丢失消息</p><ul><li>首先从producer生产者方面，为send()方法注册一个回调函数，可以得知消息发送有没有成功；将重试次数retrie设置为3；设置acks参数为all，当消息被写入所有同步副本之后才算发送成功。</li><li>在consumer消费者方面，关闭自动提交；</li><li>在broker集群方面，设置复制系数replica.factor为大于等于3<h4 id="10-kafka如何选举leader"><a href="#10-kafka如何选举leader" class="headerlink" title="10. kafka如何选举leader"></a>10. kafka如何选举leader</h4>首先启动的broker在zookeeper中创建一个临时节点并让自己称为leader，其他的节点会创建watch对象进行监听并成为follower，当broker宕机的时候，其他follower会尝试创建这个临时节点，但是只有一个能够创建成功，创建成功的broker就会成为leader。</li></ul><h4 id="11-说下spark中的宽依赖和窄依赖"><a href="#11-说下spark中的宽依赖和窄依赖" class="headerlink" title="11. 说下spark中的宽依赖和窄依赖"></a>11. 说下spark中的宽依赖和窄依赖</h4><p><a href="https://blog.csdn.net/a1043498776/article/details/54889922" target="_blank" rel="noopener">https://blog.csdn.net/a1043498776/article/details/54889922</a></p><ul><li>宽依赖：指子RDD的分区依赖于父RDD的所有分区，举例：groupbykey,join</li><li>窄依赖：指父RDD的每个分区被最多一个子RDD的分区所依赖,举例：map，filter<br><img src="https://img-blog.csdn.net/20170206221148299?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEwNDM0OTg3NzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt><h4 id="12-说下spark中stage是依照什么划分的"><a href="#12-说下spark中stage是依照什么划分的" class="headerlink" title="12. 说下spark中stage是依照什么划分的"></a>12. 说下spark中stage是依照什么划分的</h4><a href="https://zhuanlan.zhihu.com/p/57124273" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57124273</a></li></ul><p>spark中的stage其实是一组并行的任务，spark会将多个RDD根据依赖关系划分成有向无环图DAG，DAG会被划分成多个stage，划分的依据是RDD之间的宽窄依赖。遇到宽依赖就划分stage。因为宽依赖与窄依赖的区别之一就是宽依赖会发生shuffle操作，所以也可以说stage的划分依据是是否发生shuffle操作。</p><h4 id="13-spark的内存管理是怎样的"><a href="#13-spark的内存管理是怎样的" class="headerlink" title="13. spark的内存管理是怎样的"></a>13. spark的内存管理是怎样的</h4><p><a href="https://www.jianshu.com/p/4f1e551553ae" target="_blank" rel="noopener">https://www.jianshu.com/p/4f1e551553ae</a> </p><p><a href="https://www.cnblogs.com/wzj4858/p/8204282.html" target="_blank" rel="noopener">https://www.cnblogs.com/wzj4858/p/8204282.html</a></p><p>spark的内存包括静态内存管理和统一内存管理两种机制。静态内存管理中存储和执行两块内存区域是分开的，统一内存管理中两块内存之间可以相互借用<br></p><ul><li>静态内存管理：静态内存管理机制下堆内内存包括安全内存，存储内存，shuffle内存和unroll内存</li></ul><p><img src="fig/spark%E5%86%85%E5%AD%98%E4%B8%80.png" alt></p><ul><li>统一内存管理：统一内存管理机制下内存分为spark内存，用户内存和保留内存三部分。用户内存存放用户代码逻辑和自定义数据结构等，保留内存存放的是spark的内部对象和逻辑。<br><img src="https://upload-images.jianshu.io/upload_images/195230-f119edabb5683f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt></li></ul><h4 id="14-spark的容错机制是什么样的"><a href="#14-spark的容错机制是什么样的" class="headerlink" title="14. spark的容错机制是什么样的"></a>14. spark的容错机制是什么样的</h4><p><a href="https://blog.csdn.net/dengxing1234/article/details/73613484" target="_blank" rel="noopener">https://blog.csdn.net/dengxing1234/article/details/73613484</a></p><p>spark的容错机制是通过血统（lineage）和checkpoint来实现的 。</p><ul><li>RDD的lineage可以看作是一个重做日志（redo log）记录的是它粗粒度上的transformation操作。当rdd的分区数据丢失时，它可以根据lineage重新计算来恢复数据。 在窄依赖上可以直接计算父RDD的节点数据进行恢复，在宽依赖上则要等到父RDD所有数据计算完后并将结果shuffle到子RDD上才能完成恢复。</li><li>如果DAG中的lineage过长，或者在宽依赖上进行checkpoint的收益更大，就会使用checkpoint进行容错，将RDD写入磁盘进行持久化存储，如果节点数据丢失，就从磁盘读取数据进行恢复。</li></ul><h1 id="9-HR面"><a href="#9-HR面" class="headerlink" title="9. HR面"></a>9. HR面</h1><h4 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h4><p>（HR面试的自我介绍可以侧重软实力部分，项目技术方面介绍可以适当少一些）</p><h4 id="2-项目中遇到的最大难点"><a href="#2-项目中遇到的最大难点" class="headerlink" title="2. 项目中遇到的最大难点"></a>2. 项目中遇到的最大难点</h4><ul><li><p>在项目中曾经遇到了新的框架不知道该如何上手的问题，以及面对新的概念，新的技术不知道从何学起。解决的办法是在官网寻找说明文档和demo，按照说明文档上的内容一步步了解，以及咨询身边有用过这个框架的同学，或者在CSDN上寻找相关博客。</p></li><li><p>项目的时间比较紧迫，没有那么多的时间可以用。解决方法是把还没有完成的项目分一个轻重缓急，在有限的时间里，先做重要而且紧急的，然后完成紧急的，再做重要的。利用轻重缓急做一个取舍。</p><h4 id="3-项目中的收获"><a href="#3-项目中的收获" class="headerlink" title="3. 项目中的收获"></a>3. 项目中的收获</h4><p>一个是了解了相关框架的使用方法（比如Dataframe的使用，xgboost的使用等等），这些框架或者技术可以在以后的开发中使用到。和对自己开发能力的锻炼。</p></li></ul><p>一个是锻炼了与他人的交流能力，因为在团队项目里经常会跟别人汇报自己的想法和进度，同时也会跟其他成员沟通模块之间的交互，所以在这个过程中对自己的表达能力和理解能力都是一个很大的提升。</p><h4 id="4-可以实习的时间，实习时长"><a href="#4-可以实习的时间，实习时长" class="headerlink" title="4. 可以实习的时间，实习时长"></a>4. 可以实习的时间，实习时长</h4><p>一定要往长了说！半年起步，最好七八个月，因为实习生是可以随时跑路的。而且实习时间越长HR越青睐。</p><h4 id="5-哪里人"><a href="#5-哪里人" class="headerlink" title="5. 哪里人"></a>5. 哪里人</h4><h4 id="6-说一下自己的性格"><a href="#6-说一下自己的性格" class="headerlink" title="6. 说一下自己的性格"></a>6. 说一下自己的性格</h4><p>我是比较内向谨慎的人，平时做的多说的少。比较善于总结，在与人交流的时候更倾向于倾听别人的意见后才发言。并且别人都说我办事认真靠谱。</p><h4 id="7-你的优缺点是什么"><a href="#7-你的优缺点是什么" class="headerlink" title="7. 你的优缺点是什么"></a>7. 你的优缺点是什么</h4><p>我的缺点是容易在一些细节的地方花费太多的时间，有时候过分追求细节。并且我的实习经验比较缺乏，对于实际项目的业务流程和工作流程不是很了解。（所以我打算通过实习来熟悉实际的软件开发的流程和技术。）</p><p>我的优点是责任心比较强，做事比较负责，在校期间我负责的大创项目进展很顺利，我经常组织组员们进行讨论和推进项目的开发，最后这个项目得到了92的评分，在同级别里面是比较高的。</p><h4 id="8-有什么兴趣爱好，画的怎么样-球打的如何-游戏打的怎么样"><a href="#8-有什么兴趣爱好，画的怎么样-球打的如何-游戏打的怎么样" class="headerlink" title="8. 有什么兴趣爱好，画的怎么样/球打的如何/游戏打的怎么样"></a>8. 有什么兴趣爱好，画的怎么样/球打的如何/游戏打的怎么样</h4><p>平时的爱好是画画打游戏，在CSDN写写博客，还有就是看书，我很喜欢学到新知识掌握新技能的感觉。</p><h4 id="9-看过最好的一本书是什么"><a href="#9-看过最好的一本书是什么" class="headerlink" title="9. 看过最好的一本书是什么"></a>9. 看过最好的一本书是什么</h4><p>技术类：编程之美 机器学习西瓜书 STL源码剖析 剑指offer C++primer plus</p><p>非技术类：明朝那些事儿 香水（聚斯金德） 解忧杂货店 人类简史 沉默的大多数 与时间做朋友（李笑来） 千年历史千年诗</p><h4 id="10-学习技术中有什么难点"><a href="#10-学习技术中有什么难点" class="headerlink" title="10. 学习技术中有什么难点"></a>10. 学习技术中有什么难点</h4><h4 id="11-怎么看待加班"><a href="#11-怎么看待加班" class="headerlink" title="11. 怎么看待加班"></a>11. 怎么看待加班</h4><p>我觉得 任何一家单位都有可能要加班。如果自己的工作没有按时完成，那自觉加班是理所当然的，当然，自己要不断提高工作效率，避免这种原因导致的加班。如果遇到紧急任务或者突发状况时，为了顺利配合团队完成任务，我会尽自己所能加班共同完成。</p><h4 id="12-觉得深圳怎么样（或者其他地点）"><a href="#12-觉得深圳怎么样（或者其他地点）" class="headerlink" title="12. 觉得深圳怎么样（或者其他地点）"></a>12. 觉得深圳怎么样（或者其他地点）</h4><h4 id="13-遇见过最大的挫折是什么，怎么解决的"><a href="#13-遇见过最大的挫折是什么，怎么解决的" class="headerlink" title="13. 遇见过最大的挫折是什么，怎么解决的"></a>13. 遇见过最大的挫折是什么，怎么解决的</h4><h4 id="14-职业规划"><a href="#14-职业规划" class="headerlink" title="14. 职业规划"></a>14. 职业规划</h4><p>在工作的第一个阶段，先尽快适应工作的环境，包括开发环境开发工具和工作流程等，把自己负责的部分快速的完成，不能出差错。第二个阶段要熟悉整个项目的业务流程，所有模块的结构和依赖关系，知道每个模块为什么要这么设计，以及它们的实现细节。第三个阶段要培养独立设计一个项目的能力，可以独立或者在别人的协作下设计项目的模块分工和架构。</p><p>在工作和项目中多写博客或者笔记，积累技术影响力，将经验总结成文档。同时与同事搞好关系，尝试培养领导能力和组织能力。</p><h4 id="15-目前的offer情况"><a href="#15-目前的offer情况" class="headerlink" title="15. 目前的offer情况"></a>15. 目前的offer情况</h4><p>可以如实说</p><h4 id="16-你最大的优势和劣势是什么"><a href="#16-你最大的优势和劣势是什么" class="headerlink" title="16. 你最大的优势和劣势是什么"></a>16. 你最大的优势和劣势是什么</h4><ul><li>优势：做事情有主动性，不拖沓，有责任心。举个例子：在做论文课题的时候，几乎都是我自己找老师汇报进度和找老师讨论问题，很少有被老师催的时候。每一次跟老师讨论之后都会将讨论的内容和老师提出的意见进行详细记录。在中软杯的比赛中，主动承担答辩ppt的制作，并且每次排练之后都迅速对ppt的修改意见进行落实修改，前前后后改了十几版。</li><li>劣势：有时候做事情比较急躁，容易导致粗心。<h4 id="17-介绍在项目里面充当的角色"><a href="#17-介绍在项目里面充当的角色" class="headerlink" title="17. 介绍在项目里面充当的角色"></a>17. 介绍在项目里面充当的角色</h4><h4 id="18-介绍一下本科获得的全国赛奖项的情况"><a href="#18-介绍一下本科获得的全国赛奖项的情况" class="headerlink" title="18. 介绍一下本科获得的全国赛奖项的情况"></a>18. 介绍一下本科获得的全国赛奖项的情况</h4><h4 id="19-最有成就感的事情-最骄傲的一件事情"><a href="#19-最有成就感的事情-最骄傲的一件事情" class="headerlink" title="19. 最有成就感的事情/最骄傲的一件事情"></a>19. 最有成就感的事情/最骄傲的一件事情</h4></li><li>本科的时候跟优秀的队友们一起参加中国软件杯比赛努力了四个月，最后获得了该赛题的第一名和全国一等奖的好成绩</li><li>保研夏令营拿到了四个学校的offer<h4 id="20-在实验室中担任什么角色，参加的XXX能聊聊吗"><a href="#20-在实验室中担任什么角色，参加的XXX能聊聊吗" class="headerlink" title="20. 在实验室中担任什么角色，参加的XXX能聊聊吗"></a>20. 在实验室中担任什么角色，参加的XXX能聊聊吗</h4><h4 id="22-用两个词来形容自己"><a href="#22-用两个词来形容自己" class="headerlink" title="22. 用两个词来形容自己"></a>22. 用两个词来形容自己</h4>踏实 认真</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统</title>
      <link href="/2020/08/29/ji-suan-ji-ji-chu/ji-suan-ji-cao-zuo-xi-tong/"/>
      <url>/2020/08/29/ji-suan-ji-ji-chu/ji-suan-ji-cao-zuo-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="进程死锁"><a href="#进程死锁" class="headerlink" title="进程死锁"></a>进程死锁</h1><blockquote><p>张三拿着语文课本。他学完语文课本后需要数学课本（有人归还数学课本后他才能学数学）；<br>李四拿着数学课本。他学完数学课本后需要语文课本（有人归还语文课本后他才能学语文）。<br>张三等待李四归还数学课本，李四等待张三归还语文课本。他们等啊等，一直都等不到自己想要的书。因而两个人都永远卡在那里无法前进</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>有两个进程 A 和 B ，各自在加锁的状态下运行。A 持有一部分资源，并且等待 B 线程中的资源以完成自己的工作，而此时 B 也在等待 A 中的资源以完成自己的工作。由于他们都是锁定状态，所以他们必须完成了自己的工作后，自己持有的资源才能释放。于是进程无休止地等待，导致死锁。<br>（死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。）</p><h2 id="产生死锁的的四个条件"><a href="#产生死锁的的四个条件" class="headerlink" title="产生死锁的的四个条件"></a>产生死锁的的四个条件</h2><ol><li><p>互斥条件：一个资源每次只能被一个进程使用；（语文数学课本只各有一本）</p></li><li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；（张三没有拿到数学课本前，不会归还语文课本，李四同理）</p></li><li><p>不剥夺条件：进程已获得的资源，在没使用完之前，不能强行剥夺，只能在使用完时由自己释放；（两个人不能互相抢）</p></li><li><p>循环等待条件：多个进程之间形成一种互相循环等待资源的关系。（张三等李四，李四等张三）</p><ul><li>指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li></ul></li></ol><h2 id="如何破坏死锁？"><a href="#如何破坏死锁？" class="headerlink" title="如何破坏死锁？"></a>如何破坏死锁？</h2><p>破坏上述中任一条件即可</p><ol><li>破坏互斥条件：改造独占性资源为虚拟资源<del>，但大部分资源已无法改造</del></li><li>破坏请求与保持条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源</li><li>破坏不剥夺条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请</li><li>破坏循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源</li></ol><h2 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h2><ul><li>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</li><li>死锁恢复：利用抢占恢复；利用回滚恢复；通过杀死进程恢复。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>200. 岛屿数量</title>
      <link href="/2020/08/29/leetcode/200-dao-yu-shu-liang/"/>
      <url>/2020/08/29/leetcode/200-dao-yu-shu-liang/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></p><p>利用dfs深度优先搜索解决：</p><ul><li>心里先想象出一棵搜索树</li><li>在节点处判断：<ul><li>如果满足条件：该节点没有超过二维数组范围且是岛屿（用1表示），则把该点置为水（用0表示）以避免重复搜索。并在此节点的基础上，继续向搜索树下面（下面的选择有上下左右四个分支）搜索</li><li>若不满足条件，则返回</li></ul></li><li>一开始时，搜索树的入口：grid[i][j]处若为1，则进入搜索树。用count来计数，每进入一次树，count+=1</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># gird[i][j] 点若是岛屿，则把该点置0，避免后续重复搜索到。然后从该点的上下左右继续搜</span>            <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span>  grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span>                dfs<span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span>        count <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 每进入一次搜索树，cont+=1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 搜索树的入口</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                    dfs<span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>                    count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章：计算机网络</title>
      <link href="/2020/08/28/labuladong/di-liu-zhang-ji-suan-ji-wang-luo/"/>
      <url>/2020/08/28/labuladong/di-liu-zhang-ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<p><a href="https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men" target="_blank" rel="noopener">labuladong 计算机网络</a></p><h1 id="25-张图解：键入网址后，到网页显示，其间发生了什么"><a href="#25-张图解：键入网址后，到网页显示，其间发生了什么" class="headerlink" title="25 张图解：键入网址后，到网页显示，其间发生了什么"></a><a href="https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/25-zhang-tu-jie-jian-ru-wang-zhi-hou-dao-wang-ye-xian-shi-qi-jian-fa-sheng-le-shi-mo#01-gu-dan-xiao-di-http" target="_blank" rel="noopener">25 张图解：键入网址后，到网页显示，其间发生了什么</a></h1><h2 id="解答："><a href="#解答：" class="headerlink" title="解答："></a><a href="https://blog.csdn.net/kongmin_123/article/details/82555936" target="_blank" rel="noopener">解答：</a></h2><ul><li>DNS域名解析<ul><li><strong>查询服务器域名对应的 IP 地址</strong>。因为委托操作系统发送消息时，必须提供通信对象的 IP 地址</li><li>DNS 中的域名都是用句点来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的界限。在域名中，越靠右的位置表示其层级越高</li></ul></li><li>浏览器得到了IP以后，向服务器发送TCP连接<ul><li>TCP 连接的过程，通常称为三次握手，目的是<strong>保证双方都有发送和接收的能力</strong>。</li></ul></li><li>浏览器发送HTTP请求<ul><li>浏览器和服务器建立连接以后，浏览器接着按这个IP地址给服务器发送一个http请求，方式为get，例如访问<code>www.baidu.com</code>。其本质是在建立起的TCP连接中，按照HTTP协议标准<strong>发送一个索要网页的请求</strong></li></ul></li><li>服务器处理请求<ul><li>服务器（经过物理层→数据链路层→网络层→传输层→应用层）收到浏览器的请求以后，会解析这个请求（读请求头），然后生成一个响应头和具体响应内容。接着服务器会传回来一个响应头和一个响应，响应头告诉了浏览器一些必要的信息 </li></ul></li><li>浏览器解析渲染页面</li><li>关闭TCP连接，即TCP的四次挥手<br><img src="https://img-blog.csdnimg.cn/20200828163409378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></li></ul><h1 id="30张图解：HTTP常见面试题"><a href="#30张图解：HTTP常见面试题" class="headerlink" title="30张图解：HTTP常见面试题"></a><a href="https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/30-zhang-tu-jie-http-chang-jian-mian-shi-ti" target="_blank" rel="noopener">30张图解：HTTP常见面试题</a></h1><h2 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h2><ul><li>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」，是一个<strong>双向协议</strong>。</li></ul><h2 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h2><ul><li>GET 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等</li><li>POST 方法则是相反操作，它向 URI <strong>指定的资源提交数据</strong>，数据就放在报文的 body 里</li><li>GET 方法就是<strong>安全且幂等</strong>的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以<strong>不是幂等的</strong></li></ul><h2 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h2><ul><li>HTTP 是超文本传输协议，信息是明文传输，<strong>存在安全风险</strong>的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 <strong>TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议</strong>，使得报文能够加密传输<ul><li>HTTPS 实现了<strong>信息加密，校验机制，身份证书</strong>等功能，使传输更安全</li></ul></li><li>HTTP 连接建立相对简单， <strong>TCP 三次握手之后便可进行 HTTP 的报文传输</strong>。而 HTTPS 在 TCP 三次握手之后，<strong>还需进行 SSL/TLS 的握手过程</strong>，才可进入加密报文传输</li><li>HTTP 的端口号是 80，HTTPS 的端口号是 443</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li></ul><p><img src="https://img-blog.csdnimg.cn/20200828162303211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><h2 id="HTTPS-是如何解决HTTP的窃听，冒充，篡改等风险的？"><a href="#HTTPS-是如何解决HTTP的窃听，冒充，篡改等风险的？" class="headerlink" title="HTTPS 是如何解决HTTP的窃听，冒充，篡改等风险的？"></a>HTTPS 是如何解决HTTP的窃听，冒充，篡改等风险的？</h2><ul><li><strong>混合加密</strong>的方式实现信息的机密性，解决了窃听的风险</li><li>将<strong>服务器公钥放入到数字证书</strong>中，解决了冒充的风险</li><li><strong>摘要算法的方式</strong>来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险</li></ul><h1 id="30张图解：TCP重传、滑动窗口、流量控制、拥塞控制"><a href="#30张图解：TCP重传、滑动窗口、流量控制、拥塞控制" class="headerlink" title="30张图解：TCP重传、滑动窗口、流量控制、拥塞控制"></a><a href="https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/30-zhang-tu-jie-tcp-zhong-chuan-hua-dong-chuang-kou-liu-liang-kong-zhi-yong-sai-kong-zhi-fa-chou" target="_blank" rel="noopener">30张图解：TCP重传、滑动窗口、流量控制、拥塞控制</a></h1><h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息<br><img src="https://img-blog.csdnimg.cn/20200828170035866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br>但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？<br>所以 TCP 针对数据包丢失的情况，会用重传机制解决：<br>    1.    超时重传 ：当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据<br>    2.    快速重传：不以时间为驱动，而是以<strong>数据</strong>驱动重传。但是这样的话，发送方不知道哪些数据收到了，哪些没收到<br>    3.    SACK（ Selective Acknowledgment 选择性确认）: 可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据<br>    4.    Duplicate-SACK：使用了 SACK 来告诉「发送方」有哪些数据被重复接收了</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul><li><p>TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。但这样的话，<strong>数据包的往返时间越长，通信的效率就越低</strong>。所以用滑动窗口解决该问题。窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>（TCP窗口的最大值为2的16次方，即65535字节）</p></li><li><p>TCP 头里有一个字段叫 Window，也就是窗口大小。这个字段是<strong>接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</p></li><li><p>流量控制</p><ul><li>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果对方处理不过来，那么就会导致触发重发机制，浪费资源</li><li>TCP 提供一种机制可以让「发送方」根据「接收方」的<strong>实际接收能力控制发送的数据量</strong>，这就是所谓的<strong>流量控制</strong></li></ul></li><li><p>拥塞控制</p><ul><li>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</li><li>于是，就有了拥塞控制，控制的目的就是<strong>避免「发送方」的数据填满整个网络</strong>。 拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的</li></ul></li></ul><h1 id="40张图解：TCP三次握手和四次挥手面试题"><a href="#40张图解：TCP三次握手和四次挥手面试题" class="headerlink" title="40张图解：TCP三次握手和四次挥手面试题"></a><a href="https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/40-zhang-tu-jie-tcp-san-ci-wo-shou-he-si-ci-hui-shou-mian-shi-ti" target="_blank" rel="noopener">40张图解：TCP三次握手和四次挥手面试题</a></h1><h2 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a>TCP 和 UDP 区别</h2><ul><li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）</li><li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信</li></ul><ol><li>连接<br>TCP 是面向连接的传输层协议，传输数据前先要建立连接。<br>UDP 是不需要连接，即刻传输数据。</li><li>服务对象<br>TCP 是一对一的两点服务，即一条连接只有两个端点。<br>UDP 支持一对一、一对多、多对多的交互通信</li><li>可靠性<br>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。<br>UDP 是尽最大努力交付，不保证可靠交付数据。</li><li>拥塞控制、流量控制<br>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。<br>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li><li>首部开销<br>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。<br>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li><li>传输方式<br>TCP 是流式传输，没有边界，但保证顺序和可靠。<br>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li><li>分片不同<br>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。<br>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，则就需要重传所有的数据包，这样传输效率非常差，所以通常 UDP 的报文应该小于 MTU。</li></ol><h2 id="TCP-和-UDP-应用场景"><a href="#TCP-和-UDP-应用场景" class="headerlink" title="TCP 和 UDP 应用场景"></a>TCP 和 UDP 应用场景</h2><ul><li>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</li></ul><ol><li>FTP 文件传输</li><li>HTTP / HTTPS</li></ol><ul><li>由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</li></ul><ol><li>包总量较少的通信，如 DNS 、SNMP 等</li><li>视频、音频等多媒体通信</li><li>广播通信</li></ol><h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><p><strong>第三次握手是可以携带数据的</strong>，前两次握手是不可以携带数据的<br><img src="https://img-blog.csdnimg.cn/20200828193854391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><h2 id="TCP为什么是三次握手？"><a href="#TCP为什么是三次握手？" class="headerlink" title="TCP为什么是三次握手？"></a>TCP为什么是三次握手？</h2><ul><li>（因为三次握手才能保证双方具有接收和发送的能力）</li><li><strong>三次握手才可以阻止重复历史连接的初始化（主要原因）</strong><ul><li>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵情况下：<ul><li>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；那么此时服务端就会回一个 SYN + ACK 报文给客户端；客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。</li></ul></li><li>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：<ul><li>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 RST 报文，以此中止历史连接；<br>如果不是历史连接，则第三次发送的报文是 ACK 报文，通信双方就会成功建立连接</li></ul></li></ul></li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul><h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p><img src="https://img-blog.csdnimg.cn/20200828203712197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><h2 id="TCP-为什么是四次挥手？"><a href="#TCP-为什么是四次挥手？" class="headerlink" title="TCP 为什么是四次挥手？"></a>TCP 为什么是四次挥手？</h2><ul><li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了<strong>但是还能接收数据</strong></li><li>服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，<strong>而服务端可能还有数据需要处理和发送</strong>，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接</li></ul><h1 id="45张图解：IP基础知识全家桶"><a href="#45张图解：IP基础知识全家桶" class="headerlink" title="45张图解：IP基础知识全家桶"></a><a href="https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/45-zhang-tu-jie-ip-ji-chu-zhi-shi-quan-jia-tong" target="_blank" rel="noopener">45张图解：IP基础知识全家桶</a></h1><h2 id="IP的基本认识"><a href="#IP的基本认识" class="headerlink" title="IP的基本认识"></a>IP的基本认识</h2><ul><li><p>IP 在 TCP/IP 参考模型中处于第三层，也就是<strong>网络层</strong>。网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信。</p></li><li><p>MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。</p></li></ul><p><strong>IP</strong>：整个旅游行程表就<strong>相当于网络层</strong>，充当远程定位的功能，<strong>行程的开始好比源 IP，行程的终点好比目的 IP 地址</strong>。<br><strong>MAC</strong>：在区间内移动相当于<strong>数据链路层</strong>，充当<strong>区间内两个节点传输</strong>的功能，区间内的出发点好比源 MAC 地址，目标地点好比目的 MAC 地址<br><img src="https://img-blog.csdnimg.cn/20200828205359161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><h2 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h2><p>对于 A、B、C 类主要分为两个部分，分别是网络号和主机号<br><img src="https://img-blog.csdnimg.cn/20200828230539759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br><img src="https://img-blog.csdnimg.cn/20200828232212201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br>主机号全为 1 指定某个网络下的所有主机，用于广播<br>主机号全为 0 指定某个网络</p><h2 id="无分类地址-CIDR及子网掩码"><a href="#无分类地址-CIDR及子网掩码" class="headerlink" title="无分类地址 CIDR及子网掩码"></a>无分类地址 CIDR及子网掩码</h2><p><img src="https://img-blog.csdnimg.cn/20200828232734141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br><img src="https://img-blog.csdnimg.cn/20200828232841700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br><img src="https://img-blog.csdnimg.cn/20200828233219102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br>由于子网网络地址被划分成 2 位，那么子网地址就有 4 个，分别是 00、01、10、11。<img src="https://img-blog.csdnimg.cn/20200828233357342.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br><img src="https://img-blog.csdnimg.cn/20200828233433874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><h2 id="公有-IP-地址与私有-IP-地址"><a href="#公有-IP-地址与私有-IP-地址" class="headerlink" title="公有 IP 地址与私有 IP 地址"></a>公有 IP 地址与私有 IP 地址</h2><p><img src="https://img-blog.csdnimg.cn/20200828233532502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><h2 id="IPV4-和IPV6"><a href="#IPV4-和IPV6" class="headerlink" title="IPV4 和IPV6"></a>IPV4 和IPV6</h2><ul><li>IPv4 的地址是 <strong>32 位</strong>的，大约可以提供 42 亿个地址。但是 IPv6 的地址是 <strong>128 位</strong>的，这可分配的地址数量是大的惊人，说个段子 IPv6 可以保证地球上的每粒沙子都能被分配到一个 IP 地址</li><li>IPv6 除了有更多的地址之外，还有更好的安全性和扩展性，说简单点就是 IPv6 相比于 IPv4 能带来更好的网络体验。<ul><li>IPv6 可自动配置，即使没有 DHCP 服务器也可以<strong>实现自动分配IP地址</strong></li><li>IPv6 包头包首部长度采用固定的值 40 字节，去掉了包头校验和，简化了首部结构，<strong>减轻了路由器负荷，大大提高了传输的性能</strong>。</li><li>IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，<strong>大大提升了安全性</strong><br><img src="https://img-blog.csdnimg.cn/20200829125751727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></li></ul></li></ul><h2 id="ARP-（Address-Resolution-Protocol，地址解析协议）"><a href="#ARP-（Address-Resolution-Protocol，地址解析协议）" class="headerlink" title="ARP （Address Resolution Protocol，地址解析协议）"></a>ARP （Address Resolution Protocol，地址解析协议）</h2><p><img src="https://i.loli.net/2020/08/29/GWgYKVaB5NJCu6I.png" alt="20200829232021"></p><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><p>ARP 实现由 IP 地址得到 MAC 地址。</p><ul><li>在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下一跳。然而，网络层的下一层是数据链路层，而链路层实现具体每段链路之间的通信。<strong>所以我们还要知道「下一跳」的 MAC 地址</strong>。</li><li>由于主机的路由表中可以找到下一跳的 IP 地址，所以可以通过 ARP 协议，求得下一跳的 MAC 地址。</li></ul><p>ARP 是借助 ARP 请求与 ARP 响应两种类型的包确定 MAC 地址的：</p><ul><li>主机会<strong>通过广播发送 ARP 请求</strong>，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li><li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就<strong>将自己的 MAC 地址塞入 ARP 响应包</strong>返回给主机。<br><img src="https://img-blog.csdnimg.cn/20200829131607551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python字典常用操作</title>
      <link href="/2020/08/25/python/python-zi-dian-chang-yong-cao-zuo/"/>
      <url>/2020/08/25/python/python-zi-dian-chang-yong-cao-zuo/</url>
      
        <content type="html"><![CDATA[<ol><li>普通字典</li></ol><p><a href="https://www.runoob.com/python/python-dictionary.html" target="_blank" rel="noopener">常用的字典操作</a></p><ul><li>字典按键或值排序</li></ul><pre class="line-numbers language-python"><code class="language-python">d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 按键排序</span>d_k <span class="token operator">=</span> sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d_k<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [(1, 2), (2, 1), (3, 4), (5, 3)]</span><span class="token comment" spellcheck="true"># 按值排序</span>d_v <span class="token operator">=</span> sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#取出排序后的键</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> d_k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [1, 2, 3, 5]</span><span class="token comment" spellcheck="true"># 把键按空格输出</span>res<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span><span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> d_k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 取出排序后的值</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> d_k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [2, 1, 4, 3]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>defaultdict 字典</li></ol><p><a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" target="_blank" rel="noopener">常用的defaultdict字典操作</a></p><p>defaultdict接受一个工厂函数作为参数：<code>dict =defaultdict( factory_function)</code>. 这个factory_function可以是list、set、str、int等等。作用<strong>是当key不存在时，返回的是工厂函数的默认值</strong>。比如list对应[ ]，str对应的是空字符串，set对应set( )，int对应0</p><ul><li>取出字典中的信息</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> collectionss <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>d <span class="token operator">=</span> collections<span class="token punctuation">.</span>defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># d的键对应的值默认为列表</span><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> s<span class="token punctuation">:</span>    d<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># defaultdict(&lt;class 'list'>, {'yellow': [6, 3], 'blue': [2, 4], 'red': [1]})</span><span class="token comment" spellcheck="true"># 按键排序</span><span class="token keyword">print</span><span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [('blue', [2, 4]), ('red', [1]), ('yellow', [6, 3])]</span><span class="token comment" spellcheck="true"># 打印字典</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># dict_items([('yellow', [6, 3]), ('blue', [2, 4]), ('red', [1])])</span><span class="token comment" spellcheck="true"># 打印某键对应的值</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token string">"blue"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [2, 4]</span><span class="token comment" spellcheck="true"># 打印键</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># dict_keys(['yellow', 'blue', 'red'])</span><span class="token comment" spellcheck="true"># 打印值</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># dict_values([[6, 3], [2, 4], [1]])</span><span class="token comment" spellcheck="true"># 把值以列表的形式输出</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>d<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [[6, 3], [2, 4], [1]]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯2020笔试记录</title>
      <link href="/2020/08/24/leetcode/others/teng-xun-2020-bi-shi-ji-lu/"/>
      <url>/2020/08/24/leetcode/others/teng-xun-2020-bi-shi-ji-lu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/discuss/486638" target="_blank" rel="noopener">技术研究 数据分析笔试题&amp;题解</a></p><p>（P.S. <a href="https://wandbox.org/" target="_blank" rel="noopener">一个支持多语言在线编译的页面</a>）</p><p><a href="https://blog.csdn.net/qq_22522375/article/details/108189181" target="_blank" rel="noopener">题解1</a><br><a href="https://www.nowcoder.com/discuss/486688?channel=1009&source_id=discuss_terminal_discuss_sim" target="_blank" rel="noopener">题解2（python实现）</a></p><h1 id="1-使括号有效的最小添加"><a href="#1-使括号有效的最小添加" class="headerlink" title="1. 使括号有效的最小添加"></a>1. 使括号有效的最小添加</h1><p><img src="https://img-blog.csdnimg.cn/20200824165931141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><blockquote><p>如果是单类别的括号，就是：<br><a href="https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/solution/python-tong-ji-shi-gua-hao-you-xiao-de-tian-jia-by/" target="_blank" rel="noopener">LeetCode921题</a><br>给定一个由 ‘(‘ 和 ‘)’ 括号组成的字符串 S，我们需要添加最少的括号（ ‘(‘ 或是<br>‘)’，可以在任何位置），以使得到的括号字符串有效。</p><p>从形式上讲，只有满足下面几点之一，括号字符串才是有效的：</p><ul><li>它是一个空字符串，或者 </li><li>它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者 </li><li>它可以被写作 (A)，其中 A是有效字符串。 </li></ul><p>给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minAddToMakeValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'?'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 加一个'?'打底，防止栈为空并且需要pop时报错</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> S<span class="token punctuation">:</span>            <span class="token keyword">if</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'('</span> <span class="token operator">and</span> i<span class="token operator">==</span><span class="token string">')'</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 栈顶为左括号，且当前元素为右括号，可以互相抵消。此时栈顶出栈</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 抵消不了的元素通通入栈</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> ```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><strong>本题解题思路：</strong></p><ul><li>经典区间dp问题，构建一个<code>len(s)*len(s)</code>的二维数组。dp[i][j]代表着从字符串i位置到j位置需要的最小括号匹配数。</li><li>对角线部分（<code>dp[i][i]</code>）为1，从下到上遍历上三角部分，    <code>dp[0][len(s)-1]</code> 为所求结果</li><li>当i&lt;j 时:<ul><li>如果第i个位置和第j个位置的两个括号是匹配的（<code>if((s[i]==&#39;[&#39; &amp;&amp; s[j]==&#39;]&#39;) or (s[i]==&#39;(&#39; &amp;&amp; s[j]==&#39;)&#39;))</code>），那么<code>dp[i][j] = dp[i+1][j-1]</code>，相当于两边分别往里缩了一个；</li><li>如果第i个位置和第j个位置的两个括号无法抵消，则 <code>dp[i][j] = dp[i][k]+dp[k+1][j]</code>  k的范围为<code>[i,j)</code></li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>    n<span class="token operator">=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># dp=[[float('inf') for _ in range(n)] for _ in range(n)] # 不可以这样初始化，为什么？</span>    dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 对角线初始化为1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            当i <span class="token operator">&lt;</span> j时            <span class="token comment" spellcheck="true"># 如果能抵消，则 dp[i][j]=dp[i+1][j-1]</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'['</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">']'</span><span class="token punctuation">)</span> <span class="token operator">or</span>  <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'('</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 如果不能抵消，则 dp[i][j] = dp[i][k]+dp[k+1][j] k的范围为[i,j)</span>                temp<span class="token operator">=</span>n                <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;=</span>temp<span class="token punctuation">:</span>                        temp<span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>temp        <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># s=str(input().strip())</span>s<span class="token operator">=</span><span class="token string">'()[)[)(][(]([)]]]((]]'</span>helper<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-求抛物线围成的面积"><a href="#2-求抛物线围成的面积" class="headerlink" title="2. 求抛物线围成的面积"></a>2. 求抛物线围成的面积</h1><p><img src="https://img-blog.csdnimg.cn/20200824184943576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><ul><li>题目要求取6位小数，注意输出的格式：<code>print(&quot;{:.6f}&quot;.format(ans))</code><br><a href="https://www.runoob.com/python/att-string-format.html" target="_blank" rel="noopener">Python format 格式化函数</a></li><li>计算n组面积</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> math<span class="token keyword">def</span> <span class="token function">solution</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>C<span class="token punctuation">,</span>D<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 简单的微积分后，求得的面积</span>    ans <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span>A<span class="token operator">*</span><span class="token punctuation">(</span>D<span class="token operator">**</span><span class="token number">3</span><span class="token operator">-</span>C<span class="token operator">**</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token operator">*</span><span class="token punctuation">(</span>D<span class="token operator">**</span><span class="token number">2</span><span class="token operator">-</span>C<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">+</span>B<span class="token operator">*</span><span class="token punctuation">(</span>D<span class="token operator">-</span>C<span class="token punctuation">)</span>    <span class="token keyword">return</span> ansn <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    ans <span class="token operator">=</span> abs<span class="token punctuation">(</span>solution<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># print("%.6f"%ans)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"{:.6f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-选队长的方案"><a href="#3-选队长的方案" class="headerlink" title="3. 选队长的方案"></a>3. 选队长的方案</h1><p><img src="https://img-blog.csdnimg.cn/20200824193626747.png#pic_center" alt><br>主要考察的知识点：</p><ul><li>排列组合找规律：方案数为 <code>ans=n * 2^(n-1)</code></li><li>用<strong>快速幂</strong>来计算方案数：<a href="https://leetcode-cn.com/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/" target="_blank" rel="noopener">Krahets的快速幂知识点讲解</a></li></ul><p><img src="https://img-blog.csdnimg.cn/20200824194151327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">myPow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 若为0，直接返回结果</span>        res <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span> x<span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> x<span class="token punctuation">,</span> <span class="token operator">-</span>n <span class="token comment" spellcheck="true"># 把n为负数的情况转化成正数</span>        <span class="token keyword">while</span> n<span class="token punctuation">:</span>            <span class="token keyword">if</span> n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>res<span class="token operator">*=</span>x <span class="token comment" spellcheck="true"># res随着x的增大越来越大</span>            x<span class="token operator">*=</span>x             n<span class="token operator">=</span>n<span class="token operator">//</span><span class="token number">2</span> <span class="token comment" spellcheck="true"># 幂每次向下除2，直至为0</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以本题把方案数带进去即可：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">myPow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 求x的n次方</span>    <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>    res <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span> x<span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> x<span class="token punctuation">,</span> <span class="token operator">-</span>n    <span class="token keyword">while</span> n<span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> res <span class="token operator">*=</span> x        x <span class="token operator">*=</span> x        n <span class="token operator">=</span> n <span class="token operator">//</span> <span class="token number">2</span>    <span class="token keyword">return</span> resn<span class="token operator">=</span>int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>output<span class="token operator">=</span>n<span class="token operator">*</span>myPow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">**</span><span class="token number">9</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-计算图的价值"><a href="#4-计算图的价值" class="headerlink" title="4.  计算图的价值"></a>4.  计算图的价值</h1><p><img src="https://img-blog.csdnimg.cn/20200824232431214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt><br><img src="https://img-blog.csdnimg.cn/20200824232603550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><ul><li>统计小伙伴相同的点对数量。用     <code>defaultdict</code> 实现。<br>（AC 90%）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token comment" spellcheck="true"># 数据输入</span><span class="token triple-quoted-string string">'''4 31 22 32 4'''</span>n<span class="token punctuation">,</span>m<span class="token operator">=</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 统计每个点的对应的小伙伴。主人（1个）：小伙伴（1个或多个）</span>host<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token keyword">for</span> x<span class="token punctuation">,</span>y <span class="token keyword">in</span> res<span class="token punctuation">:</span>    host<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 键为x对应的小伙伴</span>    host<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print(host) # defaultdict(&lt;class 'list'>, {1: [2], 2: [1, 3, 4], 3: [2], 4: [2]})</span><span class="token comment" spellcheck="true"># 统计小伙伴相同的（主人）键。此时，小伙伴(处理过了，是独特的1个名称)：主人（1个或多个）</span>partner<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token keyword">for</span> u<span class="token punctuation">,</span>v <span class="token keyword">in</span> host<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    v<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span>sorted<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 小伙伴从  [1,3,4]-> 134</span>    partner<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print(partner) # defaultdict(&lt;class 'list'>, {'2': [1, 3, 4], '134': [2]})</span><span class="token comment" spellcheck="true"># partner中，主人数>1的才会对图产生价值 （1:2，然后 2:1 的这种无价值）</span>ans<span class="token operator">=</span><span class="token number">0</span><span class="token keyword">for</span> v<span class="token punctuation">,</span>u <span class="token keyword">in</span> partner<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    hostLen<span class="token operator">=</span>len<span class="token punctuation">(</span>u<span class="token punctuation">)</span>    <span class="token keyword">if</span> hostLen<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 从n种样品中 取 2种，无先后区分。则一共有 n*（n-1）/2 种组合</span>        ans<span class="token operator">+=</span>hostLen<span class="token operator">*</span><span class="token punctuation">(</span>hostLen<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token keyword">print</span><span class="token punctuation">(</span>int<span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>921. 使括号有效的最少添加</title>
      <link href="/2020/08/24/leetcode/921-shi-gua-hao-you-xiao-de-zui-shao-tian-jia/"/>
      <url>/2020/08/24/leetcode/921-shi-gua-hao-you-xiao-de-zui-shao-tian-jia/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/" target="_blank" rel="noopener">921. 使括号有效的最少添加</a></p><p>统计不可匹配的括号数 = 使括号有效的最少添加</p><ul><li>加一个’?’打底，防止栈为空并且需要pop时报错</li><li>若栈顶为左括号，且当前元素为右括号，可以互相抵消。此时栈顶出栈</li><li>其他情况：抵消不了. 此时，不管是左括号还是右括号, 通通入栈</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minAddToMakeValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'?'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 加一个'?'打底，防止栈为空并且需要pop时报错</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> S<span class="token punctuation">:</span>            <span class="token keyword">if</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'('</span> <span class="token operator">and</span> i<span class="token operator">==</span><span class="token string">')'</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 栈顶为左括号，且当前元素为右括号，可以互相抵消。此时栈顶出栈</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 抵消不了的元素通通入栈</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美团2020笔试及赛码网输入输出示例</title>
      <link href="/2020/08/22/leetcode/others/mei-tuan-2020-bi-shi-ji-sai-ma-wang-shu-ru-shu-chu/"/>
      <url>/2020/08/22/leetcode/others/mei-tuan-2020-bi-shi-ji-sai-ma-wang-shu-ru-shu-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a><a href="https://www.nowcoder.com/discuss/485689?toCommentId=6937138" target="_blank" rel="noopener">字符匹配</a></h1><p>规则：<br>首字母必须为字母<br>只能包含数字和字母<br>数字和字母必须都有</p><p>(<a href="https://mofanpy.com/tutorials/python-basic/basic/regular-expression/" target="_blank" rel="noopener">莫烦python</a>，也可以用正则表达式解决)</p><p><strong>每一行输入都对应一行输出</strong></p><blockquote><p>输入：<br>第一行：数字（需要判断的行数）<br>后面的行：每行一个字符串<br>输出： Accept 或者 Wrong</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> re<span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">20</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token comment" spellcheck="true"># 判断首字母是否为字母</span>    <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>isalpha<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token comment" spellcheck="true"># 判断字符串是否由字母和数字组成</span>    <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token comment" spellcheck="true"># 判断是否含有数字</span>    numMatch <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span><span class="token string">'[0-9]'</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token operator">not</span> numMatch<span class="token punctuation">.</span>search<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment" spellcheck="true"># # 判断是否含有数字也可以这样：截止现在，只剩下 全字母  和  字母+数字 组合</span>    <span class="token comment" spellcheck="true"># if s.isalpha():</span>    <span class="token comment" spellcheck="true">#     return False</span>    <span class="token comment" spellcheck="true"># else:</span>    <span class="token comment" spellcheck="true">#     return True</span>T <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>    s <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 这里要strip,大坑耽误不少时间</span>    <span class="token keyword">if</span> isValid<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Accept'</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Wrong'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="小美跑腿"><a href="#小美跑腿" class="headerlink" title="小美跑腿"></a>小美跑腿</h1><p><strong>输入所有行后才输出结果</strong></p><blockquote><p>输入示例:<br>输入第一行:<br>[5,2] # 5个订单，只能取2个订单。<br>后面的行：# 赚的钱是第一个数+第二个数<em>2。<br>[1,2] # 1+2</em>2=5元<br>[3,1] # 5<br>[4,2] # 8<br>[4,2] # 8<br>[5,1] # 7<br>输出：<br>要赚最多的钱，返回小美选择的订单序列 </p></blockquote><pre class="line-numbers language-python"><code class="language-python">n<span class="token punctuation">,</span> m <span class="token operator">=</span> map<span class="token punctuation">(</span>int<span class="token punctuation">,</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    v<span class="token punctuation">,</span> w <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    arr<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>v<span class="token operator">+</span>w<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>arr<span class="token operator">=</span>sorted<span class="token punctuation">(</span>arr<span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 按第一个元素降序排列，第一个元素相同时，按第二个元素升序排列</span>res<span class="token operator">=</span><span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span>res<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>394. 字符串解码</title>
      <link href="/2020/08/20/leetcode/394-zi-fu-chuan-jie-ma/"/>
      <url>/2020/08/20/leetcode/394-zi-fu-chuan-jie-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/" target="_blank" rel="noopener">394. 字符串解码</a></h1><p><a href="https://leetcode-cn.com/problems/decode-string/solution/zhan-by-ssk-x/" target="_blank" rel="noopener">方法1：利用栈先进后出原则_更容易理解</a></p><ul><li>digit = []   ###存放数字</li><li>letter = []  ###存放数字前面的字母串</li><li>res = ‘’     ###解码结果。在遍历过程中，也会临时存放字母串<ul><li>遇到左括号时，根据res更新letter，并清空res</li><li>遇到右括号时，更新res </li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decodeString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        digit <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">###存放数字</span>        letter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">###存放数字前面的字母串</span>        res <span class="token operator">=</span> <span class="token string">''</span>     <span class="token comment" spellcheck="true">###左括号后面的字母串</span>        number <span class="token operator">=</span> <span class="token number">0</span>   <span class="token comment" spellcheck="true">###数字</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token string">'0'</span><span class="token operator">&lt;=</span>i<span class="token operator">&lt;=</span><span class="token string">'9'</span><span class="token punctuation">:</span>                number <span class="token operator">=</span> number<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>int<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token string">'['</span><span class="token punctuation">:</span>                digit<span class="token punctuation">.</span>append<span class="token punctuation">(</span>number<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">###当遇见左括号的时候数字结束，这个很关键</span>                letter<span class="token punctuation">.</span>append<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true">###遇见左括号的时候数字前面的字符串也存入栈</span>                number <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">###置零</span>                res <span class="token operator">=</span> <span class="token string">''</span>   <span class="token comment" spellcheck="true">###置空</span>            <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token string">']'</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">###当遇见右括号取出数字前面的字母串，数字，然后数字乘以当前字符串</span>                a <span class="token operator">=</span> digit<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                b <span class="token operator">=</span> letter<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                res <span class="token operator">=</span> b<span class="token operator">+</span>a<span class="token operator">*</span>res            <span class="token keyword">else</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span> i <span class="token comment" spellcheck="true">###当前数字后面的字母串</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode-cn.com/problems/decode-string/solution/394zi-fu-chuan-jie-ma-zhan-by-zhouzhoucn-2/" target="_blank" rel="noopener">方法2：利用递归函数</a></p><ul><li>将 <code>[</code> 和 <code>]</code> 分别作为递归的开启与终止条件。 </li><li>明确递归函数的功能<del>（不要跳进函数内）</del>：<code>decoding(s, index)</code>返回字符串s中，<strong>以index下标开始的后面的子字符串解码后的结果</strong>。<ul><li>当<code>&#39;s[i]==&#39;[&#39;</code>，进入函数，并接受返回值</li><li>当 <code>s[i]==&#39;]&#39;</code>，返回解码后的结果，以及<strong>入口左括号对应的右括号的下标</strong></li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decodeString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">decoding</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># num储存当前遍历到的数字</span>            <span class="token comment" spellcheck="true"># res储存当前遍历到的字符串</span>            num <span class="token operator">=</span> <span class="token string">""</span>            res <span class="token operator">=</span> <span class="token string">""</span>            <span class="token comment" spellcheck="true"># 遍历字符串</span>            <span class="token keyword">while</span> index <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 读取当前字符串</span>                current <span class="token operator">=</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span>                <span class="token comment" spellcheck="true"># index表示当前字符的索引</span>                <span class="token comment" spellcheck="true"># 如果是数字，添加到num</span>                <span class="token keyword">if</span> current<span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    num <span class="token operator">+=</span> current                <span class="token comment" spellcheck="true"># 如果是字母，添加到res</span>                <span class="token keyword">if</span> current<span class="token punctuation">.</span>isalpha<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> current                <span class="token comment" spellcheck="true"># 如果是"["，进入下一层递归并返回下一状态的res</span>                <span class="token comment" spellcheck="true"># 返回的res与当前状态下的num相乘，并添加到当前的res</span>                <span class="token keyword">if</span> current <span class="token operator">==</span> <span class="token string">"["</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># temp表示解码后的结果，index表示下标</span>                    temp<span class="token punctuation">,</span> index <span class="token operator">=</span> decoding<span class="token punctuation">(</span>s<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                    res <span class="token operator">+=</span> int<span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">*</span> temp                    num <span class="token operator">=</span> <span class="token string">""</span>                <span class="token comment" spellcheck="true"># 如果是"]",返回这一状态的res与index</span>                <span class="token keyword">if</span> current <span class="token operator">==</span> <span class="token string">"]"</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># 返回这一状态的res与index</span>                    <span class="token keyword">return</span> res<span class="token punctuation">,</span> index                <span class="token comment" spellcheck="true"># 下标右移，继续下一次循环</span>                index <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 遍历完所有字符串，返回res</span>            <span class="token keyword">return</span> res        <span class="token comment" spellcheck="true"># 开始递归，index初始为0  </span>        <span class="token keyword">return</span> decoding<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2020秋招腾讯后台笔试题（一）"><a href="#2020秋招腾讯后台笔试题（一）" class="headerlink" title="2020秋招腾讯后台笔试题（一）"></a><a href="https://zhuanlan.zhihu.com/p/116482908" target="_blank" rel="noopener">2020秋招腾讯后台笔试题（一）</a></h1><p>该题的思路同上，也是利用栈</p><ul><li><code>|</code>就相当于上题的<code>[</code>的功能。</li><li>而<code>[</code> 在本题没用，用<code>s=s.replace(&#39;[&#39;,&#39;&#39;)</code>删除掉即可 </li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">decodeString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 删除掉'['字符</span>    s<span class="token operator">=</span>s<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'['</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span>    digit <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">###存放数字</span>    letter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">###存放数字前面的字母串</span>    res <span class="token operator">=</span> <span class="token string">''</span>     <span class="token comment" spellcheck="true">###左括号后面的字母串</span>    number <span class="token operator">=</span> <span class="token number">0</span>   <span class="token comment" spellcheck="true">###数字</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> s<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token string">'0'</span><span class="token operator">&lt;=</span>i<span class="token operator">&lt;=</span><span class="token string">'9'</span><span class="token punctuation">:</span>            number <span class="token operator">=</span> number<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>int<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token string">'|'</span><span class="token punctuation">:</span>            digit<span class="token punctuation">.</span>append<span class="token punctuation">(</span>number<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">###当遇见左括号的时候数字结束，这个很关键</span>            letter<span class="token punctuation">.</span>append<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true">###遇见左括号的时候数字前面的字符串也存入栈</span>            number <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">###置零</span>            res <span class="token operator">=</span> <span class="token string">''</span>   <span class="token comment" spellcheck="true">###置空</span>        <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token string">']'</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">###当遇见右括号取出数字前面的字母串，数字，然后数字乘以当前字符串</span>            a <span class="token operator">=</span> digit<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            b <span class="token operator">=</span> letter<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> b<span class="token operator">+</span>a<span class="token operator">*</span>res        <span class="token keyword">else</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> i <span class="token comment" spellcheck="true">###当前数字后面的字母串</span>    <span class="token keyword">return</span> resa<span class="token operator">=</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>decodeString<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>54. 螺旋矩阵</title>
      <link href="/2020/08/20/leetcode/54-luo-xuan-ju-zhen/"/>
      <url>/2020/08/20/leetcode/54-luo-xuan-ju-zhen/</url>
      
        <content type="html"><![CDATA[<h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/" target="_blank" rel="noopener">54. 螺旋矩阵</a></h1><p>顺时针打印矩阵</p><ul><li>设定上下左右四个点</li><li>从左到右彻底遍历一行，然后上边界+1。若上边界超过下边界：跳出</li><li>从上到下彻底遍历一列，然后右边界-1。若左边界超过右边界：跳出</li><li>从右到左彻底遍历一行，然后下边界-1。若上边界超过下边界：跳出</li><li>从下到上彻底遍历一列，然后左边界+1。若左边界超过右边界：跳出</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> matrix<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        t <span class="token operator">=</span> <span class="token number">0</span>        b <span class="token operator">=</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 从左到右</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            t <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> t <span class="token operator">></span> b<span class="token punctuation">:</span> <span class="token keyword">break</span>            <span class="token comment" spellcheck="true"># 从上到下</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>t<span class="token punctuation">,</span> b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>            r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> l <span class="token operator">></span> r<span class="token punctuation">:</span> <span class="token keyword">break</span>            <span class="token comment" spellcheck="true"># 从右到左</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>r<span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            b <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> t <span class="token operator">></span> b<span class="token punctuation">:</span> <span class="token keyword">break</span>            <span class="token comment" spellcheck="true"># 从下到上</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>b<span class="token punctuation">,</span> t <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span>            l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> l <span class="token operator">></span> r<span class="token punctuation">:</span> <span class="token keyword">break</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有种取巧的方法（仅供参考）：</p><ul><li>把第一行pop出来，加到结果中</li><li>把剩下的矩阵逆时针翻转90度，把第一行pop出来，加到结果中。直至结束</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type matrix: List[List[int]]        :rtype: List[int]        """</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> matrix<span class="token punctuation">:</span>            res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>matrix<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            matrix<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>list<span class="token punctuation">,</span>zip<span class="token punctuation">(</span><span class="token operator">*</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2020-8-19-华为笔试题目1"><a href="#2020-8-19-华为笔试题目1" class="headerlink" title="2020.8.19 华为笔试题目1"></a><a href="https://www.nowcoder.com/discuss/482620?type=1&channel=0&source_id=discuss_terminal_discuss_hot" target="_blank" rel="noopener">2020.8.19 华为笔试题目1</a></h1><ul><li>同样是顺时针遍历数组，只是增加了一个判断个位十位的功能</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 判断个位十位的函数</span><span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> n <span class="token operator">%</span> <span class="token number">10</span> <span class="token comment" spellcheck="true"># 个位</span>    b <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">//</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token comment" spellcheck="true"># 十位</span>    <span class="token keyword">return</span> a <span class="token operator">==</span> <span class="token number">7</span> <span class="token operator">and</span> b <span class="token operator">%</span> <span class="token number">2</span><span class="token keyword">def</span> <span class="token function">getRes</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 超过范围，返回</span>    <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">&lt;=</span> M <span class="token operator">&lt;=</span> <span class="token number">1000</span> <span class="token operator">and</span> <span class="token number">10</span> <span class="token operator">&lt;=</span> N <span class="token operator">&lt;=</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[]"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    idx <span class="token operator">=</span> <span class="token number">0</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    l <span class="token operator">=</span> <span class="token number">0</span>    r <span class="token operator">=</span> N <span class="token operator">-</span> <span class="token number">1</span>    t <span class="token operator">=</span> <span class="token number">0</span>    b <span class="token operator">=</span> M <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 从左到右</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            idx <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> helper<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>t<span class="token punctuation">,</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span>        t <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> t <span class="token operator">></span> b<span class="token punctuation">:</span> <span class="token keyword">break</span>        <span class="token comment" spellcheck="true"># 从上到下：</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>t<span class="token punctuation">,</span> b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            idx <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> helper<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span> r<span class="token punctuation">]</span><span class="token punctuation">)</span>        r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">if</span> l <span class="token operator">></span> r<span class="token punctuation">:</span> <span class="token keyword">break</span>        <span class="token comment" spellcheck="true"># 从右到左</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>r<span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            idx <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> helper<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>b<span class="token punctuation">,</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span>        b <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">if</span> t <span class="token operator">></span> b<span class="token punctuation">:</span> <span class="token keyword">break</span>        <span class="token comment" spellcheck="true"># 从下到上</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>b<span class="token punctuation">,</span> t <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            idx <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> helper<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span> l<span class="token punctuation">]</span><span class="token punctuation">)</span>        l <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> l <span class="token operator">></span> r<span class="token punctuation">:</span> <span class="token keyword">break</span>        <span class="token comment" spellcheck="true"># print(res)</span>    res <span class="token operator">=</span> str<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    tmp<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    M<span class="token operator">=</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    N<span class="token operator">=</span>tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    getRes<span class="token punctuation">(</span>M<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网编程常见输入输出练习</title>
      <link href="/2020/08/19/leetcode/others/niu-ke-wang-bian-cheng-chang-jian-shu-ru-shu-chu-lian-xi/"/>
      <url>/2020/08/19/leetcode/others/niu-ke-wang-bian-cheng-chang-jian-shu-ru-shu-chu-lian-xi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5649#question" target="_blank" rel="noopener">OJ在线编程常见输入输出练习场题目链接</a></p><p><a href="https://www.codeleading.com/article/67893417412/" target="_blank" rel="noopener">python:各种字符输入、数值输入总结、OJ输入输出</a></p><h1 id="A-B-1"><a href="#A-B-1" class="headerlink" title="A+B(1)"></a>A+B(1)</h1><ul><li>可以输入无数次</li><li>每次输入一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200822232853963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">for</span> line <span class="token keyword">in</span> sys<span class="token punctuation">.</span>stdin<span class="token punctuation">:</span>    a<span class="token punctuation">,</span> b <span class="token operator">=</span> map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">for</span> line <span class="token keyword">in</span> sys<span class="token punctuation">.</span>stdin<span class="token punctuation">:</span>    a <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># a是这样的：['1','2']</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>int<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> int<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        a<span class="token punctuation">,</span>b<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="A-B-2"><a href="#A-B-2" class="headerlink" title="A+B(2)"></a>A+B(2)</h1><ul><li>可以输入<code>t</code>次</li><li>每次输入一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200823080711526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python">t<span class="token operator">=</span>int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>    a<span class="token punctuation">,</span>b<span class="token operator">=</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># a,b=list(map(int,input().strip().split())) # 也可以</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="A-B-3"><a href="#A-B-3" class="headerlink" title="A+B(3)"></a>A+B(3)</h1><ul><li>可以输入无数次, 但遇到 输入为0 0 时，结束输入 （跳出循环） </li><li>每次输入一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/2020082308113630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        a<span class="token punctuation">,</span>b<span class="token operator">=</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> a<span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">and</span> b<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="A-B-4"><a href="#A-B-4" class="headerlink" title="A+B(4)"></a>A+B(4)</h1><ul><li><p>可以输入无数次, 但如果输入的第一个元素为0，结束输入（跳出循环） </p></li><li><p>每次输入一行后，输出一行结果</p><p><img src="https://img-blog.csdnimg.cn/20200823081848657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        l <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">(</span>l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="A-B-5"><a href="#A-B-5" class="headerlink" title="A+B(5)"></a>A+B(5)</h1><ul><li>可以输入<code>t</code>次</li><li>每次输入一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200823083446835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python">t<span class="token operator">=</span>int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>    l<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">(</span>l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="A-B-6"><a href="#A-B-6" class="headerlink" title="A+B(6)"></a>A+B(6)</h1><ul><li>可以输入无数次</li><li>每次输入一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200823084416906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        l<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">(</span>l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="A-B-7"><a href="#A-B-7" class="headerlink" title="A+B(7)"></a>A+B(7)</h1><ul><li>可以输入无数次</li><li>每次输入一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200823084921151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        l <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> EOFError<span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="字符串排序-1"><a href="#字符串排序-1" class="headerlink" title="字符串排序(1)"></a>字符串排序(1)</h1><ul><li>输入有两行，第一行表示字符串的个数<code>n</code>，第二行是输入的<code>n</code>个字符串</li><li>每次完整输入后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200823090055420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python">n<span class="token operator">=</span>int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>res<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>res<span class="token operator">=</span>sorted<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># res=" ".join(res)</span>res<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="字符串排序-2"><a href="#字符串排序-2" class="headerlink" title="字符串排序(2)"></a>字符串排序(2)</h1><ul><li>可以输入无数次 </li><li>每次输入（空格隔开）一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200823091047706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        l<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        l<span class="token operator">=</span>sorted<span class="token punctuation">(</span>l<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="字符串排序-3"><a href="#字符串排序-3" class="headerlink" title="字符串排序(3)"></a>字符串排序(3)</h1><ul><li>可以输入无数次 </li><li>每次输入（逗号隔开）一行后，输出一行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/2020082309124959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        l<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        l<span class="token operator">=</span>sorted<span class="token punctuation">(</span>l<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="当输入的行数不确定时"><a href="#当输入的行数不确定时" class="headerlink" title="当输入的行数不确定时"></a>当输入的行数不确定时</h1><p>输入示例：<br>1 2回车<br>3 4回车<br>回车</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sysres<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    line <span class="token operator">=</span> sys<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 读取该行的内容 如 1空格2</span>    <span class="token keyword">if</span> <span class="token operator">not</span> line<span class="token punctuation">:</span>        <span class="token keyword">break</span>    lineList <span class="token operator">=</span> str<span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 以空格间开</span>    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>lineList<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># [['1', '2'], ['3', '4']]</span>resNum<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> res<span class="token punctuation">:</span>    i<span class="token operator">=</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>    resNum<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>resNum<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [[1, 2], [3, 4]]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何去除有序数组的重复元素</title>
      <link href="/2020/08/18/labuladong/di-si-zhang-ru-he-qu-chu-you-xu-shu-zu-de-chong-fu-yuan-su/"/>
      <url>/2020/08/18/labuladong/di-si-zhang-ru-he-qu-chu-you-xu-shu-zu-de-chong-fu-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/ru-he-qu-chu-you-xu-shu-zu-de-zhong-fu-yuan-su" target="_blank" rel="noopener">如何去除有序数组的重复元素</a></p><p>用<strong>快慢指针</strong>解决问题（两种初始化都可以）<br>初始化时：</p><pre class="line-numbers language-python"><code class="language-python">slow<span class="token punctuation">,</span>fast<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>slow<span class="token punctuation">,</span>fast<span class="token operator">=</span>head<span class="token punctuation">,</span>head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-python"><code class="language-python">slow<span class="token punctuation">,</span>fast<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span>slow<span class="token punctuation">,</span>fast<span class="token operator">=</span>head<span class="token punctuation">,</span>head<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>快指针在前，慢指针在后。快指针在每次前进时，如果和慢指针的元素不同，则慢指针跳1格，然后把快指针的元素赋给慢指针</li></ul><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># nums = [0,0,1,1,1,2,2,3,3,4]</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token number">0</span>        slow<span class="token punctuation">,</span>fast<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">while</span> fast<span class="token operator">&lt;</span>n<span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token operator">!=</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">:</span>                slow <span class="token operator">+=</span> <span class="token number">1</span>                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span>            fast<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> slow<span class="token operator">+</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: ListNode        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> head<span class="token punctuation">:</span> <span class="token keyword">return</span> None        slow<span class="token operator">=</span>head        fast<span class="token operator">=</span>head<span class="token punctuation">.</span>next        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">if</span> slow<span class="token punctuation">.</span>val<span class="token operator">!=</span>fast<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next                slow<span class="token punctuation">.</span>val<span class="token operator">=</span>fast<span class="token punctuation">.</span>val            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next        slow<span class="token punctuation">.</span>next<span class="token operator">=</span>None        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何高效解决接雨水问题</title>
      <link href="/2020/08/17/labuladong/di-si-zhang-ru-he-gao-xiao-jie-jue-jie-yu-shui-wen-ti/"/>
      <url>/2020/08/17/labuladong/di-si-zhang-ru-he-gao-xiao-jie-jue-jie-yu-shui-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/jie-yu-shui" target="_blank" rel="noopener">如何高效解决接雨水问题</a></p><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></p><p>我们开两个数组 r_max 和 l_max 充当备忘录</p><ul><li>l_max[i] 表示位置 i 左边最高的柱子高度（包括本身在内，正着遍历）， r_max[i] 表示位置 i 右边最高的柱子高度（包括本身在内，倒着遍历）。位置 i 能保存的最大的水柱高度就是 <code>min(l_max, r_max)- height[i]</code></li><li>预先把这两个数组计算好，避免重复计算</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type height: List[int]        :rtype: int        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> height<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true">#初始化</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>height<span class="token punctuation">)</span>        l_max<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>n        r_max<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>n        l_max<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>height<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        r_max<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span>height<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 计算i对应的左右最大值</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            l_max<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>l_max<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            r_max<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>r_max<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 计算面积</span>        ans<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            ans<span class="token operator">+=</span>min<span class="token punctuation">(</span>l_max<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>r_max<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> ans<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何运用二分查找算法</title>
      <link href="/2020/08/17/labuladong/di-si-zhang-ru-he-yun-yong-er-fen-cha-zhao-suan-fa/"/>
      <url>/2020/08/17/labuladong/di-si-zhang-ru-he-yun-yong-er-fen-cha-zhao-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/koko-tou-xiang-jiao" target="_blank" rel="noopener">如何运用二分查找算法</a></p><p><a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a></p><ul><li><p><code>canFinish()</code> 函数：当前速度下，能吃完的小时数（注意要<strong>向上整除</strong>）    </p></li><li><p>最小速度为1，最大速度为数组中最大值。因此利用二分查找框架求h（<strong>h相当于二分查找中的目标值</strong>），注意相等时，也是更新右边界。最后返回左边界</p><p>*  此题需在python3中提交（python3 中 <code>pile/speed</code> 是除法，除不尽时有小数（python2 与此略有不同），然后向上取整）</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minEatingSpeed</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> piles<span class="token punctuation">,</span> H<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type piles: List[int]        :type H: int        :rtype: int        """</span>        <span class="token keyword">import</span> math        <span class="token comment" spellcheck="true"># 当前速度下需要的时间</span>        <span class="token keyword">def</span> <span class="token function">canFinish</span><span class="token punctuation">(</span>piles<span class="token punctuation">,</span> H<span class="token punctuation">,</span> speed<span class="token punctuation">)</span><span class="token punctuation">:</span>            h <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> pile <span class="token keyword">in</span> piles<span class="token punctuation">:</span>                h <span class="token operator">+=</span> math<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>pile <span class="token operator">/</span> speed<span class="token punctuation">)</span>            <span class="token keyword">return</span> h        <span class="token comment" spellcheck="true"># 二分查找</span>        l <span class="token operator">=</span> <span class="token number">1</span>        r <span class="token operator">=</span> max<span class="token punctuation">(</span>piles<span class="token punctuation">)</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>            speed <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> canFinish<span class="token punctuation">(</span>piles<span class="token punctuation">,</span> H<span class="token punctuation">,</span> speed<span class="token punctuation">)</span> <span class="token operator">></span> H<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 速度太慢</span>                l <span class="token operator">=</span> speed <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">elif</span> canFinish<span class="token punctuation">(</span>piles<span class="token punctuation">,</span> H<span class="token punctuation">,</span> speed<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> H<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 速度太快</span>                <span class="token comment" spellcheck="true"># 因为是找左边界，所以若相等，更新右边界</span>                r <span class="token operator">=</span> speed <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">return</span> l        <span class="token comment" spellcheck="true"># # while 循环也可以写成这样：</span>        <span class="token comment" spellcheck="true"># while l&lt;=r:</span>        <span class="token comment" spellcheck="true">#     speed=l+(r-l)//2</span>        <span class="token comment" spellcheck="true">#     if canFinish(piles,H,speed)>H:</span>        <span class="token comment" spellcheck="true">#         l=speed+1</span>        <span class="token comment" spellcheck="true">#     elif canFinish(piles,H,speed)&lt;H:</span>        <span class="token comment" spellcheck="true">#         r=speed-1</span>        <span class="token comment" spellcheck="true">#     elif canFinish(piles,H,speed)==H:</span>        <span class="token comment" spellcheck="true">#         return speed</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank" rel="noopener">1011.在D天内送达包裹的能力</a></p><p>与上题思路相同，只是</p><ul><li><p>cap 的最小值和最大值分别为 max(weights) 和 sum(weights)。</p></li><li><p>按照有无超过容量来更新完成的天数<code>d</code></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">def</span> <span class="token function">shipWithinDays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> weights<span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token triple-quoted-string string">"""     :type weights: List[int]     :type D: int     :rtype: int     """</span>     <span class="token comment" spellcheck="true"># 当前capacity下完成的天数</span>     <span class="token keyword">def</span> <span class="token function">canFinish</span><span class="token punctuation">(</span>weights<span class="token punctuation">,</span>cap<span class="token punctuation">)</span><span class="token punctuation">:</span>         cur_w<span class="token operator">=</span><span class="token number">0</span>         d<span class="token operator">=</span><span class="token number">1</span>         <span class="token keyword">for</span> i <span class="token keyword">in</span> weights<span class="token punctuation">:</span>             <span class="token keyword">if</span> cur_w<span class="token operator">+</span>i<span class="token operator">></span>cap<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 超过容量了，放不下，天数加1，当前容量更新为i</span>                 d<span class="token operator">+=</span><span class="token number">1</span>                 cur_w<span class="token operator">=</span>i             <span class="token keyword">else</span><span class="token punctuation">:</span>                 cur_w<span class="token operator">+=</span>i <span class="token comment" spellcheck="true"># 没有超过，当前容量+i</span>         <span class="token keyword">return</span> d     <span class="token comment" spellcheck="true"># 二分搜索找左边界</span>     l<span class="token operator">=</span>max<span class="token punctuation">(</span>weights<span class="token punctuation">)</span>     r<span class="token operator">=</span>sum<span class="token punctuation">(</span>weights<span class="token punctuation">)</span>     <span class="token keyword">while</span> l<span class="token operator">&lt;=</span>r<span class="token punctuation">:</span>         cap<span class="token operator">=</span>l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>         <span class="token keyword">if</span> canFinish<span class="token punctuation">(</span>weights<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token operator">></span>D<span class="token punctuation">:</span>             l<span class="token operator">=</span>cap<span class="token operator">+</span><span class="token number">1</span>         <span class="token keyword">elif</span> canFinish<span class="token punctuation">(</span>weights<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token operator">&lt;=</span>D<span class="token punctuation">:</span>             r<span class="token operator">=</span>cap<span class="token number">-1</span>     <span class="token keyword">return</span> l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何高效寻找素数</title>
      <link href="/2020/08/17/labuladong/di-si-zhang-ru-he-gao-xiao-xun-zhao-su-shu/"/>
      <url>/2020/08/17/labuladong/di-si-zhang-ru-he-gao-xiao-xun-zhao-su-shu/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/da-yin-su-shu" target="_blank" rel="noopener">如何高效寻找素数</a></p><p><a href="https://leetcode-cn.com/problems/count-primes/solution/qiu-zhi-shu-chao-guo-90-by-powcai/" target="_blank" rel="noopener">204. 计数质数</a></p><p>统计所有<strong>小于非负整数 n</strong> 的质数的数量</p><ul><li>初始化时，给每个位置立一个flag，并初始化为1</li><li>遍历时，对于i而言：<ul><li>如果这个位置的flag为1，说明数字 i  没有被比 i 小的数整除过，说明它是质数，计数器+1。</li><li>i 的倍数一定不是质数，将这些数的flag设置为0</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countPrimes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#给每个位置立一个flag，初始化为1</span>        isPrimes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token comment" spellcheck="true">#result，输出的质数总个数的计数器，初始化为0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true">#循环，从最小质数i开始到n循环</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#如果这个位置的flag为1，说明数字 i  没有被比 i 小的数整除过，说明它是质数，计数器+1</span>            <span class="token keyword">if</span> isPrimes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> res <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true">#下面这几步的思路是， i 的倍数一定不是质数，将这些数的flag设置为0</span>            <span class="token comment" spellcheck="true">#设置倍数 j ，初始化与 i 相等。 因为i也是一点点加上来的，比如 i=5的时候，i 的4倍一定在 i=4 时已经设置为0过。</span>            j <span class="token operator">=</span> i            <span class="token comment" spellcheck="true"># 因为统计的是所有小于非负整数 n 的质数的数量，当 i 的 j 倍 >=n 时，跳出循环</span>            <span class="token keyword">while</span> i <span class="token operator">*</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true">#设置i 的 j 倍的flag为0</span>                isPrimes<span class="token punctuation">[</span>i <span class="token operator">*</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                <span class="token comment" spellcheck="true"># 自增，下一个找 j+1 倍</span>                j <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true">#返回结果</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：递归详解</title>
      <link href="/2020/08/17/labuladong/di-san-zhang-di-gui-xiang-jie/"/>
      <url>/2020/08/17/labuladong/di-san-zhang-di-gui-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/di-gui-xiang-jie" target="_blank" rel="noopener">递归详解</a></p><ul><li>明白一个递归函数的作用并相信它能完成这个任务，千万不要试图跳进细节</li><li>补充递归结束的条件<br><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">路径总和 III</a></li><li><code>pathSum(self, root, sum)</code> : 给定root 和目标值，返回和为目标值的路径总数。选择时，有两种情况： 路径开始时，<strong>选择当前节点/不选择当前节点，只考虑左右孩子</strong><ul><li>结果由3部分构成：以自己开头+（不以自己开头，以左孩子开头）+ （不以自己开头，以右孩子开头）</li></ul></li><li>以自己开头时，<code>count(self,root,sum)</code>:  返回count的个数 （能凑出几个<strong>以该节点为路径开头</strong>，和为目标值的路径总数）<ul><li>结果由3部分构成：自己独挡一面+（自己出力+左孩子出力）+（自己出力+右孩子出力）</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :type sum: int        :rtype: int        """</span>        <span class="token comment" spellcheck="true"># 注意递归结束条件</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 自己为开头的路径数</span>        ro<span class="token operator">=</span>self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>root<span class="token punctuation">,</span>sum<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 左边路径总数（相信他能算出来）</span>        l<span class="token operator">=</span>self<span class="token punctuation">.</span>pathSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>sum<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 右边路径总数（相信他能算出来）</span>        r<span class="token operator">=</span>self<span class="token punctuation">.</span>pathSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>sum<span class="token punctuation">)</span>        res<span class="token operator">=</span>ro<span class="token operator">+</span>l<span class="token operator">+</span>r        <span class="token keyword">return</span> res    <span class="token comment" spellcheck="true"># 返回count的个数 （能凑出几个以该节点为路径开头，和为目标值的路径总数）</span>    <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>root<span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 注意递归结束条件</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 我自己能不能独当一面，作为一条单独的路径呢？</span>        isMe<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>sum <span class="token keyword">else</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 左边的小老弟，你那边能凑几个sum - node.val 呀？</span>        lc<span class="token operator">=</span>self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>sum<span class="token operator">-</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 右边的小老弟，你那边能凑几个sum - node.val 呀？</span>        rc<span class="token operator">=</span>self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>sum<span class="token operator">-</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 以我这个头开始的节点，能凑这么多个</span>        countAll<span class="token operator">=</span>isMe<span class="token operator">+</span>lc<span class="token operator">+</span>rc        <span class="token keyword">return</span> countAll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：信封嵌套问题</title>
      <link href="/2020/08/16/labuladong/di-san-zhang-xin-feng-qian-tao-wen-ti/"/>
      <url>/2020/08/16/labuladong/di-san-zhang-xin-feng-qian-tao-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/xin-feng-qian-tao-wen-ti#yi-ti-mu-gai-shu" target="_blank" rel="noopener">信封嵌套问题</a></p><p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354. 俄罗斯套娃信封问题</a></p><ul><li>先对宽度（第一个数）进行升序排序，宽度相同时，对高度（第二个数）降序排序 <code>envelopes=sorted(envelopes,key=lambda x:(x[0],-x[1]))</code></li><li>然后对高度求最长上升子序列</li></ul><p>这个解法的关键在于，对于宽度 w 相同的数对，要<strong>对其高度 h 进行降序排序</strong>。因为两个宽度相同的信封不能相互包含的，<strong>逆序排序保证在 w 相同的数对中最多只选取一个。</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxEnvelopes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> envelopes<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># w升序，w相同时h降序</span>        envelopes<span class="token operator">=</span>sorted<span class="token punctuation">(</span>envelopes<span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        h<span class="token operator">=</span><span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> envelopes<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 取h</span>        res<span class="token operator">=</span>self<span class="token punctuation">.</span>lengthOfLIS<span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 调用函数</span>        <span class="token keyword">return</span> res    <span class="token comment" spellcheck="true"># 最长上升子序列函数</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：区间调度之区间交集问题</title>
      <link href="/2020/08/16/labuladong/di-san-zhang-qu-jian-diao-du-zhi-qu-jian-jiao-ji-wen-ti/"/>
      <url>/2020/08/16/labuladong/di-san-zhang-qu-jian-diao-du-zhi-qu-jian-jiao-ji-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/qu-jian-jiao-ji-wen-ti" target="_blank" rel="noopener">区间调度之区间交集问题</a></p><p><a href="https://leetcode-cn.com/problems/interval-list-intersections/" target="_blank" rel="noopener">986. 区间列表的交集</a></p><ul><li>找到有交集的条件，然后取公共部分</li><li>可能存在多个区间，注意更新指针的条件</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">intervalIntersection</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type A: List[List[int]]        :type B: List[List[int]]        :rtype: List[List[int]]        """</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        i<span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        <span class="token keyword">while</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">and</span> j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>            a1<span class="token punctuation">,</span>a2<span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            b1<span class="token punctuation">,</span>b2<span class="token operator">=</span>B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> b2<span class="token operator">>=</span>a1 <span class="token operator">and</span> a2<span class="token operator">>=</span>b1<span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 有交集的情况</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>max<span class="token punctuation">(</span>a1<span class="token punctuation">,</span>b1<span class="token punctuation">)</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>a2<span class="token punctuation">,</span>b2<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 取公共部分</span>            <span class="token comment" spellcheck="true"># 跳指针</span>            <span class="token keyword">if</span> b2<span class="token operator">&lt;</span>a2<span class="token punctuation">:</span> j<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> i<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：区间调度之区间合并问题</title>
      <link href="/2020/08/16/labuladong/di-san-zhang-qu-jian-diao-du-zhi-qu-jian-he-bing-wen-ti/"/>
      <url>/2020/08/16/labuladong/di-san-zhang-qu-jian-diao-du-zhi-qu-jian-he-bing-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/qu-jian-tiao-du-wen-ti-zhi-qu-jian-he-bing" target="_blank" rel="noopener">区间调度之区间合并问题</a></p><p><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></p><ul><li><p>按照区间的start，排序</p></li><li><p>如果当前的头没超过之前的尾，则取当前/ 之间尾的最大值。否则若超过了，res把当前区间添加进去。然后开始新一轮更新</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 输入: [[1,3],[2,6],[8,10],[15,18]]</span><span class="token comment" spellcheck="true"># 输出: [[1,6],[8,10],[15,18]]</span><span class="token comment" spellcheck="true"># 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> intervals<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token triple-quoted-string string">"""      :type intervals: List[List[int]]      :rtype: List[List[int]]      """</span>      <span class="token keyword">if</span> <span class="token operator">not</span> intervals<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>      intervals <span class="token operator">=</span> sorted<span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>      res <span class="token operator">=</span> <span class="token punctuation">[</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">if</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> res<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>              <span class="token comment" spellcheck="true">#更新并维护当前最大区间</span>              res<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>          <span class="token keyword">else</span><span class="token punctuation">:</span>              <span class="token comment" spellcheck="true"># 添加到结果，并重新更新</span>              res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python装饰器</title>
      <link href="/2020/08/13/python/python-zhuang-shi-qi/"/>
      <url>/2020/08/13/python/python-zhuang-shi-qi/</url>
      
        <content type="html"><![CDATA[<ul><li>什么是装饰器？<ul><li>python装饰器用于装饰函数。可以在保留原函数功能的条件下，赋予该函数更丰富的功能（而无需改动原函数）</li></ul></li><li>为什么要用装饰器？<ul><li>可以更便于开发，实现代码复用</li></ul></li><li>装饰器可以解决哪些问题？<ul><li>不破坏原函数的条件下，扩展函数功能(或函数权限)</li></ul></li></ul><blockquote><p>小明每学会一个新本领，他妈妈都会说：“小明太棒了”。所以把妈妈说的话单独写个函数，以后在每次调用时，就可以代码复用</p><ul><li><code>momSaid(func)</code>里的参数为函数</li><li><code>def wrapper(*args,**kwargs)</code>  … <code>return wrapper</code> 可以自动调用函数参数。（如 <code>learnAdd</code>函数有3个参数，<code>learnSubtraction</code> 有两个，但是完全没问题）</li></ul></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">momSaid</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        f<span class="token operator">=</span>func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"算数结果为{}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"妈妈说小明太棒了"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> f    <span class="token keyword">return</span> wrapper@momSaid<span class="token keyword">def</span> <span class="token function">learnAdd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"小明学会了加法"</span><span class="token punctuation">)</span>    res<span class="token operator">=</span>a<span class="token operator">+</span>b<span class="token operator">+</span>c    <span class="token keyword">return</span> res@momSaid<span class="token keyword">def</span> <span class="token function">learnSubtraction</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"小明学会了减法"</span><span class="token punctuation">)</span>    res<span class="token operator">=</span>a<span class="token operator">-</span>b    <span class="token keyword">return</span> reslearnAdd<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"==="</span><span class="token punctuation">)</span>learnSubtraction<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为：</p><pre><code>小明学会了加法算数结果为6妈妈说小明太棒了===小明学会了减法算数结果为1妈妈说小明太棒了</code></pre><blockquote><p>小明和他爸爸都喜欢看动画片。于是小明的妈妈在电视上加了年龄权限，当爸爸在看天线宝宝时，会提醒他别看啦（增加函数权限）。而小明在看时，就不会提醒（不破坏原函数）</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">accessTV</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> age<span class="token operator">&lt;=</span><span class="token number">18</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"小明的爸爸，你都成年啦，别看天线宝宝啦"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> wapper@accessTV<span class="token keyword">def</span> <span class="token function">watchTV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"小明在看天线宝宝"</span><span class="token punctuation">)</span>age<span class="token operator">=</span><span class="token number">10</span>watchTV<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为：</p><pre><code>age小于等于18时，函数输出：小明在看天线宝宝age大于18时，函数输出：小明的爸爸，你都成年啦，别看天线宝宝啦</code></pre><p><a href="https://www.youtube.com/watch?v=QqRvteWBSWg" target="_blank" rel="noopener">参考1</a>,<a href="https://www.zhihu.com/question/26930016/answer/360300235" target="_blank" rel="noopener">参考2</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：前缀和技巧</title>
      <link href="/2020/08/12/labuladong/di-san-zhang-qian-zhui-he-ji-qiao/"/>
      <url>/2020/08/12/labuladong/di-san-zhang-qian-zhui-he-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/qian-zhui-he-ji-qiao" target="_blank" rel="noopener">前缀和技巧</a></p><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/qian-zhui-he-si-xiang-560-he-wei-kde-zi-shu-zu-by-/" target="_blank" rel="noopener">560. 和为K的子数组</a></p><p>具体算法：</p><ul><li>维护一个 hashmap，hashmap 的 <strong>key 为累加值 acc，value 为累加值 acc 出现的次数</strong>。</li><li>遍历数组，然后不断更新 acc 和 hashmap，如果 acc 等于 k，那么很明显应该+1. 如果 hashmap[acc - k] 存在，我们就把它加到结果中去即可。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">subarraySum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict        record<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        res<span class="token operator">=</span><span class="token number">0</span>        record<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        presum<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            presum<span class="token operator">+=</span>i            <span class="token keyword">if</span> presum<span class="token operator">-</span>k <span class="token keyword">in</span> record<span class="token punctuation">:</span>                res<span class="token operator">+=</span>record<span class="token punctuation">[</span>presum<span class="token operator">-</span>k<span class="token punctuation">]</span>            record<span class="token punctuation">[</span>presum<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：双指针技巧总结</title>
      <link href="/2020/08/12/labuladong/di-san-zhang-shuang-zhi-zhen-ji-qiao-zong-jie/"/>
      <url>/2020/08/12/labuladong/di-san-zhang-shuang-zhi-zhen-ji-qiao-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/shuang-zhi-zhen-ji-qiao" target="_blank" rel="noopener">双指针技巧总结</a></p><p>利用快慢指针或者左右指针解决问题</p><h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></h1><p>利用快慢指针，一开始都指到头结点处，然后每次快指针走两步，慢指针。若最后相遇了，说明有环</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: bool        """</span>        slow<span class="token operator">=</span>head        fast<span class="token operator">=</span>head        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            <span class="token keyword">if</span> slow<span class="token operator">==</span>fast<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/142kuai-man-zhi-zhen-by-821218213/" target="_blank" rel="noopener">142. 环形链表 II</a></h1><p>返回入环的第一个链表</p><ul><li>快慢指针相遇后，把任意一个指针指向头结点，当他们再次相遇时，即是入环口<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token triple-quoted-string string">"""      :type head: ListNode      :rtype: ListNode      """</span>      <span class="token comment" spellcheck="true"># 找到相遇点</span>      slow<span class="token punctuation">,</span>fast<span class="token operator">=</span>head<span class="token punctuation">,</span>head      <span class="token keyword">while</span> fast<span class="token operator">!=</span>None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>          slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next          fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next          <span class="token keyword">if</span> slow<span class="token operator">==</span>fast<span class="token punctuation">:</span>              <span class="token keyword">break</span>      <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> None      slow<span class="token operator">=</span>head      <span class="token keyword">while</span> slow<span class="token operator">!=</span>fast<span class="token punctuation">:</span>          slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next          fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next      <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="倒数第k个节点"><a href="#倒数第k个节点" class="headerlink" title="倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/" target="_blank" rel="noopener">倒数第k个节点</a></h1><ul><li>让快指针先走k步，然后快慢指针一起同步走。快指针到达终点时，慢指针指向的就是倒数第k个节点</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">kthToLast</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :type k: int        :rtype: int        """</span>        fast<span class="token punctuation">,</span>slow<span class="token operator">=</span>head<span class="token punctuation">,</span>head        <span class="token keyword">while</span> k<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#相当于 while k>0</span>            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next            k<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">while</span> fast<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 相当于while fast!=None</span>            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next        <span class="token keyword">return</span> slow<span class="token punctuation">.</span>val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="两数之和2"><a href="#两数之和2" class="headerlink" title="两数之和2"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">两数之和2</a></h1><ul><li>只要数组有序，就应该想到双指针技巧</li><li>类似于二分查找，通过调节左右指针，得到目标和<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>      left<span class="token operator">=</span><span class="token number">0</span>      right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>      <span class="token keyword">while</span> left<span class="token operator">&lt;</span>right<span class="token punctuation">:</span>          <span class="token keyword">if</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>              right<span class="token operator">-=</span><span class="token number">1</span>          <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>              left<span class="token operator">+=</span><span class="token number">1</span>          <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>              <span class="token keyword">return</span> <span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>      <span class="token keyword">else</span><span class="token punctuation">:</span>          <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="两数之和1（无序）"><a href="#两数之和1（无序）" class="headerlink" title="两数之和1（无序）"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和1（无序）</a></h1><ul><li>遍历过程中，利用字典保存值对应的下标。若找到目标和，则返回下标</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type target: int        :rtype: List[int]        """</span>    <span class="token comment" spellcheck="true"># def two_sum(nums,target):</span>        dic<span class="token operator">=</span>dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> target<span class="token operator">-</span>v  <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                <span class="token keyword">return</span> i<span class="token punctuation">,</span> dic<span class="token punctuation">[</span>target<span class="token operator">-</span>v<span class="token punctuation">]</span>            dic<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span>i          <span class="token comment" spellcheck="true"># for i,j in enumerate(nums):</span>        <span class="token comment" spellcheck="true">#     if target-j in nums[i+1:]:</span>        <span class="token comment" spellcheck="true">#         return i, i+1+nums[i+1:].index(target-j)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></h1><ul><li>利用同步赋值，交换左右指针对应的值<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token triple-quoted-string string">"""      :type s: List[str]      :rtype: None Do not return anything, modify s in-place instead.      """</span>      left<span class="token operator">=</span><span class="token number">0</span>      right<span class="token operator">=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>      <span class="token keyword">while</span> left<span class="token operator">&lt;</span>right<span class="token punctuation">:</span>          s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span>          left<span class="token operator">+=</span><span class="token number">1</span>          right<span class="token operator">-=</span><span class="token number">1</span>      <span class="token keyword">return</span> s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：回溯算法最佳实践：括号生成</title>
      <link href="/2020/08/12/labuladong/di-san-zhang-hui-su-suan-fa-zui-jia-shi-jian-gua-hao-sheng-cheng/"/>
      <url>/2020/08/12/labuladong/di-san-zhang-hui-su-suan-fa-zui-jia-shi-jian-gua-hao-sheng-cheng/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/he-fa-kuo-hao-sheng-cheng" target="_blank" rel="noopener">回溯算法最佳实践：括号生成</a></p><p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></p><p>问题转化为：<strong>现在有 2n 个位置，每个位置可以放置字符 ( 或者 )，求生成所有可能的并且 有效的 括号组合</strong></p><ul><li>可用的左括号数量为 left 个，可用的右括号数量为 rgiht 个。cur表示当前字符串状态</li><li>左右括号都能用完，说明是合法的，res中记录当前cur</li><li>剩下的左括号比右括号多，或者括号数量小于0，说明是不合法的，直接return</li><li>回溯：做选择，撤销选择</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type n: int        :rtype: List[str]        """</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        choose<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'('</span><span class="token punctuation">,</span><span class="token string">')'</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>cur<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 还可以放几个左括号/右括号，当前字符串的状态</span>            <span class="token comment" spellcheck="true"># 合法的情况</span>            <span class="token keyword">if</span> left<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> right<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 左右括号都用完了，合法</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token comment" spellcheck="true"># 不合法的情况</span>            <span class="token comment" spellcheck="true"># 剩下的左括号比右括号多，或者括号数量小于0</span>            <span class="token keyword">if</span> left<span class="token operator">></span>right <span class="token operator">or</span> left<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> right<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token comment" spellcheck="true"># 回溯， 有两种方法</span>            <span class="token comment" spellcheck="true"># 方法1：以左括号为例</span>            cur<span class="token operator">=</span>cur<span class="token operator">+</span>choose<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 做选择 ，尝试放左括号</span>            backtrack<span class="token punctuation">(</span>left<span class="token number">-1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>cur<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># </span>            cur<span class="token operator">=</span>cur<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#撤销选择</span>            <span class="token comment" spellcheck="true"># 方法2：以右括号为例，直接在backtrack中进行更新</span>            backtrack<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token number">-1</span><span class="token punctuation">,</span>cur<span class="token operator">+</span>choose<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        backtrack<span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：递归反转链表的一部分</title>
      <link href="/2020/08/12/labuladong/di-er-zhang-di-gui-fan-zhuan-lian-biao-de-yi-bu-fen/"/>
      <url>/2020/08/12/labuladong/di-er-zhang-di-gui-fan-zhuan-lian-biao-de-yi-bu-fen/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/di-gui-fan-zhuan-lian-biao-de-yi-bu-fen" target="_blank" rel="noopener">递归反转链表的一部分</a></p><h1 id="方法1-递归反转链表"><a href="#方法1-递归反转链表" class="headerlink" title="方法1.递归反转链表 "></a>方法1.<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/pythondi-gui-jie-jue-by-clark-12/" target="_blank" rel="noopener"><del>递归反转链表</del> </a></h1><p>（只是说明递归方法的思想，本题优解应参考方法二）</p><blockquote><ul><li>先看例题<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转整个链表</a><ul><li>对于递归算法，最重要的就是<strong>明确递归函数实现的功能</strong><del>（而不是跳进递归中）</del> ，因此，reverseList函数定义为：输入一个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点    </li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 递归结束条件</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None <span class="token operator">or</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span> <span class="token keyword">return</span> head        <span class="token comment" spellcheck="true"># reverseList函数返回反转后的头结点</span>        last<span class="token operator">=</span>self<span class="token punctuation">.</span>reverseList<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span>        head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">=</span>head        head<span class="token punctuation">.</span>next<span class="token operator">=</span>None        <span class="token keyword">return</span> last ```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><p>先用递归实现：       反转以head开头的前n个节点</p></li><li><p>首先，如果 m == 1（因为头结点是从1开始计数的），就相当于反转链表开头的 n 个元素，也就是函数<code>reverseN(head, n)</code>   (也是<code>reverseBetween</code>结束递归的条件)</p></li><li><p>如果 m != 1 怎么办？如果我们把 head 的索引视为 1，那么我们是想从第 m 个元素开始反转；如果把 head.next 的索引视为 1 呢？那么相对于 head.next，反转的区间应该是从第 m - 1 个元素开始的；那么对于 head.next.next 呢……因此有：</p><pre class="line-numbers language-python"><code class="language-python">      <span class="token comment" spellcheck="true"># 如果不是第一个，那么以下一个为头结点开始递归，直到触发m==1递归终止条件</span>      head<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>reverseBetween<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>综上，反转m到n直接的节点的整体代码为：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 先用递归实现：       反转以head开头的前n个节点</span>      <span class="token keyword">def</span> <span class="token function">reverseN</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>              successor <span class="token operator">=</span> head<span class="token punctuation">.</span>next <span class="token comment" spellcheck="true"># 拿到后继节点</span>              <span class="token keyword">return</span> head<span class="token punctuation">,</span> successor          <span class="token comment" spellcheck="true"># 以 head.next 为起点，需要反转前 n - 1 个节点</span>          last<span class="token punctuation">,</span> successor <span class="token operator">=</span> reverseN<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span>          head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head          head<span class="token punctuation">.</span>next <span class="token operator">=</span> successor          <span class="token keyword">return</span> last<span class="token punctuation">,</span> successor      <span class="token keyword">if</span> m <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 递归终止条件</span>          res<span class="token punctuation">,</span> _ <span class="token operator">=</span> reverseN<span class="token punctuation">(</span>head<span class="token punctuation">,</span> n<span class="token punctuation">)</span>          <span class="token keyword">return</span> res      <span class="token comment" spellcheck="true"># 如果不是第一个，那么以下一个为头结点开始递归，直到触发条件</span>      head<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>reverseBetween<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="方法2-找到要翻转部分的链表-将其翻转-再与原链表拼接"><a href="#方法2-找到要翻转部分的链表-将其翻转-再与原链表拼接" class="headerlink" title="方法2. 找到要翻转部分的链表,将其翻转,再与原链表拼接"></a>方法2. <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/liang-chong-fang-fa-by-powcai/" target="_blank" rel="noopener">找到要翻转部分的链表,将其翻转,再与原链表拼接</a></h1></li></ul><blockquote><ol><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/" target="_blank" rel="noopener">复习一下逐个反转链表元素的代码：</a><ul><li>pre -&gt; cur (pre在前，cur 在后)</li><li>把cur的next指向pre，然后pre和cur分别向右跳一格。（利用<strong>同步赋值语句</strong>同时实现这些功能） </li></ul></li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>        pre<span class="token operator">=</span>None        cur<span class="token operator">=</span>head        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>            cur<span class="token punctuation">.</span>next<span class="token punctuation">,</span>pre<span class="token punctuation">,</span>cur<span class="token operator">=</span>pre<span class="token punctuation">,</span>cur<span class="token punctuation">,</span>cur<span class="token punctuation">.</span>next        <span class="token keyword">return</span> pre <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>先添加dummy节点，并连接在头结点前面</li><li>cur跳到位置m处，pre在cur左面</li><li>反转m到n的节点</li><li>连接各节点</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self):</span><span class="token comment" spellcheck="true">#         self.val=x</span><span class="token comment" spellcheck="true">#         self.next=None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        dummy<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        dummy<span class="token punctuation">.</span>next<span class="token operator">=</span>head        pre<span class="token operator">=</span>dummy        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            pre<span class="token operator">=</span>pre<span class="token punctuation">.</span>next        cur<span class="token operator">=</span>pre<span class="token punctuation">.</span>next        node<span class="token operator">=</span>pre        <span class="token comment" spellcheck="true"># node保存m的前一个节点，为后续连接做准备</span>        <span class="token comment" spellcheck="true"># cur为反转的当前节点，node为cur的上一个节点 </span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">-</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#反转m到n的节点</span>            cur<span class="token punctuation">.</span>next<span class="token punctuation">,</span>node<span class="token punctuation">,</span>cur<span class="token operator">=</span>node<span class="token punctuation">,</span>cur<span class="token punctuation">,</span>cur<span class="token punctuation">.</span>next <span class="token comment" spellcheck="true">#注意顺序，cur.next 在最前</span>        <span class="token comment" spellcheck="true">#连接反转后的各节点</span>        pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">=</span>cur        pre<span class="token punctuation">.</span>next<span class="token operator">=</span>node        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：特殊数据结构：单调队列</title>
      <link href="/2020/08/05/labuladong/di-er-zhang-te-shu-shu-ju-jie-gou-dan-diao-dui-lie/"/>
      <url>/2020/08/05/labuladong/di-er-zhang-te-shu-shu-ju-jie-gou-dan-diao-dui-lie/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/dan-tiao-dui-lie" target="_blank" rel="noopener">特殊数据结构：单调队列</a></p><h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/python-deque-by-frankchen250/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></h1><h2 id="方法1：更新滑动窗口法（暴力遍历，超时）"><a href="#方法1：更新滑动窗口法（暴力遍历，超时）" class="headerlink" title="方法1：更新滑动窗口法（暴力遍历，超时）"></a><del>方法1：更新滑动窗口法（暴力遍历，超时）</del></h2><ul><li>滑动窗口没有完全进入数组时，把数据加入窗口中</li><li>窗口完全进入数组后，保存最大值，同时弹出窗口最左侧的元素（即，右边进，左边出，更新窗口），继续进行下一次循环</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        window<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 滑动窗口未完全进入数组，把元素添加到窗口中</span>                window<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                window<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>max<span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 记录窗口中最大值</span>                window<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 弹出窗口最左边的元素</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法二：维护一个递减的单调队列"><a href="#方法二：维护一个递减的单调队列" class="headerlink" title="方法二：维护一个递减的单调队列"></a>方法二：维护一个递减的单调队列</h2><p><strong>踩扁前面比他小的数</strong><br><img src="https://img-blog.csdnimg.cn/20200624150009357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt="图片来自labuladong"><br><img src="https://img-blog.csdnimg.cn/20200624145943325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt="图片来自labuladong"><br><img src="https://img-blog.csdnimg.cn/20200624145958795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt="图片来自labuladong"></p><blockquote><blockquote><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p></blockquote><p>返回滑动窗口中的最大值。</p><p>进阶：</p><p>你能在线性时间复杂度内解决此题吗？</p><p>示例:<br>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7]  解释: </p></blockquote><table><thead><tr><th>滑动窗口的位置</th><th>最大值</th></tr></thead><tbody><tr><td>[1  3  -1] -3  5  3  6  7</td><td>3</td></tr><tr><td>1 [3  -1  -3] 5  3  6  7</td><td>3</td></tr><tr><td>1  3 [-1  -3  5] 3  6  7</td><td>5</td></tr><tr><td>1  3  -1 [-3  5  3] 6  7</td><td>5</td></tr><tr><td>1  3  -1  -3 [5  3  6] 7</td><td>6</td></tr><tr><td>1  3  -1  -3  5 [3  6  7]</td><td>7</td></tr></tbody></table><blockquote><p>遍历过程中，deque中存储的元素：</p><p>deque([1])    （前两次窗口未满）<br>deque([3])      （前两次窗口未满）<br>deque([3, -1])<br>deque([-1, -3])   （当前窗口中的元素为[3,-1,-3],但我们要确保下一个元素能被加到队列中，因此，如果队列中最左边的元素为nums[i - k + 1]，则把它删掉，否则不用删（已经被压扁了））<br>deque([5])<br>deque([5, 3])<br>deque([6])<br>deque([7])</p></blockquote><ul><li>双端队列中存储着压扁后剩下的结果 （确保队列单调递减）</li><li>队列中的最大值有重复时，保留重复（只踩扁比它小的数，相同的不踩，确保次序一致）</li><li><strong>之所以要判断<code>queue[0] == n</code>，是因为我们想删除的队头元素 n 可能已经被「压扁」了，这时候就不用删除了</strong><ul><li>双端队列中最多<strong>存储着<code>k-1</code> 个</strong>元素，以确保下一次循环时，元素能被加到队列中。因此，若加进来的元素一直压不扁队头，但队列已满时，要删掉最左边的队头元素 （如果已经压扁过了，那么<code>queue[0] == nums[i - k + 1]</code>不成立 ,不用删了）</li><li>以滑动窗口位置在<code>1 [3 -1 -3] 5 3 6 7</code>  为例，现在的队列是[3,-1,-3] (-1 和 -3 都没能压扁3，说明这时<code>queue[0] == nums[i - k + 1]</code>，在窗口向右挪动时，这个3就要过时了)，为了给后面的元素腾出空位，把队列最左边的元素删掉，让队列变成[-1,-3]</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">push_num</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 把元素n加入双端队列，小于n的元素被n踩扁</span>            <span class="token keyword">while</span> queue <span class="token operator">and</span> queue<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>n<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">pop_num</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 把最左端的元素n（若存在）弹出双端队列</span>            <span class="token keyword">if</span> queue <span class="token operator">and</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> n<span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 双端队列没有完全进入列表，则把该元素加入队列</span>                push_num<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                push_num<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 把该元素加入队列</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 最左端为最大值</span>                pop_num<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 删除位置为i-k+1的元素 （若已经被压扁了，则不用删了）</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：特殊数据结构：单调栈</title>
      <link href="/2020/08/05/labuladong/di-er-zhang-te-shu-shu-ju-jie-gou-dan-diao-zhan/"/>
      <url>/2020/08/05/labuladong/di-er-zhang-te-shu-shu-ju-jie-gou-dan-diao-zhan/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/dan-tiao-zhan" target="_blank" rel="noopener">特殊数据结构：单调栈</a></p><blockquote><p>文章例题：<br>给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。<br>解释：第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。</p></blockquote><p>这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人站成一列（你站在右边看他们，且逆序遍历），如何求元素「2」的 Next Greater Number 呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的 Next Greater Number，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。</p><p>这就是单调队列解决问题的模板。<strong>for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个“高个”元素之间的元素排除，因为他们的存在没有意义，前面挡着个“更高”的元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了。</strong><br><img src="https://img-blog.csdnimg.cn/20200623194612914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt="图片来自labuladong"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    ans<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    s<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#倒着往栈里放</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">while</span>  s <span class="token operator">and</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#矮个起开</span>            s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">if</span>  s <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>        s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 进队，接受之后的身高判定</span>    <span class="token keyword">return</span> ansnums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ans:"</span><span class="token punctuation">,</span>nextGreaterElement<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果输出：</p><blockquote><p>每次的s:<br>[]<br>[3]<br>[4]<br>[4, 2]<br>[4, 2, 1]</p><p>ans: [4, 2, 4, -1, -1]</p></blockquote><h1 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">503. 下一个更大元素 II</a></h1><ul><li>从<strong>最后一个</strong>元素开始逆序遍历，维护一个单调递减的<strong>栈</strong>。</li><li>因为这个栈是<strong>先进后出</strong>，且<strong>单调递减</strong>的，所以弹出栈中<strong>小于等于</strong>当前元素的值后，栈顶的元素就是找到的结果</li><li>把<strong>当前元素入栈</strong>，这样，它前面的元素才能和它继续比较 </li><li>根据不同输出结果的要求，栈中存放当前元素对应的信息，此题存放<strong>当前元素</strong></li></ul><blockquote><p>以 [2,1,2,4,3] 为例，<code>nums*2</code> 后得[2,1,2,,4,3,2,1,2,4,3] （扩充数组，以便求取最后一个值对应的结果）。<br>当前值对应的结果为栈中当前值所在的<strong>前一个</strong>元素（记录结果后才把当前值入栈），当前值前面没有元素，则结果为-1</p><p>则逆序遍历过程中：<br>当前值为：3，加入当前值后对应的栈为[3]   （无解，-1）<br>当前值为：4，加入当前值后对应的栈为[4] （无解，-1）<br>当前值为：2，加入当前值后对应的栈为[<strong>4</strong>, 2]<br>当前值为：1，加入当前值后对应的栈为[4, <strong>2</strong>, 1]<br>当前值为：2，加入当前值后对应的栈为[<strong>4</strong>, 2]<br><em>当前值为：3，加入当前值后对应的栈为[<strong>4</strong>, 3]<br>当前值为：4，加入当前值后对应的栈为[4]   （无解，-1）<br>当前值为：2，加入当前值后对应的栈为[<strong>4</strong>, 2]<br>当前值为：1，加入当前值后对应的栈为[4, <strong>2</strong>, 1]<br>当前值为：2，加入当前值后对应的栈为[<strong>4</strong>, 2]</em></p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nextGreaterElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[int]        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        nums<span class="token operator">=</span>nums<span class="token operator">*</span><span class="token number">2</span>  <span class="token comment" spellcheck="true"># 扩充数组</span>        ans<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 初始化</span>        s<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 逆序遍历</span>            <span class="token keyword">while</span> s <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 1.弹出栈中小于等于当前元素的值</span>                s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> s <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment" spellcheck="true"># 2.弹出不符合的元素后，栈顶元素就是所求的结果</span>            s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 3. 当前元素入栈，这样，它前面的元素才能和它继续比较</span>        <span class="token keyword">return</span> ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I</a></h1><ul><li>该题与上题的区别是： <ul><li>上题直接给定列表，在逆序遍历的同时，更新单调栈</li><li>本题中，对任意的nums1[i], 需要找到当前元素在nums2 中的位置，并把该位置及其后面的元素取出来并反转后作为栈<code>s</code> 中的内容 （<code>nums2[nums2.index(nums1[i]):][::-1]</code>）,然后进行比较。 <ul><li>（这里并不是维护单调递减的栈，而是把找到的反转栈从尾部开始逐个弹出不符合条件的元素，最终得到结果）</li></ul></li><li>根据不同输出结果的要求，栈中存放当前元素的信息，此题存放<strong>当前元素在nums2中对应的本身及其后面的元素（并反转）</strong></li></ul></li></ul><blockquote><p>以 nums1=[4,1,2]， nums2=[1,3,4,2] 为例，<br>则逆序遍历过程中：<br>当前值为2,对应的反转后的栈为[2]<br>当前值为1,对应的反转后的栈为[2, 4, 3, 1]<br>（解释：<em>nums2中找到1的位置，1及其1后面的元素为[1,3,4,2],反转后为[2,4,3,1]）</em><br>当前值为4,对应的反转后的栈为[2, 4]</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">,</span> nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums1<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#若为空数组，则返回</span>        ans<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#逆序遍历</span>            <span class="token comment" spellcheck="true"># 用反转，使得pop的顺序一致</span>            <span class="token comment" spellcheck="true"># 比如1 要和[1,3,4,2]比，输出3</span>            <span class="token comment" spellcheck="true"># 则反转后为[2,4,3,1], 弹1，得到3为符合条件的值</span>            s<span class="token operator">=</span>nums2<span class="token punctuation">[</span>nums2<span class="token punctuation">.</span>index<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 找到每个元素对应的栈，并反转</span>            <span class="token keyword">while</span> s <span class="token operator">and</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 1.弹出栈中小于等于当前元素的值</span>                s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#矮个起开</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> s <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment" spellcheck="true"># 2.弹出不符合的元素后，栈顶元素就是所求的结果</span>        <span class="token keyword">return</span> ans<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739.每日温度</a></h1><ul><li>用栈记录的是list中元素的index，而不是list中元素值本身 （与503题类似，根据不同输出结果的要求，栈中存放当前元素的信息，此题存放<strong>当前元素的index下标</strong>）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type T: List[int]        :rtype: List[int]        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> T <span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        ans<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        s<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 这里放元素索引，而不是元素</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> s <span class="token operator">and</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>T<span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>i <span class="token keyword">if</span> s <span class="token keyword">else</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 得到索引间距</span>            s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 放入索引</span>        <span class="token comment" spellcheck="true"># print(ans)</span>        <span class="token keyword">return</span> ansT<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">73</span><span class="token punctuation">,</span> <span class="token number">74</span><span class="token punctuation">,</span> <span class="token number">75</span><span class="token punctuation">,</span> <span class="token number">71</span><span class="token punctuation">,</span> <span class="token number">69</span><span class="token punctuation">,</span> <span class="token number">72</span><span class="token punctuation">,</span> <span class="token number">76</span><span class="token punctuation">,</span> <span class="token number">73</span><span class="token punctuation">]</span>so<span class="token operator">=</span>Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>so<span class="token punctuation">.</span>dailyTemperatures<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：如何计算完全二叉树的节点数</title>
      <link href="/2020/08/02/labuladong/di-er-zhang-ru-he-ji-suan-wan-quan-er-cha-shu-de-jie-dian-shu/"/>
      <url>/2020/08/02/labuladong/di-er-zhang-ru-he-ji-suan-wan-quan-er-cha-shu-de-jie-dian-shu/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://mp.weixin.qq.com/s/xW2fbE3v4JhMSKfxoxIHBg" target="_blank" rel="noopener">如何计算完全二叉树的节点数</a></p><h1 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></h1><ul><li>完全二叉树都是<strong>紧凑靠左排列</strong>的</li><li>满二叉树<strong>每一层都是满的</strong> （除底层的叶子节点外，左右孩子都有），<strong>是一种特殊的完全二叉树</strong></li></ul><p>遍历二叉树节点时：</p><ol><li>若是普通的二叉树，则在遍历节点时计数即可</li><li>若是满二叉树，则说明左右子树的高度相等，节点个数=2^高度-1</li></ol><p>因此，若判断该完全二叉树是满二叉树，则用情况2，否则用情况1</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        l<span class="token punctuation">,</span>r<span class="token operator">=</span>root<span class="token punctuation">,</span>root        hl<span class="token punctuation">,</span>hr<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        <span class="token keyword">while</span> l<span class="token operator">!=</span>None<span class="token punctuation">:</span>            l<span class="token operator">=</span>l<span class="token punctuation">.</span>left            hl<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">while</span> r<span class="token operator">!=</span>None<span class="token punctuation">:</span>            r<span class="token operator">=</span>r<span class="token punctuation">.</span>right            hr<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">if</span> hl<span class="token operator">==</span>hr<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 左右子树高度相等，是满二叉树，用公式计算</span>            <span class="token keyword">return</span> pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>hl<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>self<span class="token punctuation">.</span>countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">+</span>self<span class="token punctuation">.</span>countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 普通二叉树，用递归方法计算</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：二叉搜索树操作集锦</title>
      <link href="/2020/08/02/labuladong/di-er-zhang-er-cha-sou-suo-shu-cao-zuo-ji-jin/"/>
      <url>/2020/08/02/labuladong/di-er-zhang-er-cha-sou-suo-shu-cao-zuo-ji-jin/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/er-cha-sou-suo-shu-cao-zuo-ji-jin" target="_blank" rel="noopener">二叉搜索树操作集锦</a></p><ul><li><p>二叉树</p><ul><li>二叉树算法设计的总路线：<strong>把当前节点要做的事做好，其他的交给递归框架，不用当前节点操心。</strong>    （可以理解成<strong>递归</strong>方法的应用）<ul><li>明确递归结束的条件 （已经到了叶子节点）</li><li>把root该做的事情做完， 然后左右子节点递归调用该方法</li></ul></li><li>如果当前节点会对下面的子节点<strong>有整体影响</strong>，可以通过<strong>辅助函数增长参数列表</strong>，借助参数传递信息。<pre class="line-numbers language-python"><code class="language-python">void traverse<span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">//</span> root 需要做什么？在这做。<span class="token operator">//</span> 其他的不用 root 操心，抛给框架traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>二叉搜索树</p><ul><li>定义：任意<strong>节点的值要大于等于左子树所有节点</strong>的值，且要<strong>小于等于右子树的所有节点</strong>的值。</li><li>因此，<strong>中序遍历</strong>二叉搜索树后，可以得到<strong>递增</strong>数组。<pre class="line-numbers language-python"><code class="language-python">void BST<span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> int target<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">==</span> target<span class="token punctuation">)</span>  <span class="token operator">//</span> 找到目标，做点什么<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> target<span class="token punctuation">)</span>   BST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> target<span class="token punctuation">)</span>  BST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h1 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/solution/ji-yu-xie-shu-suan-fa-de-tao-lu-kuang-jia-de-pytho/" target="_blank" rel="noopener">100. 相同的树</a></h1><ul><li>函数内先判断两个root节点是否相等，然后递归调用该函数，判断左右子节点是否相等</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type p: TreeNode        :type q: TreeNode        :rtype: bool        """</span>        <span class="token keyword">if</span> p<span class="token operator">==</span>None <span class="token operator">and</span> q <span class="token operator">==</span>None<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span> <span class="token comment" spellcheck="true"># 都为空节点</span>        <span class="token keyword">if</span> p<span class="token operator">==</span>None <span class="token operator">or</span> q <span class="token operator">==</span>None<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span> <span class="token comment" spellcheck="true"># 其中一个为空节点</span>        <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">!=</span>q<span class="token punctuation">.</span>val<span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token boolean">False</span> <span class="token comment" spellcheck="true"># 值不相等</span>        <span class="token comment" spellcheck="true"># 调用递归，判断左右子树是否都满足isSameTree</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>isSameTree<span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">,</span>q<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>isSameTree<span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">,</span>q<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="面试题-04-05-合法二叉搜索树"><a href="#面试题-04-05-合法二叉搜索树" class="headerlink" title="面试题 04.05. 合法二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/die-dai-yu-di-gui-by-powcai/" target="_blank" rel="noopener">面试题 04.05. 合法二叉搜索树</a></h1><h2 id="方法1：利用携带的最大最小值进行判断"><a href="#方法1：利用携带的最大最小值进行判断" class="headerlink" title="方法1：利用携带的最大最小值进行判断"></a>方法1：利用携带的最大最小值进行判断</h2><ul><li><p>root 需要做的不只是和左右子节点比较，而是要和整个左子树和右子树<strong>所有节点</strong>比较</p></li><li><p>使用辅助函数，增加函数参数列表，在<strong>参数中携带额外信息</strong>（当前节点需要比较的最小值和最大值）</p><ul><li>直接赋予最小值<code>-float(&quot;inf&quot;)</code>、最大值<code>float(&quot;inf&quot;)</code>，在递归的过程中修改最值（<strong>自顶向下</strong>的过程中，<strong>右子树的最小值从<code>-float(&quot;inf&quot;)</code> 逐渐增大，左子树的最大值从<code>float(&quot;inf&quot;)</code> 逐渐减小</strong>）</li></ul></li></ul><blockquote><p>以该不合法的二叉搜索树树为例：</p><ul><li>遍历到15 时，15与 <code>[10, float(&quot;inf&quot;)]</code> 比较，结果是True（此时最小值为10）</li><li>对于15的左子树，它应该在[10,15] 范围内，但现在是6，结果为False <img src="https://img-blog.csdnimg.cn/20200802113813779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt></li></ul></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: bool        """</span>        <span class="token keyword">def</span> <span class="token function">valid</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>mi<span class="token punctuation">,</span>ma<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">&lt;=</span>mi<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">>=</span>ma<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">return</span> valid<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> mi <span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">and</span> valid<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> ma<span class="token punctuation">)</span>        <span class="token keyword">return</span> valid<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token operator">-</span>float<span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> float<span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法2：中序遍历二叉搜索树后，判断其是否为没有重复元素的递增数组"><a href="#方法2：中序遍历二叉搜索树后，判断其是否为没有重复元素的递增数组" class="headerlink" title="方法2：中序遍历二叉搜索树后，判断其是否为没有重复元素的递增数组"></a>方法2：中序遍历二叉搜索树后，判断其是否为没有重复元素的递增数组</h2><ul><li>最后的<code>return nodes == sorted(set(nodes))</code>, 要<strong>先set，再 sorted</strong>，这样返回的是列表形式，即判断列表是否等于列表（<del>若先sorted，再set，返回的是一个集合，即判断列表是否等于集合，出现错误）</del> 。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: bool        """</span>        nodes<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 中序遍历后，判断其是否递增</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>            inOrder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            inOrder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">return</span> nodes        inOrder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> nodes <span class="token operator">==</span> sorted<span class="token punctuation">(</span>set<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700. 二叉搜索树中的搜索</a></h1><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :type val: int        :rtype: TreeNode        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> None        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>val<span class="token punctuation">:</span> <span class="token keyword">return</span> root        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">></span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> seatchBST<span class="token punctuation">(</span>self<span class="token punctuation">,</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>val<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> searchBST<span class="token punctuation">(</span>self<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="701-二叉搜索树的插入操作"><a href="#701-二叉搜索树的插入操作" class="headerlink" title="701.二叉搜索树的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/submissions/" target="_blank" rel="noopener">701.二叉搜索树的插入操作</a></h1><p>对数据结构的操作无非遍历 + 访问，遍历就是“找”，访问就是“改”。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。</p><p>上一个问题，我们总结了 BST 中的遍历框架，就是“找”的问题。直接套框架，加上“改”的操作即可。一旦涉及“<strong>改</strong>”，函数就要<strong>返回 TreeNode 类型</strong>，并且<strong>对递归调用的返回值进行接收。</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :type val: int        :rtype: TreeNode        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>val<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">if</span> val<span class="token operator">></span>root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>insertIntoBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>val<span class="token punctuation">)</span>        <span class="token keyword">elif</span> val<span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>insertIntoBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>val<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></h1><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :type key: int        :rtype: TreeNode        """</span>        <span class="token comment" spellcheck="true"># 若无根节点，直接返回</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span><span class="token keyword">return</span> None        <span class="token comment" spellcheck="true"># 若找到目标值</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>key<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 处理无子节点/只有一个子节点的情况</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token operator">==</span>None<span class="token punctuation">:</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>right            <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token operator">==</span>None<span class="token punctuation">:</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>left            <span class="token comment" spellcheck="true"># 找到右子树的最左（小）节点，并替换</span>            minNode<span class="token operator">=</span>self<span class="token punctuation">.</span>getMin<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            root<span class="token punctuation">.</span>val<span class="token operator">=</span>minNode<span class="token punctuation">.</span>val            <span class="token comment" spellcheck="true"># 转而删除最小节点</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>minNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 二叉搜索树</span>        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val<span class="token operator">></span>key<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>key<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> root    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 最小值一定在左叶子节点处</span>        <span class="token keyword">while</span> root<span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>            root<span class="token operator">=</span>root<span class="token punctuation">.</span>left        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/liang-chong-die-dai-by-powcai/" target="_blank" rel="noopener"><strong>前序、中序、后序、层序遍历 打包，讲解很棒！</strong></a></p><p>只需要<strong>改变遍历的顺序</strong>即可</p><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/di-gui-he-die-dai-by-powcai-5/" target="_blank" rel="noopener">前序遍历</a></h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[int]        """</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span><span class="token keyword">return</span>             res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/dong-hua-yan-shi-94-er-cha-shu-de-zhong-xu-bian-li/" target="_blank" rel="noopener">中序遍历</a></h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[int]        """</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span>             helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/liang-chong-die-dai-by-powcai/" target="_blank" rel="noopener">后序遍历</a></h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>                <span class="token keyword">return</span>             helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><h3 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/solution/mian-shi-ti-32-i-cong-shang-dao-xia-da-yin-er-ch-4/" target="_blank" rel="noopener">剑指 Offer 32 - I. 从上到下打印二叉树</a></h3><ul><li><strong>队列</strong>中存储当前层的节点，然后利用<strong>先进先出</strong>特性得到结果 。构建队列： <code>queue = collections.deque()</code><ul><li>同一层的节点，左儿子先进入，右儿子后进入 （如 queue的 2，3）</li><li>对于子节点，左儿子弹出后，将左儿子的左右孙子连接到右儿子后面（如 queue的3，4，5）。右儿子弹出后，将右儿子的左右孙子继续连接到左儿子的左右孙子后面（如 queue的 4,5,6,7）</li></ul></li></ul><blockquote><p>以如下二叉树为例，说明队列的先进先出，并得到层序遍历的打印结果[1,2,3,4,5,6,7]<br><img src="https://img-blog.csdnimg.cn/2020080220292811.png" alt>          </p><table><thead><tr><th>res（存储节点的值）</th><th>queue （存储节点，因为要判断是否有左右子节点）</th></tr></thead><tbody><tr><td>[]</td><td>1</td></tr><tr><td>[1]</td><td>2,3</td></tr><tr><td>[1,2]</td><td>3,4,5</td></tr><tr><td>[1,2,3]</td><td>4,5,6,7</td></tr><tr><td>[1,2,3,4]</td><td>5,6,7</td></tr><tr><td>[1,2,3,4,5]</td><td>6,7</td></tr><tr><td>[1,2,3,4,5,6]</td><td>7</td></tr><tr><td>[1,2,3,4,5,6,7]</td><td>空</td></tr></tbody></table></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[int]        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        queue<span class="token operator">=</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></h3><p>上一题把所有遍历的结果保存在数组中，即<code>[1,2,3,4,5,6,7]</code>。该题与上题的不同之处在于，这一次把每一层的元素保存在结果中，即 <code>[[1],[2,3],[4,5,6,7]]</code>.</p><p>所以只需要在<code>range(len(queue))</code> 范围内，增加临时变量temp保存当前层的结果。</p><blockquote><p>注意！即便<br><code>if node.left: queue.append(node.left)</code><br><code>if node.right: queue.append(node.right)</code> 会改变queue的长度，<code>for i in range(len(queue))</code>在超出当时赋值<code>range(len(queue))</code>范围后才跳出for循环（即，i的变化范围是0|0,1|0,1,2,3|,而不会随着循环语句中queue的改变而改变for循环次数)</p><p>如：</p><pre class="line-numbers language-python"><code class="language-python">nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>结果为： 0 1 2 。不随着nums的变化而改变for循环的次数</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[List[int]]        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        queue <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                         node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：LRU算法详解</title>
      <link href="/2020/08/01/labuladong/di-er-zhang-lru-suan-fa-xiang-jie/"/>
      <url>/2020/08/01/labuladong/di-er-zhang-lru-suan-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/lru-suan-fa" target="_blank" rel="noopener">LRU算法详解</a></p><p><a href="https://leetcode-cn.com/problems/lru-cache/solution/pythonde-ordereddict-huo-zhe-ha-xi-shuang-xiang-li/" target="_blank" rel="noopener">146. LRU(Least Recently Used) 缓存机制</a></p><p>利用<strong>字典+双向链表</strong></p><ul><li>字典里存的是<strong>Node的节点类</strong>，self.add(Node(key, value))</li><li>传给add函数的是一个Node类，这个字典的<strong>键是node.key</strong>，<strong>值是Node类</strong></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 构建Node类</span><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val        self<span class="token punctuation">.</span>prev <span class="token operator">=</span> None        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 构建首尾节点, 使之相连</span>        <span class="token comment" spellcheck="true"># 之后处理head到tail之间的node</span>        self<span class="token punctuation">.</span>head <span class="token operator">=</span> Node<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>tail <span class="token operator">=</span> Node<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> self<span class="token punctuation">.</span>head        self<span class="token punctuation">.</span>lookup <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>max_len <span class="token operator">=</span> capacity    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>lookup<span class="token punctuation">:</span>            node <span class="token operator">=</span> self<span class="token punctuation">.</span>lookup<span class="token punctuation">[</span>key<span class="token punctuation">]</span>            self<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>add<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            <span class="token keyword">return</span> node<span class="token punctuation">.</span>val        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>lookup<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>self<span class="token punctuation">.</span>lookup<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 移除该节点</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>lookup<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>max_len<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 把表头位置节点删除(说明最近的数据值)</span>            self<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Node<span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 删除链表节点</span>    <span class="token keyword">def</span> <span class="token function">remove</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">del</span> self<span class="token punctuation">.</span>lookup<span class="token punctuation">[</span>node<span class="token punctuation">.</span>key<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 删除该节点</span>        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next <span class="token comment" spellcheck="true"># 更新链表</span>        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">.</span>prev    <span class="token comment" spellcheck="true"># 加在链表尾</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>lookup<span class="token punctuation">[</span>node<span class="token punctuation">.</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> node <span class="token comment" spellcheck="true"># 添加(key ,node)节点</span>        pre_tail <span class="token operator">=</span> self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev <span class="token comment" spellcheck="true">#暂存该节点</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>tail <span class="token comment" spellcheck="true">#更新链表</span>        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> node        pre_tail<span class="token punctuation">.</span>next <span class="token operator">=</span> node        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pre_tail<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：贪心算法之区间调度问题</title>
      <link href="/2020/07/31/labuladong/di-yi-zhang-tan-xin-suan-fa-zhi-qu-jian-diao-du-wen-ti/"/>
      <url>/2020/07/31/labuladong/di-yi-zhang-tan-xin-suan-fa-zhi-qu-jian-diao-du-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/tan-xin-suan-fa-zhi-qu-jian-tiao-du-wen-ti" target="_blank" rel="noopener">贪心算法之区间调度问题</a></p><h1 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. 无重叠区间</a></h1><blockquote><p>一天有好多活动，你可以选择不重叠的时间尽量多参加活动。</p><ul><li>按照活动结束的时间排序后（不管开始得多早，都不如选择早点结束的活动，这样还能继续选其他活动）<ul><li>假设当前参加的是活动A，如果活动B的开始时间大于等于活动A的结束时间，则继续参加B活动。</li><li>这时活动数+1，后面的活动开始时间要和活动B结束的时间进行比较，所以活动结束的时间更新为活动B结束的时间。</li></ul></li></ul></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">eraseOverlapIntervals</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> intervals<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> intervals<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        intervals<span class="token operator">=</span>sorted<span class="token punctuation">(</span>intervals<span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x <span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        end<span class="token operator">=</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 第0个活动结束的时间</span>        count<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 可以想象成当前活动开始的时间大于等于之前活动结束的时间，那么参加当前活动</span>            <span class="token keyword">if</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">>=</span>end<span class="token punctuation">:</span>                count<span class="token operator">+=</span><span class="token number">1</span>                end<span class="token operator">=</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">-</span>count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：动态规划之子序列问题解题模板</title>
      <link href="/2020/07/31/labuladong/di-yi-zhang-dong-tai-gui-hua-zhi-zi-xu-lie-wen-ti-jie-ti-mo-ban/"/>
      <url>/2020/07/31/labuladong/di-yi-zhang-dong-tai-gui-hua-zhi-zi-xu-lie-wen-ti-jie-ti-mo-ban/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md" target="_blank" rel="noopener">动态规划之子序列问题解题模板</a></p><h1 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a></h1><ol><li>dp数组的含义：s[i…j] 中最长回文子序列的长度保存在dp[i][j] 中</li><li>状态转移方程：如果i处和j处的字符相同，则从短串s[i+1…j-1]中扩充2（<code>dp[i][j]=dp[i+1][j-1]+2</code>）。 否则继承 s[i+1…j] ， s[i…j-1] 的最长回文子序列长度的最大值 （<code>max(dp[i+1][j],dp[i][j-1])</code>）</li><li>base case: dp 数组先初始化为 0 （而且对角线下半部分的三角形表示i &gt; j, 不可能出现这种情况，因此为0）。i 和 j 指向同一个字符时，回文子序列为其本身， 因此对角线处的dp数组元素初始化为1</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestPalindromeSubseq</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">2</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：经典动态规划：最长公共子序列</title>
      <link href="/2020/07/31/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-zui-chang-gong-gong-zi-xu-lie/"/>
      <url>/2020/07/31/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-zui-chang-gong-gong-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-chang-gong-gong-zi-xu-lie" target="_blank" rel="noopener">经典动态规划：最长公共子序列</a></p><p><em>（在dp数组中添加0行和0列可以包含text为空的情况，并且更便于状态转移）</em></p><ol><li>dp数组的含义： 对于 text1[0..i-1] 和 text2[0..j-1]，dp[i][j]中保存当前位置的最长公共子序列的长度</li><li>状态转移方程：若当前元素相等，则在之前状态下+1 （<code>dp[i][j]=dp[i-1][j-1]+1</code>）。 若不相等，则继承之前的最大值（<code>dp[i][j]=max(dp[i-1][j],dp[i][j-1])</code>）</li><li>base case : 第0行和第0列初始化为0 。（至少有一个为空字符时，不可能有公共子序列 （两个都为空时，公共子序列长度也为0））</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text1<span class="token punctuation">,</span> text2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token punctuation">(</span>text1 <span class="token operator">and</span> text2<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        m<span class="token operator">=</span>len<span class="token punctuation">(</span>text1<span class="token punctuation">)</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>text2<span class="token punctuation">)</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> text1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span>text2<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：经典动态规划：编辑距离</title>
      <link href="/2020/07/30/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-bian-ji-ju-chi/"/>
      <url>/2020/07/30/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-bian-ji-ju-chi/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/bian-ji-ju-li" target="_blank" rel="noopener">经典动态规划：编辑距离</a></p><p><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></p><p><img src="https://img-blog.csdnimg.cn/2020073020134580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt></p><ul><li>在word1 和word2 前面分别插入<code>&quot;&quot;</code> 不仅可以包括字符串为空的情况，而且可以更清楚地用空字符串说明状态转移的过程</li><li>i 和 j 中，因为最前面加了<code>&quot;&quot;</code>, 因此第i个字符的下标为i-1 <ul><li>若两个字符相等（<code>word1[i-1]==word2[j-1]</code>），则i和j分别继续向右跳一格</li><li>若不相等，则增（dp[i][j-1]，如第0行），改（dp[i-1][j-1]），删（dp[i-1][j]，如第0列）的最小操作数 +1 </li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word1<span class="token punctuation">,</span> word2<span class="token punctuation">)</span><span class="token punctuation">:</span>        m<span class="token operator">=</span>len<span class="token punctuation">(</span>word1<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>word2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>j        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>i        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> word1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span>word2<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：动态规划设计：最大子数组</title>
      <link href="/2020/07/29/labuladong/di-yi-zhang-dong-tai-gui-hua-she-ji-zui-da-zi-shu-zu/"/>
      <url>/2020/07/29/labuladong/di-yi-zhang-dong-tai-gui-hua-she-ji-zui-da-zi-shu-zu/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-da-zi-shu-zu" target="_blank" rel="noopener">动态规划设计：最大子数组</a></p><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></p><hr><p>课堂上，学生排排坐。</p><p>老师：“这门课的作业，你们可以选择自己完成，也可以根据座位顺序，和你前面的同学组队（前面的同学可能和前前面的同学组了队，也可能就他一个人）。” </p><p>每个人都想把自己的作业完成得最好。</p><p> 在座位<code>i</code>处的大佬心想：“前面可能是大大佬（可以组队, <code>dp[i-1]+nums[i]</code>），也可能是小小菜（组队会拖我后腿，还不如我自己<code>nums[i]</code>）。”  不管哪种选择，最后，他的最好成绩取这两种选择的最大值即可。</p><hr><ul><li>dp数组含义： <strong>以nums[i]结尾</strong>的当前最大子序和保存在dp[i] 中</li><li>状态转移方程：<strong>nums[i] 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组</strong><ul><li><strong>对nums[i]而言</strong>（dp数组的含义决定了子序和是以nums[i]结尾的），若连接前面的子序列，则dp[i]=dp[i-1]+nums[i]。 若不连接，则自立门户 dp[i]=nums[i] 。根据这两种选择，直接取最大值即可 <code>dp[i]=max(nums[i],dp[i-1]+nums[i])</code>。</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：动态规划设计：最长递增子序列</title>
      <link href="/2020/07/29/labuladong/di-yi-zhang-dong-tai-gui-hua-she-ji-zui-chang-di-zeng-zi-xu-lie/"/>
      <url>/2020/07/29/labuladong/di-yi-zhang-dong-tai-gui-hua-she-ji-zui-chang-di-zeng-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.md" target="_blank" rel="noopener">动态规划设计：最长递增子序列</a></p><h1 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></h1><ul><li>dp数组的含义：以nums[i] 结尾的当前最长上升子序列的长度记录在dp[i]中</li><li>状态转移方程：nums[i] 与它之前的元素nums[j]进行比较，若大于nums[j], 则比较之前保存的dp[i] 和dp[j]+1 的大小，并更新dp[i] （始终保存最大值）</li><li>base case： 上升子序列至少为自己，因此dp数组初始化为1</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：动态规划和回溯算法到底谁是谁爹？</title>
      <link href="/2020/07/29/labuladong/di-yi-zhang-dong-tai-gui-hua-he-hui-su-suan-fa-dao-di-shui-shi-shui-die/"/>
      <url>/2020/07/29/labuladong/di-yi-zhang-dong-tai-gui-hua-he-hui-su-suan-fa-dao-di-shui-shi-shui-die/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/targetsum" target="_blank" rel="noopener">动态规划和回溯算法到底谁是谁爹？</a></p><h1 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/solution/dong-tai-gui-hua-by-powcai-22/" target="_blank" rel="noopener">494. 目标和</a></h1><h2 id="方法1：动态规划（dp二维数组）"><a href="#方法1：动态规划（dp二维数组）" class="headerlink" title="方法1：动态规划（dp二维数组）"></a>方法1：动态规划（dp二维数组）</h2><p>dp[i][j]表示 <strong>数组中前i个元素组成和为j的方案数</strong></p><ol><li>base case: </li></ol><ul><li>首先初始化数组第0行。如果第一个元素为0，则<code>dp[0][total]=2</code> <ul><li>（-0 和+0 都为0，所以先初始化为2） 比如 [0,1,2], 目标和为3，则有-0+1+2=3，+0+1+2=3</li></ul></li><li>否则和为±nums[0] 的位置的方案数置为1</li></ul><pre class="line-numbers language-python"><code class="language-python">        <span class="token keyword">if</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span>            <span class="token comment" spellcheck="true"># 相当于</span>            <span class="token comment" spellcheck="true"># dp[0][total-nums[0]]=2</span>            <span class="token comment" spellcheck="true"># dp[0][total+nums[0]]=2</span>            <span class="token comment" spellcheck="true"># 只是此时nums[0]=0，因此写成 dp[0][total]=2</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token operator">-</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（或者直接用下面的代码来包含nums[0]为0 和非0的情况）</p><pre class="line-numbers language-python"><code class="language-python">        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token operator">-</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">+</span><span class="token number">1</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">+</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li><p>状态转移方程<br>保证数组的列索引在0到total*2+1范围内</p><pre class="line-numbers language-python"><code class="language-python">             l<span class="token operator">=</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">0</span>             r<span class="token operator">=</span>j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>total<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span>             dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>dp[i][j]的含义 : 数组中前i个元素组成和为j的方案数。因为和最大为sum（nums），所以和的范围为 <code>-sum（nums）</code>到 <code>0</code>到 <code>sum（nums）</code>。 数组大小设为<code>[[0 for _ in range(sum(nums)*2+1)] for _ in range(len(nums))]</code></p></li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">:</span>        total<span class="token operator">=</span>sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> abs<span class="token punctuation">(</span>total<span class="token punctuation">)</span><span class="token operator">&lt;</span>abs<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">#若目标和大于数组和，凑不成，返回0</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>total<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#初始化数组第0行</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token operator">-</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>total<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># l和r要保证在合法的索引范围内</span>                l<span class="token operator">=</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">0</span>                r<span class="token operator">=</span>j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>total<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>total<span class="token operator">+</span>S<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法2：动态规划（0-1背包的变体）"><a href="#方法2：动态规划（0-1背包的变体）" class="headerlink" title="方法2：动态规划（0-1背包的变体）"></a>方法2：动态规划（0-1背包的变体）</h2><blockquote><ul><li><em>dp数组行和列都分别增加1，第0列表示背包容量为0，第0行表示（虚拟）物品重量为0（这样做，方便初始化dp数组以及后续dp状态转移）</em></li><li><em>由于加了虚拟的0行和0列， 物品i从 1 开始，而数组索引是从 0 开始的，所以第 i 个物品的重量应该是 nums[i-1]</em></li></ul></blockquote><p>以[1,1,2,3]为例，目标和为 target=3.</p><p> 一种可行的方式为 <code>+1+1-2+3=3</code> 。正数列表为P=[1,1,3] , 负数列表为N=[2] 。 则有<br>    <code>sum（P）- sum（N）=target                （1）</code><br>  另一方面，<br>  <code>sum（P）+sum（N）=sum（nums）   （2）</code><br>  公式（1）与（2）相加，得 <code>sum（P）= （sum（nums）+target）/2</code><br>  问题转化为    -&gt;     <strong>各个物品大小为 [1,1,2,3], 背包容量为（sum（nums）+target）/2，求把背包正好装满的方案数</strong></p><p>但是，这里有个<strong>与0-1背包的区别</strong>：</p><ul><li>对于0-1 背包，物品大小为正数，可以先对二维数组初始化第0行（除[0][0]位置外全为0）和<strong>第0列（全为1）</strong>。<strong>然后<code>i</code>和<code>j</code>都从1开始遍历</strong></li><li>对于该问题，列表中可能存在为 0 的元素，因此选不选这个0，都能将容量为0的背包装满。所以<strong>只有<code>dp[0][0]=1</code></strong> （因为是增加的虚拟0行和0列）, 剩下的第0列的其他位置的值用状态转移方程确定 <del>（而不能初始化为1）</del> 。<strong>即<code>i</code>从1开始遍历，<code>j</code>从0开始遍历</strong><ul><li>如 列表为 [0,0,0] , 目标值为 0，则最终的dp数组为<code>[[1], [2], [4], [8]]</code></li><li>如 列表为 [0,0,1]，目标值为 1，则最终的dp数组为<code>[[1, 0], [2, 0], [4, 0], [4, 4]]</code></li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">:</span>        total <span class="token operator">=</span> sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> abs<span class="token punctuation">(</span>total<span class="token punctuation">)</span> <span class="token operator">&lt;</span> abs<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token comment" spellcheck="true"># 目标和太大</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>total <span class="token operator">+</span> S<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">#(total + S)必须为偶数，即，能被2整除</span>        volume <span class="token operator">=</span> <span class="token punctuation">(</span>total <span class="token operator">+</span> S<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>volume <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span> volume <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> j<span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 背包太小，装不下</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 装和不装的总和</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：经典动态规划：完全背包问题</title>
      <link href="/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-wan-quan-bei-bao-wen-ti/"/>
      <url>/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-wan-quan-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/bei-bao-ling-qian" target="_blank" rel="noopener">经典动态规划：完全背包问题</a></p><hr><p>动态规划之背包汇总</p><p><a href="https://xueminxhd.github.io/2020/07/24/labuladong/di-ling-zhang-dong-tai-gui-hua-jie-ti-tao-lu-kuang-jia/">第零章：动态规划解题套路框架</a><br><a href="https://xueminxhd.github.io/2020/07/27/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-0-1-bei-bao-wen-ti/">第一章：经典动态规划：0-1 背包问题</a><br><a href="https://xueminxhd.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-zi-ji-bei-bao-wen-ti/">第零章：经典动态规划：子集背包问题</a><br><a href="https://xueminxhd.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-wan-quan-bei-bao-wen-ti/">第零章：经典动态规划：完全背包问题</a></p><hr><table><thead><tr><th>0-1背包</th><th>完全背包</th></tr></thead><tbody><tr><td>当前的物品放还是不放</td><td>当前的物品放还是不放，如果放，放几个（<strong>每种物品有无数个，可以无限次选取</strong>）</td></tr></tbody></table><p>dp[i][j]数组的含义：dp[i][j] 表示对前i个物品，背包容量为j时，可以凑的硬币组合数（dp数组可以加一行一列表示0物品或0容量时的状态，更便于进行状态转移）</p><ul><li>0-1 背包时，对第i行的硬币<code>coins[i-1]</code> ,若选择该硬币，则dp[i][j]=dp[i-1][j-coins[i-1]] (因为每种硬币只有一枚，<strong>所以状态是从上一枚硬币转到当前硬币</strong>)</li><li>完全背包时，对第i行的硬币<code>coins[i-1]</code> ,若选择该硬币，则dp[i][j]=dp[i][j-coins[i-1]] （因为硬币有无数枚，<strong>选完当前硬币可以再选当前硬币</strong>）。<ul><li>选的时候为<code>dp[i][j-coins[i-1]]</code>，选<code>coins[i-1]</code>时，总的金额减少到<code>j-coins[i-1]</code>,但由于是完全背包问题，每个物品可以选无限次，所以，剩下的可以选的<em>*</em>还是应该是<code>coins[0...i-1]</code>前<code>i</code>个</li></ul></li></ul><h1 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/solution/bei-bao-si-xiang-jie-jue-ling-qian-dui-huan-wen-ti/" target="_blank" rel="noopener">518. 零钱兑换 II</a></h1><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">change</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> amount<span class="token punctuation">,</span> coins<span class="token punctuation">)</span><span class="token punctuation">:</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>coins<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 行和列都分别增加1，第0列表示背包容量为0，第一行表示（虚拟）物品重量为0</span>        <span class="token comment" spellcheck="true"># 这样做，方便初始化dp数组以及后续dp状态转移</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>coins<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 如果该物品重量超过容量，肯定不能放</span>                <span class="token keyword">if</span> j<span class="token operator">&lt;</span>coins<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token comment" spellcheck="true"># 如果没有超过重量，则有两种情况</span>                <span class="token comment" spellcheck="true"># 1. （不放当前的商品）之前的物品已经凑齐:dp[i-1][j]</span>                <span class="token comment" spellcheck="true"># 2. (放当前的商品) 比如用[1,2]凑5，已经知道了[1,2]凑（5-3）的方法，</span>                <span class="token comment" spellcheck="true">#     则把现在的2放进去就可以：dp[i][j-coins[i-1]]. (2可以多次使用)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：经典动态规划：子集背包问题</title>
      <link href="/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-zi-ji-bei-bao-wen-ti/"/>
      <url>/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-zi-ji-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/bei-bao-zi-ji" target="_blank" rel="noopener">经典动态规划：子集背包问题</a></p><hr><p>动态规划之背包汇总</p><p><a href="https://xueminxhd.github.io/2020/07/24/labuladong/di-ling-zhang-dong-tai-gui-hua-jie-ti-tao-lu-kuang-jia/">第零章：动态规划解题套路框架</a><br><a href="https://xueminxhd.github.io/2020/07/27/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-0-1-bei-bao-wen-ti/">第一章：经典动态规划：0-1 背包问题</a><br><a href="https://xueminxhd.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-zi-ji-bei-bao-wen-ti/">第零章：经典动态规划：子集背包问题</a><br><a href="https://xueminxhd.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-wan-quan-bei-bao-wen-ti/">第零章：经典动态规划：完全背包问题</a></p><hr><p>该背包问题相当于<strong>0-1背包问题</strong>的变体  </p><h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/dong-tai-gui-hua-kong-jian-you-hua-zhu-xing-jie--2/" target="_blank" rel="noopener">416. 分割等和子集</a></h1><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><table><thead><tr><th>0-1背包问题：背包容量为m，物品有大小和价值两种属性，求背包最大能装多少价值的物品？</th><th>0-1背包问题变体（分割等和子集）：<strong>背包容量为total/2, 每个物品的大小为 nums[i] 。对于前i个物品，是否有一种装法，能恰好装满背包？</strong></th></tr></thead><tbody><tr><td>dp[i][j] 表示对前i个物品，背包容量为j时，可以装的最大价值</td><td>dp[i][j] 表示对前i个物品，背包容量为j时，值为True/ False (能否装满)</td></tr></tbody></table><ul><li>dp数组行和列都分别增加1，第0列表示背包容量为0，第0行表示（虚拟）物品重量为0（这样做，方便初始化dp数组以及后续dp状态转移）</li><li>由于加了虚拟的0行和0列， 物品i从 1 开始，而数组索引是从 0 开始的，所以第 i 个物品的重量应该是 nums[i-1]</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        total<span class="token operator">=</span>sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># total为列表之和</span>        <span class="token keyword">if</span> total<span class="token operator">%</span><span class="token number">2</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token boolean">False</span> <span class="token comment" spellcheck="true"># 若无法被2整除，说明无法等和，直接返回False</span>        <span class="token comment" spellcheck="true"># 行和列都分别增加1，第0列表示背包容量为0，第一行表示（虚拟）物品重量为0</span>        <span class="token comment" spellcheck="true"># 这样做，方便初始化dp数组以及后续dp状态转移</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>total<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 和为0时，第一列为True</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>total<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> j<span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 若背包容量超过物品大小，装不下</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 继承之前的结果</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 继承之前装下/装不下的结果（只要之前有True，dp[i][j]就为True）</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">|</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：经典动态规划：0-1 背包问题</title>
      <link href="/2020/07/27/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-0-1-bei-bao-wen-ti/"/>
      <url>/2020/07/27/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-0-1-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485064&idx=1&sn=550705eb67f5e71487c8b218382919d6&chksm=9bd7f880aca071962a5a17d0f85d979d6f0c5a5ce32c84b8fee88e36d451f9ccb3bb47b88f78&scene=21#wechat_redirect" target="_blank" rel="noopener">经典动态规划：0-1 背包问题</a></p><hr><p>动态规划之背包汇总</p><p><a href="https://xueminxhd.github.io/2020/07/24/labuladong/di-ling-zhang-dong-tai-gui-hua-jie-ti-tao-lu-kuang-jia/">第零章：动态规划解题套路框架</a><br><a href="https://xueminxhd.github.io/2020/07/27/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-0-1-bei-bao-wen-ti/">第一章：经典动态规划：0-1 背包问题</a><br><a href="https://xueminxhd.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-zi-ji-bei-bao-wen-ti/">第零章：经典动态规划：子集背包问题</a><br><a href="https://xueminxhd.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-wan-quan-bei-bao-wen-ti/">第零章：经典动态规划：完全背包问题</a></p><hr><p><a href="https://www.lintcode.com/problem/backpack-ii/description" target="_blank" rel="noopener">题目地址</a></p><blockquote><p>有 n 个物品和一个大小为 m 的背包. 给定数组 A 表示每个物品的大小和数组 V 表示每个物品的价值.</p><p>问最多能装入背包的总价值是多大?</p><p>样例 样例 1:</p><p>输入: m = 10, A = [2, 3, 5, 7], V = [1, 5, 2, 4] 输出: 9 解释: 装入 A[1] 和<br>A[3] 可以得到最大价值, V[1] + V[3] = 9  样例 2:</p><p>输入: m = 10, A = [2, 3, 8], V = [2, 5, 8] 输出: 10 解释: 装入 A[0] 和 A[2]<br>可以得到最大价值, V[0] + V[2] = 10</p></blockquote><ol><li>base case：0 物品和 0 背包容量时，价值为0</li><li>明确状态和选择<ul><li>状态：背包的容量 ，放进去的物品</li><li>选择：放/不放 当前物品到背包中</li></ul></li><li>dp数组的含义：因为状态有两个，所以dp用二维数组表示。<code>dp[i][j]</code>    表示对前<code>i</code>个物品，背包容量为<code>j</code>时，可以装的最大价值（dp数组可以加一行一列表示0物品或0容量时的状态，更<strong>便于进行状态转移</strong>）<ul><li>若书包容量太小，容不下（<code>if j&lt;A[i-1]</code>），则<code>dp[i][j]=dp[i-1][j]</code></li><li>否则，可以放进去<ul><li>若不放进去，则dp[i][j]=dp[i-1][j]</li><li>若放进去，则dp[i][j]=dp[i-1][j-w[i]] +w[i]</li></ul></li></ul></li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">backPackII</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">,</span> A<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># write your code here</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                <span class="token keyword">if</span> j<span class="token operator">&lt;</span>A<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 若书包容量为j时，放不进去第i个物品（从0开始，所以A[i-1]表示第i个物品的大小）</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 否则，可以放进去</span>                    notBring<span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 选择不放</span>                    bring<span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>A<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>V<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 选择放</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>notBring<span class="token punctuation">,</span>bring<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 取最大值即可</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：团灭 LeetCode 打家劫舍问题</title>
      <link href="/2020/07/26/labuladong/di-ling-zhang-tuan-mie-leetcode-da-jia-jie-she-wen-ti/"/>
      <url>/2020/07/26/labuladong/di-ling-zhang-tuan-mie-leetcode-da-jia-jie-she-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%8A%A2%E6%88%BF%E5%AD%90.md" target="_blank" rel="noopener">团灭 LeetCode 打家劫舍问题</a></p><p><a href="https://leetcode-cn.com/problems/house-robber/solution/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap/" target="_blank" rel="noopener">图解动态规划的解题四步骤</a></p><p>动态规划：在确定动态转移方程后，可以用<del>（自顶向下的使用备忘录递归的方法）</del> <strong>自底向上使用 dp 数组</strong>的方法</p><h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h1><p>因为状态转移方程中，dp[i]涉及到dp[i-2], 在base case 中，在最前面加一个虚拟的空房子，状态更容易转换。而dp[1] 就初始化为nums[0]。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true"># 子问题：</span>    <span class="token comment" spellcheck="true"># f(k) = 偷 [0..k) 房间中的最大金额</span>    <span class="token comment" spellcheck="true"># f(0) = 0</span>    <span class="token comment" spellcheck="true"># f(1) = nums[0]</span>    <span class="token comment" spellcheck="true"># f(k) = max{ rob(k-1), nums[k-1] + rob(k-2) }</span>    N <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k<span class="token number">-2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h1><ul><li><p>现在房子环成了一个圈，也就是说第一间和最后一间不能同时抢。那么有：</p><ol><li><p>抢第一间，不抢最后一间</p></li><li><p>不抢第一间， 抢最后一间</p></li><li><p>不抢第一间， 不抢最后一间</p><p>实际上，情况3的结果是小于情况2的(或者可以说是包含关系), 所以我们只需要考虑情况1,2。</p></li></ol></li><li><p>因此，当有多于1个房子时，只需要比较<code>nums[:-1] , nums[1:]</code> 并返回最大值<code>max(my_rob(nums[:-1]),my_rob(nums[1:]))</code>即可</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">my_rob</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token triple-quoted-string string">"""            :type nums: List[int]            :rtype: int            """</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>            dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>my_rob<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>my_rob<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token keyword">else</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="337-树形打家劫舍"><a href="#337-树形打家劫舍" class="headerlink" title="337 树形打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/solution/shu-xing-dp-by-enda-2/" target="_blank" rel="noopener">337 树形打家劫舍</a></h1><ul><li>对于每一个节点，都只有选和不选两种情况。数组中<code>[ ,  ]</code>第一个index表示不打劫当前节点的收益，第二个index表示打劫当前节点的收益</li><li>如果没选当前节点，则可以选左右节点（<code>withoutRoot=max(l)+max(r)</code>。如果选了当前节点，则不能选左右节点（<code>withRoot=root.val+l[0]+r[0]</code>）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dp</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 不偷/偷的收益</span>            l<span class="token operator">=</span>dp<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 左节点不偷/偷带来的收益</span>            r<span class="token operator">=</span>dp<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 右节点不偷/偷带来的收益</span>            <span class="token comment" spellcheck="true"># 若偷当前节点，则收益=当前节点+左节点不偷+右节点不偷</span>            <span class="token comment" spellcheck="true"># 若不偷当前节点，则收益=左节点偷或不偷的最大值+右节点偷或不偷的最大值</span>            withRoot<span class="token operator">=</span>root<span class="token punctuation">.</span>val<span class="token operator">+</span>l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 若偷当前节点，则</span>            withoutRoot<span class="token operator">=</span>max<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token operator">+</span>max<span class="token punctuation">(</span>r<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span>withoutRoot<span class="token punctuation">,</span>withRoot<span class="token punctuation">]</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 返回 不偷/偷当前节点 的收益最大值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：我写了首诗，把滑动窗口算法变成了默写题</title>
      <link href="/2020/07/25/labuladong/di-ling-zhang-wo-xie-liao-shou-shi-ba-hua-dong-chuang-kou-suan-fa-bian-cheng-liao-mo-xie-ti/"/>
      <url>/2020/07/25/labuladong/di-ling-zhang-wo-xie-liao-shou-shi-ba-hua-dong-chuang-kou-suan-fa-bian-cheng-liao-mo-xie-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://mp.weixin.qq.com/s/ioKXTMZufDECBUwRRp3zaA" target="_blank" rel="noopener">我写了首诗，把滑动窗口算法变成了默写题</a></p><ol><li>增大窗口 </li><li>找到可行解后缩小窗口</li><li><strong>注意维护valid及window中的内容</strong>（若包含需要找的元素，才更新window）</li></ol><blockquote><p> <strong>滑动窗口算法的思路</strong>是这样：</p><p>1、我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引<strong>左闭右开区间</strong>[left, right)称为一个「窗口」。</p><p>2、我们先不断地增加right指针扩大窗口[left, right)，直到窗口中的字符串符合要求（包含了T中的所有字符）。</p><p>3、此时，我们停止增加right，转而不断增加left指针缩小窗口[left, right)，直到窗口中的字符串不再符合要求（不包含T中的所有字符了）。同时，每次增加left，我们都要更新一轮结果。</p><p>4、重复第 2 和第 3 步，直到right到达字符串S的尽头。</p><p>这个思路其实也不难，第 2 步相当于<strong>在寻找一个「可行解」</strong>，然后第 3 步再<strong>优化这个「可行解」</strong>，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p></blockquote><h1 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-suan-fa-tong-yong-si-xiang-by-/" target="_blank" rel="noopener">76.最小覆盖子串</a></h1><ol><li>遍历t，得到need字典</li><li>窗口<strong>左闭右开</strong>。先增大右窗口，更新window 和valid</li><li>找全以后，开始缩小左窗口，相应地，也要更新window和valid。</li><li>在<strong>更新左窗口前</strong>，<strong>先用<code>ans</code>记录并更新左右指针位置</strong>，然后再更新window和valid。这样的话，当窗口的字符串因左窗口的缩小而不再符合要求时（退出while循环），ans中保存的是仍然正好符合要求的左右指针</li><li>如果左指针从未更新过（仍为-1），说明没有在s中找到符合要求的字符串，返回””,否则返回左右指针对应的字符串</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict        window<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        need<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> t<span class="token punctuation">:</span>            need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        l<span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        ans<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">]</span>        valid<span class="token operator">=</span><span class="token number">0</span> <span class="token comment" spellcheck="true"># 合法元素的个数</span>        <span class="token keyword">while</span> r<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            c<span class="token operator">=</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span>            <span class="token comment" spellcheck="true"># 增大窗口 ：相应的要改变window和valid</span>            r<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> need<span class="token punctuation">:</span>                window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span>need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>                    valid<span class="token operator">+=</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># 找到可行解后要缩小窗口：相应的要改变window和valid</span>            <span class="token keyword">while</span> valid<span class="token operator">==</span>len<span class="token punctuation">(</span>need<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> r<span class="token operator">-</span>l<span class="token operator">&lt;</span>ans<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    ans<span class="token operator">=</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span>                c<span class="token operator">=</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> c <span class="token keyword">in</span> need<span class="token punctuation">:</span>                    <span class="token keyword">if</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span>need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>                        valid<span class="token operator">-=</span><span class="token number">1</span>                    window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token string">""</span> <span class="token keyword">if</span> ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">else</span> s<span class="token punctuation">[</span>ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>ans<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a></h1><p>窗口大小等于s1长度，则判断窗口的内容是否符合条件。若符合，返回<code>True</code>。否则，继续更新左窗口。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">checkInclusion</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s1: str        :type s2: str        :rtype: bool        """</span>        <span class="token comment" spellcheck="true"># 准备初始值及统计信息</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict        need<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        window<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        valid<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s1<span class="token punctuation">:</span>            need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        l<span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        <span class="token comment" spellcheck="true"># 维护valid及window</span>        <span class="token keyword">while</span> r<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 维护及增大右窗口</span>            c<span class="token operator">=</span>s2<span class="token punctuation">[</span>r<span class="token punctuation">]</span>            r<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> need<span class="token punctuation">:</span>                window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span>need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>                    valid<span class="token operator">+=</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># 如果窗口大小等于s1长度，则判断窗口的内容是否符合条件</span>            <span class="token comment" spellcheck="true"># 注意是左闭右开，所以是r-l==len(s1)，而不是r-l+1==len(s1)</span>            <span class="token keyword">if</span> r<span class="token operator">-</span>l<span class="token operator">==</span>len<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 若符合，返回True</span>                <span class="token keyword">if</span> valid<span class="token operator">==</span>len<span class="token punctuation">(</span>need<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>                <span class="token comment" spellcheck="true"># 收缩并更新左窗口</span>                c<span class="token operator">=</span>s2<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> c <span class="token keyword">in</span> need<span class="token punctuation">:</span>                    <span class="token keyword">if</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span>need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>                        valid<span class="token operator">-=</span><span class="token number">1</span>                    window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h1><p>相当于在上题的基础上，返回所有满足条件的排列的初始索引值。 用res保存结果（用<code>res.append(l)</code> 添加左指针的索引）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 输入:</span><span class="token comment" spellcheck="true"># s: "cbaebabacd" p: "abc"</span><span class="token comment" spellcheck="true"># 输出:</span><span class="token comment" spellcheck="true"># [0, 6]</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findAnagrams</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :type p: str        :rtype: List[int]        """</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict        need<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        window<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        l<span class="token punctuation">,</span>r<span class="token punctuation">,</span>valid<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> p<span class="token punctuation">:</span>            need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">while</span> r<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            c<span class="token operator">=</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span>            r<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> need<span class="token punctuation">:</span>                window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span>need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>                    valid<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> r<span class="token operator">-</span>l<span class="token operator">==</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> valid<span class="token operator">==</span>len<span class="token punctuation">(</span>need<span class="token punctuation">)</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>l<span class="token punctuation">)</span>                c<span class="token operator">=</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> c <span class="token keyword">in</span> need<span class="token punctuation">:</span>                    <span class="token keyword">if</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span>need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>                        valid<span class="token operator">-=</span><span class="token number">1</span>                    window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h1><ul><li>这次连need和valid都不需要，直接更新window即可</li><li><code>while window[c]&gt;1</code>时，说明窗口中存在重复元素，不符合条件，就该移动left缩小窗口了</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 输入: "abcabcbb"</span><span class="token comment" spellcheck="true"># 输出: 3</span><span class="token comment" spellcheck="true"># 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict        window<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        l<span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        res_max<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> r <span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 更新右窗口</span>            c<span class="token operator">=</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span>            r<span class="token operator">+=</span><span class="token number">1</span>            window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># 符合左窗口更新的条件</span>            <span class="token comment" spellcheck="true"># 注意这里要用while，把不符合条件的左窗口内容一直跳过去</span>            <span class="token comment" spellcheck="true"># 如 "pwwkew"，把左侧p移除后，继续移除左侧w</span>            <span class="token keyword">while</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>                d<span class="token operator">=</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l<span class="token operator">+=</span><span class="token number">1</span>                window<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># 更新答案</span>            res_max<span class="token operator">=</span>max<span class="token punctuation">(</span>res_max<span class="token punctuation">,</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span>        <span class="token keyword">return</span> res_max<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>此题也可用动态规划解：</p><ul><li>dp数组含义：<strong>包含</strong>第i个元素的所有无重复字符串的长度（即<code>len(visited)</code>）</li><li><code>visited</code> 用于保存无重复字符串元素。<code>visited=[s[i]]</code>一定包含当前元素，然后从i-1 开始，逆序遍历之前的元素，若不在visited里，则添加到visited，否则break跳出。</li><li>最后返回dp数组的最大值</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: int        """</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            visited<span class="token operator">=</span><span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                    visited<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>len<span class="token punctuation">(</span>visited<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：我写了首诗，让你闭着眼睛也能写对二分搜索</title>
      <link href="/2020/07/25/labuladong/di-ling-zhang-wo-xie-liao-shou-shi-rang-ni-bi-zhao-yan-jing-ye-neng-xie-dui-er-fen-sou-suo/"/>
      <url>/2020/07/25/labuladong/di-ling-zhang-wo-xie-liao-shou-shi-rang-ni-bi-zhao-yan-jing-ye-neng-xie-dui-er-fen-sou-suo/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/er-fen-cha-zhao-xiang-jie" target="_blank" rel="noopener">我写了首诗，让你闭着眼睛也能写对二分搜索</a></p><ul><li>二分查找的一个技巧是：不要出现 else，而是<strong>把所有情况用 <code>elif</code> 列出来</strong>，这样可以清楚地展现所有细节</li><li><code>mid=left + (right - left) // 2</code> 可防止溢出</li><li>对于左右侧边界的二分查找，<code>elif nums[mid]==target</code> 时<strong>更新的边界</strong>不一样。<code>while</code>循环结束后要通过<strong>打补丁</strong>的方式返回结果<h1 id="基本二分查找"><a href="#基本二分查找" class="headerlink" title="基本二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">基本二分查找</a></h1></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>            mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                right<span class="token operator">=</span>mid<span class="token number">-1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> mid        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="寻找左右侧边界的二分查找"><a href="#寻找左右侧边界的二分查找" class="headerlink" title="寻找左右侧边界的二分查找"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">寻找左右侧边界的二分查找</a></h1><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">searchRange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">leftSearch</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>            left<span class="token operator">=</span><span class="token number">0</span>            right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>                mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>            <span class="token comment" spellcheck="true"># 注意此处的打补丁，因为是左边界，所以是 nums[left]!=target</span>            <span class="token keyword">if</span> left<span class="token operator">>=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">or</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">!=</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">return</span> left            <span class="token comment" spellcheck="true"># # 或者</span>            <span class="token comment" spellcheck="true"># if left&lt;=len(nums)-1 and nums[left]==target:</span>            <span class="token comment" spellcheck="true">#     return left</span>            <span class="token comment" spellcheck="true"># return -1</span>        <span class="token keyword">def</span> <span class="token function">rightSearch</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>            left<span class="token operator">=</span><span class="token number">0</span>            right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>                mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># 注意此处的打补丁，因为是右边界，所以是 nums[right]!=target</span>            <span class="token keyword">if</span> right<span class="token operator">&lt;</span><span class="token number">0</span>  <span class="token operator">or</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">!=</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">return</span> right            <span class="token comment" spellcheck="true"># 或者</span>            <span class="token comment" spellcheck="true"># if right>=0 and nums[right]==target:</span>            <span class="token comment" spellcheck="true">#     return right</span>            <span class="token comment" spellcheck="true"># return -1</span>        l<span class="token operator">=</span>leftSearch<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span>        r<span class="token operator">=</span>rightSearch<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>l<span class="token punctuation">,</span>r<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
            <tag> BinarySearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：BFS 算法解题套路框架（暂）</title>
      <link href="/2020/07/24/labuladong/di-ling-zhang-bfs-suan-fa-jie-ti-tao-lu-kuang-jia-zan/"/>
      <url>/2020/07/24/labuladong/di-ling-zhang-bfs-suan-fa-jie-ti-tao-lu-kuang-jia-zan/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/bfs-kuang-jia" target="_blank" rel="noopener">BFS 算法解题套路框架</a></p><h1 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/li-jie-zhe-dao-ti-de-jie-shu-tiao-jian-by-user7208/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></h1><p>这里先用递归解决</p><ul><li>递归结束的条件或者特判：若是空节点，则返回0</li><li>若左右孩子都为空：返回1</li><li>若左右孩子有一个为空：返回非空孩子的递归结果+1</li><li>否则都不为空，返回左右孩子递归结果的最小值+1</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 递归结束的条件:没有左右孩子</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        leftMin <span class="token operator">=</span> self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        rightMin <span class="token operator">=</span> self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> leftMin <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">and</span> rightMin <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">elif</span> leftMin <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> rightMin <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> leftMin <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> leftMin<span class="token operator">!=</span><span class="token number">0</span> <span class="token keyword">else</span> rightMin <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> min<span class="token punctuation">(</span>leftMin<span class="token punctuation">,</span> rightMin<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 递归结束的条件:没有左右孩子</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        leftMin <span class="token operator">=</span> self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        rightMin <span class="token operator">=</span> self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>left <span class="token operator">and</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">elif</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>left <span class="token operator">or</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>            <span class="token keyword">return</span> leftMin <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">else</span> rightMin <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> min<span class="token punctuation">(</span>leftMin<span class="token punctuation">,</span> rightMin<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：回溯算法解题套路框架</title>
      <link href="/2020/07/24/labuladong/di-ling-zhang-hui-su-suan-fa-jie-ti-tao-lu-kuang-jia/"/>
      <url>/2020/07/24/labuladong/di-ling-zhang-hui-su-suan-fa-jie-ti-tao-lu-kuang-jia/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban" target="_blank" rel="noopener">回溯算法解题套路框架</a></p><p>解决一个回溯问题，实际上就是一个<strong>决策树的遍历</strong>过程。主要考虑的问题有：</p><blockquote><ol><li>路径：也就是已经做出的选择。</li><li>选择列表：也就是你当前可以做的选择。</li><li>结束条件：也就是到达决策树底层，无法再做选择的条件。</li></ol></blockquote><p>回溯算法的框架：<br>（在想这个框架时，心里先建立一个N叉递归决策树，在每个决策点做选择）</p><pre class="line-numbers language-python"><code class="language-python">result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> 满足结束条件<span class="token punctuation">:</span>        result<span class="token punctuation">.</span>add<span class="token punctuation">(</span>路径<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">for</span> 选择 <span class="token keyword">in</span> 选择列表<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 做选择, 类似前序遍历</span>        将该选择从选择列表移除        路径<span class="token punctuation">.</span>add<span class="token punctuation">(</span>选择<span class="token punctuation">)</span>        backtrack<span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 撤销选择，类似后序遍历</span>        路径<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>选择<span class="token punctuation">)</span>        将该选择再加入选择列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>其核心就是 for 循环里面的递归，在递归<strong>调用之前「做选择」</strong>，在递归<strong>调用之后「撤销选择」</strong>。</li><li>for循环的一开始，往往先<strong>用<code>if ...continue</code>语句跳过不合法的选择</strong>（来更新选择列表）</li><li>可以<strong>把「路径」和「选择」列表</strong>作为决策树上<strong>每个节点的属性</strong>。<blockquote><p>以全排列为例，这张图（<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban#yi-quan-pai-lie-wen-ti" target="_blank" rel="noopener">图片来源</a>）非常清晰地说明了路径和选择列表的关系（加入路径后，选择也相应减少）。<br>backtrack 函数其实就<strong>像一个指针</strong>，在这棵树上游走，同时要<strong>正确维护每个节点的属性</strong>，每当走到树的底层，其「路径」就是一个全排列。<br><img src="https://img-blog.csdnimg.cn/20200724135038705.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt></p></blockquote><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></h1></li><li>res保存整体结果，visited保存已经走过的路径</li><li><strong>for 循环的一开始，利用 <code>if num in visited:  continue</code> 可巧妙地更新选择列表（通过continue跳出此次循环，避免选择到重复元素，达到剪枝的效果）</strong> （非常常用！！！）</li><li>利用<code>visited.append(num)</code> 和 <code>visited.pop()</code> 可更新路径（添加/回退选择）</li><li><code>res.append(visited[:])</code>   利用<strong>visited[:]</strong> 才可完整复制添加单个排列结果</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">permute</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[List[int]]        """</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>visited<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 选择列表和路径</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>visited<span class="token punctuation">)</span><span class="token operator">==</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>visited<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token keyword">for</span> num <span class="token keyword">in</span> muns<span class="token punctuation">:</span>                <span class="token keyword">if</span> num <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    visited<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>                    backtrack<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>visited<span class="token punctuation">)</span>                    visited<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        backtrack<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></h1><ul><li>与全排列类似，<strong>决策树的每一层表示棋盘上的每一行</strong>；每个节点可以做出的<strong>选择是</strong>，在该行的<strong>任意一列</strong>放置一个皇后。</li><li><code>backtrack(board,row)</code> 就是标准的回溯框架，只是在做选择时， 通过<code>isvalid()</code> 函数进行剪枝（continue 跳出当次循环），得到符合条件的排列<ul><li><code>isvalid()</code> 函数检查当列，左上，右上 是否与皇后有冲突</li><li><code>tmp_res.append(&#39;&#39;.join(b))</code> 的作用是得到符合输出格式的皇后摆放</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        board<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'.'</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 路径：board, 选择列表：row中的每一列</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#     if 满足条件:</span>            <span class="token comment" spellcheck="true">#         res.append(路径)</span>            <span class="token comment" spellcheck="true">#         return</span>            <span class="token comment" spellcheck="true"># 触底，添加</span>            <span class="token keyword">if</span> row<span class="token operator">==</span>n<span class="token punctuation">:</span>                tmp_res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                <span class="token keyword">for</span> b <span class="token keyword">in</span> board<span class="token punctuation">:</span>                    tmp_res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp_res<span class="token punctuation">)</span>                <span class="token keyword">return</span> res            <span class="token comment" spellcheck="true">#     for 选择 in 选择列表:</span>            <span class="token comment" spellcheck="true">#         做选择</span>            <span class="token comment" spellcheck="true">#         backtrack(路径,选择列表)</span>            <span class="token comment" spellcheck="true">#         撤销选择</span>            <span class="token comment" spellcheck="true"># 判断row行，col列是否可以放Q</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token operator">not</span> isvalid<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'Q'</span>                backtrack<span class="token punctuation">(</span>board<span class="token punctuation">,</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'.'</span>        <span class="token keyword">def</span> <span class="token function">isvalid</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 检查列是否有皇后互相冲突</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'Q'</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token comment" spellcheck="true"># 检查左上方是否有皇后互相冲突</span>            l_row<span class="token punctuation">,</span>l_col<span class="token operator">=</span>row<span class="token punctuation">,</span>col            <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span>l_row<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>n <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span>l_col<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>n<span class="token punctuation">:</span>                l_row<span class="token operator">-=</span><span class="token number">1</span>                l_col<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>l_row<span class="token punctuation">]</span><span class="token punctuation">[</span>l_col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'Q'</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token comment" spellcheck="true"># 检查右上方是否有皇后互相冲突</span>            r_row<span class="token punctuation">,</span>r_col<span class="token operator">=</span>row<span class="token punctuation">,</span>col            <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span>r_row<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>n <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span>r_col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>n<span class="token punctuation">:</span>                r_row<span class="token operator">-=</span><span class="token number">1</span>                r_col<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>r_row<span class="token punctuation">]</span><span class="token punctuation">[</span>r_col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'Q'</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        backtrack<span class="token punctuation">(</span>board<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：动态规划解题套路框架</title>
      <link href="/2020/07/24/labuladong/di-ling-zhang-dong-tai-gui-hua-jie-ti-tao-lu-kuang-jia/"/>
      <url>/2020/07/24/labuladong/di-ling-zhang-dong-tai-gui-hua-jie-ti-tao-lu-kuang-jia/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie" target="_blank" rel="noopener">动态规划解题套路框架</a></p><hr><p>动态规划之背包汇总</p><p><a href="https://xueminxhd.github.io/2020/07/24/labuladong/di-ling-zhang-dong-tai-gui-hua-jie-ti-tao-lu-kuang-jia/">第零章：动态规划解题套路框架</a><br><a href="https://xueminxhd.github.io/2020/07/27/labuladong/di-yi-zhang-jing-dian-dong-tai-gui-hua-0-1-bei-bao-wen-ti/">第一章：经典动态规划：0-1 背包问题</a><br><a href="https://xueminxhd.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-zi-ji-bei-bao-wen-ti/">第零章：经典动态规划：子集背包问题</a><br><a href="https://xueminxhd.github.io/2020/07/27/labuladong/di-ling-zhang-jing-dian-dong-tai-gui-hua-wan-quan-bei-bao-wen-ti/">第零章：经典动态规划：完全背包问题</a></p><hr><p>求解动态规划的核心问题是穷举,但是穷举过程中会存在<strong>重叠子问题</strong>，所以加上<strong>备忘录</strong>来优化过程<br>dp 三要素：</p><ol><li>明确 <strong>base case</strong></li><li>明确「状态」-&gt; 明确「选择」, 即<strong>状态转移方程</strong><ul><li>确定「<strong>状态</strong>」，也就是原问题和子问题中会变化的变量</li><li>确定「<strong>选择</strong>」，也就是导致「状态」产生变化的行为</li></ul></li><li>明确 <strong>dp 数组/函数的含义</strong></li></ol><p>因此，dp 框架可写成：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 初始化 base case</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token operator">=</span> base<span class="token comment" spellcheck="true"># 进行状态转移</span><span class="token keyword">for</span> 状态<span class="token number">1</span> <span class="token keyword">in</span> 状态<span class="token number">1</span>的所有取值：    <span class="token keyword">for</span> 状态<span class="token number">2</span> <span class="token keyword">in</span> 状态<span class="token number">2</span>的所有取值：        <span class="token keyword">for</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            dp<span class="token punctuation">[</span>状态<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>状态<span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token operator">=</span> 求最值<span class="token punctuation">(</span>选择<span class="token number">1</span>，选择<span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></h1><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type N: int        :rtype: int        """</span>        <span class="token keyword">if</span> N<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h1><ul><li>明确 base case：dp[0]=0。 初始化时dp[i] 设为<code>float(&quot;inf&quot;)</code> 最大值</li><li>明确状态：零钱大小</li><li>明确选择：硬币。 <code>if i&gt;=coin</code> 时才做选择（零钱大小至少要比硬币值大）</li><li>明确dp数组含义：凑好当前零钱数的最小硬币数量<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> coins<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">:</span>      dp<span class="token operator">=</span><span class="token punctuation">[</span>float<span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>      dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">for</span> coin <span class="token keyword">in</span> coins<span class="token punctuation">:</span>              <span class="token keyword">if</span> i<span class="token operator">>=</span>coin<span class="token punctuation">:</span>                  dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>coin<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">!=</span>float<span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：学习算法和刷题的框架思维</title>
      <link href="/2020/07/23/labuladong/di-ling-zhang-xue-xi-suan-fa-he-shua-ti-de-kuang-jia-si-wei/"/>
      <url>/2020/07/23/labuladong/di-ling-zhang-xue-xi-suan-fa-he-shua-ti-de-kuang-jia-si-wei/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa" target="_blank" rel="noopener">学习算法和刷题的框架思维</a></p><h1 id="124-二叉树中的最大路径和-后序遍历"><a href="#124-二叉树中的最大路径和-后序遍历" class="headerlink" title="124. 二叉树中的最大路径和_后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/er-cha-shu-zhong-de-zui-da-lu-jing-he-by-ikaruga/" target="_blank" rel="noopener">124. 二叉树中的最大路径和_后序遍历</a></h1><ul><li><code>maxVal</code> 记录的是全局最大路径和（可以不返回，因为它始终在递归过程中更新即可）。</li><li><code>dfs()</code>函数<strong>返回</strong>的是<strong>包含root</strong>在内的<strong>单边</strong>最大路径和。这样做的好处是<code>self.maxVal=max(self.maxVal,root.val+l+r)</code>可以包括全部的路径和情况（（1）根，（2）根+左，（3）根+右，（4）根+左+右），<code>l</code>或<code>r</code>可能为0）</li><li>若root的左节点对应的最大路径和是负数（在拖后腿，所以抛弃），则最大路径和为0，因此有<code>l=max(0,dfs(root.left))</code>。右节点同理</li><li>记得写<strong>递归结束</strong>的条件</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: int        """</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token number">0</span>            l<span class="token operator">=</span>max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>            r<span class="token operator">=</span>max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>maxVal<span class="token operator">=</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxVal<span class="token punctuation">,</span>root<span class="token punctuation">.</span>val<span class="token operator">+</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span>            <span class="token keyword">return</span> root<span class="token punctuation">.</span>val<span class="token operator">+</span>max<span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxVal<span class="token operator">=</span>float<span class="token punctuation">(</span><span class="token string">"-inf"</span><span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxVal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类似题目104-二叉树的最大深度-后序遍历"><a href="#类似题目104-二叉树的最大深度-后序遍历" class="headerlink" title="类似题目104. 二叉树的最大深度_后序遍历"></a>类似题目<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度_后序遍历</a></h2><ul><li><code>dfs()</code>函数返回包含<code>root</code>在内的二叉树最大深度</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: int        """</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>            l<span class="token operator">=</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            r<span class="token operator">=</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">return</span> max<span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="105-从前序与中序遍历序列构造二叉树-前序遍历"><a href="#105-从前序与中序遍历序列构造二叉树-前序遍历" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树_前序遍历"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/dong-hua-yan-shi-105-cong-qian-xu-yu-zhong-xu-bian/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树_前序遍历</a></h1><ul><li>前序遍历的第一个元素是根节点</li><li>在中序遍历中找到根节点的位置，其左边的元素就是左子树，右边的元素就是右子树</li><li>然后递归处理左右子树</li><li>注意写上递归结束条件（左右子树为空时）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type preorder: List[int]        :type inorder: List[int]        :rtype: TreeNode        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token punctuation">(</span>preorder <span class="token operator">and</span> inorder<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> None        root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 根节点</span>        midIdx<span class="token operator">=</span>inorder<span class="token punctuation">.</span>index<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 递归处理左右子树</span>        root<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>buildTree<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span>midIdx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>inorder<span class="token punctuation">[</span><span class="token punctuation">:</span>midIdx<span class="token punctuation">]</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>buildTree<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>midIdx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>inorder<span class="token punctuation">[</span>midIdx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="99-恢复二叉搜索树-中序遍历"><a href="#99-恢复二叉搜索树-中序遍历" class="headerlink" title="99. 恢复二叉搜索树_中序遍历"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/solution/san-chong-jie-fa-xiang-xi-tu-jie-99-hui-fu-er-cha-/" target="_blank" rel="noopener">99. 恢复二叉搜索树_中序遍历</a></h1><p>题目说二叉搜索树，中序遍历后应该是升序排列。否则若出现非递增的元素，说明这个地方有错误</p><ul><li>先中序遍历二叉搜索树，保存在nodes列表中（列表中的元素是节点）</li><li>x保存第一个错误节点，y保存第二个错误节点，pre保存遍历过程中的前一个节点</li><li>找到错误节点x、y后，交换x与y的值</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">recoverTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[int]        """</span>        nodes<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># nodes 中保存节点</span>        <span class="token comment" spellcheck="true"># 中序遍历二叉树,得到递增序列</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span>            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 如果出现非递增的元素，说明这个地方有错误</span>        x<span class="token operator">=</span>None        y<span class="token operator">=</span>None        pre<span class="token operator">=</span>nodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> pre<span class="token punctuation">.</span>val<span class="token operator">></span>nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token punctuation">:</span>                y<span class="token operator">=</span>nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token keyword">if</span> <span class="token operator">not</span> x<span class="token punctuation">:</span>                    x<span class="token operator">=</span>pre            pre<span class="token operator">=</span>nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 交换x与y的值</span>        <span class="token keyword">if</span> x <span class="token operator">and</span> y<span class="token punctuation">:</span>            x<span class="token punctuation">.</span>val<span class="token punctuation">,</span>y<span class="token punctuation">.</span>val<span class="token operator">=</span>y<span class="token punctuation">.</span>val<span class="token punctuation">,</span>x<span class="token punctuation">.</span>val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python经典排序算法</title>
      <link href="/2020/07/22/leetcode/python-jing-dian-pai-xu-suan-fa/"/>
      <url>/2020/07/22/leetcode/python-jing-dian-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-an-array/solution/python-shi-xian-de-shi-da-jing-dian-pai-xu-suan-fa/" target="_blank" rel="noopener">Python经典排序算法</a></p><p><img src="https://img-blog.csdnimg.cn/20200722182404772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wZW5jdnpzZWZ2,size_16,color_FFFFFF,t_70" alt></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><ul><li>对每一个nums[i], 寻找 $range(i,n)$ 范围内比nums[i]大的数，并与之交换</li><li>以此类推，位置 i 处就是 第i 小的数</li></ul><blockquote><p>两次for循环，时间复杂度为 $O(n^2)$</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">selection_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="==冒泡排序=="></a>==冒泡排序==</h1><ul><li>最坏的情况是: 原始的nums是倒序，从倒序转顺序</li><li>对每一个nums[i], 需要比较n-i次<strong>相邻元素</strong><blockquote><p>两次for循环，时间复杂度为 $O(n^2)$</p></blockquote></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="==插入排序=="></a>==插入排序==</h1><ul><li>对每一个nums[i], 将其插入到符合大小顺序的位置处</li><li>随着i的增加，需要比较的次数也增加。比较时，从最近的相邻元素开始，倒序比<blockquote><p>时间复杂度为 $O(n^2)$</p></blockquote></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>                i<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                    i<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="希尔排序（了解）"><a href="#希尔排序（了解）" class="headerlink" title="希尔排序（了解）"></a>希尔排序（了解）</h1><ul><li>希尔排序是插入排序的优化，通过<code>gap</code>减少排序过程中交换的次数<blockquote><p>时间复杂度为 $O(n^2)$</p></blockquote></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        gap<span class="token operator">=</span>n<span class="token operator">//</span><span class="token number">2</span>        <span class="token keyword">while</span> gap<span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>gap<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> i<span class="token operator">-</span>gap<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">:</span>                                nums<span class="token punctuation">[</span>i<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span>gap<span class="token punctuation">]</span>                    i<span class="token operator">-=</span>gap            gap<span class="token operator">=</span>gap<span class="token operator">//</span><span class="token number">2</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="==归并排序=="></a>==归并排序==</h1><p>归并排序是理解<strong>递归方法</strong>的一个很好的例子</p><ul><li><strong>不要跳进</strong>递归里面去 （<del>跳进去没任何用处，反而会更混乱</del> ）。归并排序就是先把数组分左右两个子数组并<strong>对子数组排序</strong>，然后<strong>合并</strong></li><li>递归是逐步缩小子问题，主要是理解<strong>函数的作用及返回的内容</strong><ul><li><code>sortArray()</code> 函数的作用是排序，返回排好序的列表<ul><li>如 [7,5,3] -&gt; 返回[3,5,7]    </li></ul></li><li><code>merge()</code> 函数的作用是对两个有序数组按照由小到大的顺序合并<ul><li>如 left=[2,4,6],right=[3,5,7]-&gt; 合并后返回[2,3,4,5,6,7]</li></ul></li></ul></li></ul><blockquote><p>时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$。参考<a href="https://blog.csdn.net/touch_2011/article/details/6785881" target="_blank" rel="noopener">漫谈经典排序算法</a></p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 函数的作用是排序，不要跳进递归中</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> nums        mid<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>        <span class="token comment" spellcheck="true"># 分成有序的左右两个子列</span>        left<span class="token operator">=</span>self<span class="token punctuation">.</span>sortArray<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>        right<span class="token operator">=</span>self<span class="token punctuation">.</span>sortArray<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 合并</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 按照大小顺序，合并两个子数组</span>    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> len<span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> len<span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 从while条件中跳出后，左右子数组中可能仍有未pop出的元素</span>        <span class="token comment" spellcheck="true"># 所以将其连接到res后面即可</span>        res<span class="token operator">+=</span>left        res<span class="token operator">+=</span>right        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="==快速排序=="></a>==快速排序==</h1><ul><li>将列表的第一个（或最后一个）元素设为pivot，然后在<code>range(1,len(nums))</code>中，小于等于pivot的元素放l，大于pivot的元素放r</li><li>对l和r列表分别递归调用排序函数，并通过<code>left+[pivot]+right</code> 将其连起开，返回最终结果</li><li>注意递归终止的条件及特判<code>if len(nums)&lt;=0:return nums</code><blockquote><p>时间复杂度为 $O(n^2)$</p></blockquote></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 递归终止的条件及特判</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token keyword">return</span> nums        <span class="token comment" spellcheck="true"># 将列表的第一个元素设为pivot，后面的元素中，小于pivot</span>        l<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        r<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        pivot<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">:</span>                l<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        left<span class="token operator">=</span>self<span class="token punctuation">.</span>sortArray<span class="token punctuation">(</span>l<span class="token punctuation">)</span>        right<span class="token operator">=</span>self<span class="token punctuation">.</span>sortArray<span class="token punctuation">(</span>r<span class="token punctuation">)</span>        <span class="token keyword">return</span> left<span class="token operator">+</span><span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token operator">+</span>right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索旋转排序数组系列</title>
      <link href="/2020/07/17/leetcode/sou-suo-xuan-zhuan-pai-xu-shu-zu-xi-lie/"/>
      <url>/2020/07/17/leetcode/sou-suo-xuan-zhuan-pai-xu-shu-zu-xi-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></h1><ul><li><p>二分查找过程中，比较mid与right（而非left）的原因：<br><strong>以 [1,2,3,4,5,6,7] 为例</strong>，分以下<strong>情况</strong></p><ol><li>若[1,2,3,<strong>4</strong>,5,6,7] 左&lt;中，<strong>中&lt;右</strong>。最小值在最左边， 所以更新 <strong>右指针</strong></li><li>若[6,7,1,<strong>2</strong>,3,4,5] 左&gt;中，<strong>中&lt;右</strong>。最小值在mid左边，所以更新 <strong>右指针</strong></li><li>若[4,5,6,<strong>7</strong>,1,2,3] 左&lt;中，<em>中&gt;右</em>。最小值在mid右边，所以更新 <em>左指针</em></li></ol></li><li><p>可见，当中&lt;右时（情况1,2），都是更新右指针，中&gt;右时 （情况3），都是更新左指针（<strong>因为是找最小值，最小值偏左，所以mid和右指针进行比较，更有区分度</strong>）。 但是左&lt;中时 （情况1,3）,指针更新不统一，讨论起来较麻烦。</p></li></ul><blockquote><p>循环条件<strong>l&lt;r</strong>:</p><ul><li>若<code>nums[mid]&gt;nums[r]</code>,说明mid在第一个递增序列，最小值在mid右边，所以l=mid+1 （情况3）</li><li>若<code>nums[mid]&lt;=nums[r]</code>,说明mid在第二个递增序列，最小值在mid处或mid左边，所以r=mid （情况2, 或者如[3,4,0,1,2]）</li></ul></blockquote><pre class="line-numbers language-python"><code class="language-python">  <span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> left<span class="token operator">&lt;</span>right<span class="token punctuation">:</span>            mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                right<span class="token operator">=</span>mid        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/er-fen-fa-python3-by-zhu_shi_fu/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></h1><p>此题与上一题的区别是，增加了重复元素,所以循环条件略有区别，增加了<code>nums[mid]==nums[r]</code>等于时的特判，用right-=1跳过重复元素，使得right慢慢向左跳</p><blockquote><p>循环条件<strong>l&lt;r</strong>:</p><ul><li>若<code>nums[mid]&gt;nums[r]</code>,说明mid在第一个递增序列，最小值在mid右边，所以l=mid+1 （情况3）</li><li>若<code>nums[mid]&lt;nums[r]</code>,说明mid在第二个递增序列，最小值在mid处或mid左边，所以r=mid （情况2, 或者如[3,4,0,1,2]）</li><li>若<code>nums[mid]=nums[r]</code>,r 向左慢慢跳，所以r-=1 （如[1,0,1,1,1]）</li></ul></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> left<span class="token operator">&lt;</span>right<span class="token punctuation">:</span>            mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                right<span class="token operator">=</span>mid            <span class="token keyword">else</span><span class="token punctuation">:</span>                right<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/duo-tu-yan-shi-33-sou-suo-xuan-zhuan-pai-xu-shu-zu/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></h1><p>方法1：找到数组中的最小值后，在第一或第二递增区域内找目标值</p><p>根据上题”153. 寻找旋转排序数组中的最小值” 可以得到最小值，若将最小值<code>minIdx</code>作为旋转点，则有</p><blockquote><ul><li>若最小值下标为0，说明序列是单调递增的，所以在<code>0 - n-1</code> 范围内进行二分查找</li><li>若<code>target&gt;=nums[0]</code>,说明target在第一段递增序列内，所以在<code>nums[0:minIdx]</code> 范围内进行二分查找</li><li>若<code>target&lt;nums[0]</code>,说明target需要在第二段递增序列内找，所以在<code>nums[minIdx:]</code> 范围内进行二分查找<ul><li>如果目标值不在第二递增序列中，则返回-1（如<code>[4,5,6,7,0,1,2]</code>中找target 3），否则返回 <code>minIdx+binarySearch(nums[minIdx:],target)</code>的结果</li></ul></li></ul></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type target: int        :rtype: int        """</span>        <span class="token comment" spellcheck="true"># 找到最小值的下标</span>        <span class="token keyword">def</span> <span class="token function">findMin</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            l<span class="token operator">=</span><span class="token number">0</span>            r<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">:</span>                mid<span class="token operator">=</span>l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                    l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    r<span class="token operator">=</span>mid            <span class="token keyword">return</span> l        <span class="token comment" spellcheck="true"># 普通的二分查找，用于确定目标值下标</span>        <span class="token keyword">def</span>  <span class="token function">binarySearch</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>            l<span class="token operator">=</span><span class="token number">0</span>            r<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> l<span class="token operator">&lt;=</span>r<span class="token punctuation">:</span>                mid<span class="token operator">=</span>l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                    <span class="token keyword">return</span> mid                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                    r<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        minIdx<span class="token operator">=</span>findMin<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> minIdx<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#单调递增，在整个范围内寻找</span>            <span class="token keyword">return</span> binarySearch<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span>        <span class="token keyword">elif</span> target<span class="token operator">>=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 在第一个递增序列内找</span>            <span class="token keyword">return</span> binarySearch<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>minIdx<span class="token punctuation">]</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># target&lt;nums[0]: # 在第二个递增序列内找</span>            <span class="token comment" spellcheck="true"># 如果目标值不在第二递增序列中，则返回-1，否则返回 minIdx+tmp</span>            tmp<span class="token operator">=</span>binarySearch<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>minIdx<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> tmp<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">else</span> minIdx<span class="token operator">+</span>tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法2：直接二分查找,在<strong>严格的递增序列内</strong>找target，其余情况取反</p><ul><li>设置左右指针</li><li><code>nums[mid]==target</code>时，说明已找到目标值，返回 mid （也是while的结束条件）</li><li><code>当nums[mid]&gt;=nums[l]</code> 时（注意这里要取等号，使得满足递增序列只有一个元素的情况也符合(如<code>[3,1]</code>)），说明左边是递增序列，<ul><li>若<strong>target在递增序列内</strong>，则更新右指针</li><li>其他情况更新左指针 （target 在mid的右边，所以更新左指针）</li></ul></li><li>否则当<code>nums[mid]&lt;nums[l]</code>时，说明右边是递增序列<ul><li>若<strong>target在递增序列内</strong>，则更新左指针</li><li>其他情况更新右指针 （target 在mid的左边，所以更新右指针）</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type target: int        :rtype: int        """</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        l<span class="token operator">=</span><span class="token number">0</span>        r<span class="token operator">=</span>n<span class="token number">-1</span>        <span class="token keyword">while</span> l<span class="token operator">&lt;=</span>r<span class="token punctuation">:</span>            mid<span class="token operator">=</span>l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token comment" spellcheck="true"># 找到后，结束循环，跳出</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> mid            <span class="token comment" spellcheck="true"># 左边是递增序列</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">>=</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># target 若在递增序列内，则更新右指针</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">:</span>                    r<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 剩余情况更新左指针</span>                    l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># 右边是递增序列</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># target 若在递增序列内，则更新左指针</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                    l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 剩余情况更新右指针</span>                    r<span class="token operator">=</span>mid<span class="token number">-1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment" spellcheck="true"># 不满足条件时，返回-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/er-fen-by-powcai/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></h1><p>与上题相比，本题增加了重复元素。因此，若检测到重复元素，则左（右）指针要跳，直到不重复：</p><blockquote><p>如[1,1,1,1,2,1], 可保证跳过相邻的相同元素<br>与上题相比，增加如下判断：</p><pre><code>        if nums[mid]==nums[l]==nums[r]:            l+=1            r-=1</code></pre></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type target: int        :rtype: int        """</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        l<span class="token operator">=</span><span class="token number">0</span>        r<span class="token operator">=</span>n<span class="token number">-1</span>        <span class="token keyword">while</span> l<span class="token operator">&lt;=</span>r<span class="token punctuation">:</span>            mid<span class="token operator">=</span>l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token comment" spellcheck="true"># 找到后，结束循环，跳出</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token comment" spellcheck="true"># ******与上题相比，增加的部分****** #</span>            <span class="token triple-quoted-string string">"""            如[1,1,1,1,2,1], 可保证跳过相邻的相同元素            """</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                l<span class="token operator">+=</span><span class="token number">1</span>                r<span class="token operator">-=</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># ******与上题相比，增加的部分****** #</span>            <span class="token comment" spellcheck="true"># 左边是递增序列</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">>=</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># target 若在递增序列内，则更新右指针</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">:</span>                    r<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 剩余情况更新左指针</span>                    l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># 右边是递增序列</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># target 若在递增序列内，则更新左指针</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                    l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 剩余情况更新右指针</span>                    r<span class="token operator">=</span>mid<span class="token number">-1</span>        <span class="token keyword">return</span> <span class="token boolean">False</span> <span class="token comment" spellcheck="true"># 不满足条件时，返回-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零章：一个方法团灭 nSum 问题</title>
      <link href="/2020/07/16/labuladong/di-ling-zhang-yi-ge-fang-fa-tuan-mie-nsum-wen-ti/"/>
      <url>/2020/07/16/labuladong/di-ling-zhang-yi-ge-fang-fa-tuan-mie-nsum-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://mp.weixin.qq.com/s/fSyJVvggxHq28a0SdmZm6Q" target="_blank" rel="noopener">一个方法团灭 nSum 问题</a></p><h1 id="方法1：利用字典去重的2Sum和3Sum"><a href="#方法1：利用字典去重的2Sum和3Sum" class="headerlink" title="方法1：利用字典去重的2Sum和3Sum"></a>方法1：利用字典去重的2Sum和3Sum</h1><h2 id="2Sum-问题"><a href="#2Sum-问题" class="headerlink" title="2Sum 问题"></a>2Sum 问题</h2><ul><li>利用字典保存遍历过程变量，若满足条件，则返回结果<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token triple-quoted-string string">"""      :type nums: List[int]      :type target: int      :rtype: List[int]      """</span>      dic<span class="token operator">=</span>dict<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> i<span class="token punctuation">,</span>j <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">if</span> target<span class="token operator">-</span>j <span class="token keyword">in</span> dic<span class="token punctuation">:</span>              <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> dic<span class="token punctuation">[</span>target<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span>          dic<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3Sum-问题"><a href="#3Sum-问题" class="headerlink" title="3Sum 问题"></a>3Sum 问题</h2></li><li>在2Sum 的基础上(- 如    <code>[-10,4,4,5,5,6]</code>,对-10 而言，<code>res=[[4,6],[5,5]]</code>)，逐个遍历<code>nums</code> ,求满足target为<code>-nums[i]</code> 的结果</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            dic <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> target <span class="token operator">-</span> j <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>j<span class="token punctuation">,</span> target <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span>                dic<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i            <span class="token comment" spellcheck="true"># 去重，如[[1,2],[1,2],[0,3]] -> [[1,2],[0,3]] (假设target为3)</span>            resAll<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token punctuation">[</span>resAll<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> res <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> resAll<span class="token punctuation">]</span>            <span class="token keyword">return</span> resAll        all <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        nums<span class="token operator">=</span>sorted<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token keyword">continue</span>  <span class="token comment" spellcheck="true"># 若有相等元素，则跳过</span>            target<span class="token operator">=</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            cur<span class="token operator">=</span>twoSum<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 若没有满足条件的twoSum，对结果也没影响.</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> cur<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 对cur中的每组列表都添加当前的nums[i]</span>                c<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                all<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">return</span> all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="方法2：排序后双指针逼近"><a href="#方法2：排序后双指针逼近" class="headerlink" title="方法2：排序后双指针逼近"></a>方法2：排序后双指针逼近</h1><h2 id="2Sum-双指针逼近"><a href="#2Sum-双指针逼近" class="headerlink" title="2Sum 双指针逼近"></a>2Sum 双指针逼近</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type target: int        :rtype: List[int]        """</span>        <span class="token keyword">import</span> copy        nums1<span class="token operator">=</span>copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        nums1<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            cur <span class="token operator">=</span> nums1<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span>            <span class="token keyword">if</span> cur <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> cur <span class="token operator">></span> target<span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>        id1<span class="token operator">=</span>nums<span class="token punctuation">.</span>index<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 使得nums与nums1 的下标相对应</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>id1<span class="token punctuation">)</span>        nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>id1<span class="token punctuation">)</span>        id2<span class="token operator">=</span>nums<span class="token punctuation">.</span>index<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> id2<span class="token operator">>=</span>id1<span class="token punctuation">:</span>            id2<span class="token operator">=</span>id2<span class="token operator">+</span><span class="token number">1</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>id2<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3Sum双指针逼近"><a href="#3Sum双指针逼近" class="headerlink" title="3Sum双指针逼近"></a>3Sum双指针逼近</h2><ul><li><code>sorted(nums)</code>先对列表进行排序, 然后用双指针逼近</li><li>利用twoSum函数返回满足条件的所有列表 <ul><li>如    <code>[-10,4,4,5,5,6]</code>,对-10 而言，<code>res=[[4,6],[5,5]]</code></li><li>设置<code>left</code>，保证<code>nums[l]</code>可以与其左边的元素比较是否相等（<code>right</code>同理）</li><li><code>for i in range(len(nums))</code>  对每一次遍历，就是求满足<code>target</code> 为<code>-nums[i]</code> 的 结果</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[List[int]]        """</span>        <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>                cur <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                left <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                right <span class="token operator">=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                <span class="token keyword">if</span> cur <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> left<span class="token punctuation">:</span> l <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">elif</span> cur <span class="token operator">></span> target<span class="token punctuation">:</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> right<span class="token punctuation">:</span> r <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># 设置left，保证nums[l]可以与其左边的元素比较是否相等（right 同理）</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> left<span class="token punctuation">:</span> l <span class="token operator">+=</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># 一直向右跳，直到不相等</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> right<span class="token punctuation">:</span> r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>            <span class="token keyword">return</span> res        all <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        nums<span class="token operator">=</span>sorted<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token keyword">continue</span>  <span class="token comment" spellcheck="true"># 若有相等元素，则跳过</span>            target<span class="token operator">=</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            cur<span class="token operator">=</span>twoSum<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 若没有满足条件的twoSum，则 不执行下面语句.因为cur为[].</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> cur<span class="token punctuation">:</span>                c<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                all<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">return</span> all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个函数秒杀 2Sum 3Sum 问题</title>
      <link href="/2020/07/16/labuladong/yi-ge-han-shu-miao-sha-2sum-3sum-wen-ti/"/>
      <url>/2020/07/16/labuladong/yi-ge-han-shu-miao-sha-2sum-3sum-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://mp.weixin.qq.com/s/fSyJVvggxHq28a0SdmZm6Q" target="_blank" rel="noopener">一个函数秒杀 2Sum 3Sum 4Sum 问题</a></p><h1 id="方法1：利用字典去重的2Sum和3Sum"><a href="#方法1：利用字典去重的2Sum和3Sum" class="headerlink" title="方法1：利用字典去重的2Sum和3Sum"></a>方法1：利用字典去重的2Sum和3Sum</h1><h2 id="2Sum-问题"><a href="#2Sum-问题" class="headerlink" title="2Sum 问题"></a>2Sum 问题</h2><ul><li>利用字典保存遍历过程变量，若满足条件，则返回结果<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token triple-quoted-string string">"""      :type nums: List[int]      :type target: int      :rtype: List[int]      """</span>      dic<span class="token operator">=</span>dict<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> i<span class="token punctuation">,</span>j <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">if</span> target<span class="token operator">-</span>j <span class="token keyword">in</span> dic<span class="token punctuation">:</span>              <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> dic<span class="token punctuation">[</span>target<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span>          dic<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3Sum-问题"><a href="#3Sum-问题" class="headerlink" title="3Sum 问题"></a>3Sum 问题</h2></li><li>在2Sum 的基础上(- 如    <code>[-10,4,4,5,5,6]</code>,对-10 而言，<code>res=[[4,6],[5,5]]</code>)，逐个遍历<code>nums</code> ,求满足target为<code>-nums[i]</code> 的结果</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            dic <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> target <span class="token operator">-</span> j <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>j<span class="token punctuation">,</span> target <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span>                dic<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i            <span class="token comment" spellcheck="true"># 去重，如[[1,2],[1,2],[0,3]] -> [[1,2],[0,3]] (假设target为3)</span>            resAll<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token punctuation">[</span>resAll<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> res <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> resAll<span class="token punctuation">]</span>            <span class="token keyword">return</span> resAll        all <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        nums<span class="token operator">=</span>sorted<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token keyword">continue</span>  <span class="token comment" spellcheck="true"># 若有相等元素，则跳过</span>            target<span class="token operator">=</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            cur<span class="token operator">=</span>twoSum<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 若没有满足条件的twoSum，对结果也没影响.</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> cur<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 对cur中的每组列表都添加当前的nums[i]</span>                c<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                all<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">return</span> all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="方法2：排序后双指针逼近"><a href="#方法2：排序后双指针逼近" class="headerlink" title="方法2：排序后双指针逼近"></a>方法2：排序后双指针逼近</h1><h2 id="2Sum-双指针逼近"><a href="#2Sum-双指针逼近" class="headerlink" title="2Sum 双指针逼近"></a>2Sum 双指针逼近</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type target: int        :rtype: List[int]        """</span>        <span class="token keyword">import</span> copy        nums1<span class="token operator">=</span>copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        nums1<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            cur <span class="token operator">=</span> nums1<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span>            <span class="token keyword">if</span> cur <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> cur <span class="token operator">></span> target<span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>        id1<span class="token operator">=</span>nums<span class="token punctuation">.</span>index<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 使得nums与nums1 的下标相对应</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>id1<span class="token punctuation">)</span>        nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>id1<span class="token punctuation">)</span>        id2<span class="token operator">=</span>nums<span class="token punctuation">.</span>index<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> id2<span class="token operator">>=</span>id1<span class="token punctuation">:</span>            id2<span class="token operator">=</span>id2<span class="token operator">+</span><span class="token number">1</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>id2<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3Sum双指针逼近"><a href="#3Sum双指针逼近" class="headerlink" title="3Sum双指针逼近"></a>3Sum双指针逼近</h2><ul><li><code>sorted(nums)</code>先对列表进行排序, 然后用双指针逼近</li><li>利用twoSum函数返回满足条件的所有列表 <ul><li>如    <code>[-10,4,4,5,5,6]</code>,对-10 而言，<code>res=[[4,6],[5,5]]</code></li><li>设置<code>left</code>，保证<code>nums[l]</code>可以与其左边的元素比较是否相等（<code>right</code>同理）</li><li><code>for i in range(len(nums))</code>  对每一次遍历，就是求满足<code>target</code> 为<code>-nums[i]</code> 的 结果</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[List[int]]        """</span>        <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>                cur <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                left <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                right <span class="token operator">=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                <span class="token keyword">if</span> cur <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> left<span class="token punctuation">:</span> l <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">elif</span> cur <span class="token operator">></span> target<span class="token punctuation">:</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> right<span class="token punctuation">:</span> r <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># 设置left，保证nums[l]可以与其左边的元素比较是否相等（right 同理）</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> left<span class="token punctuation">:</span> l <span class="token operator">+=</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># 一直向右跳，直到不相等</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> right<span class="token punctuation">:</span> r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>            <span class="token keyword">return</span> res        all <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        nums<span class="token operator">=</span>sorted<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token keyword">continue</span>  <span class="token comment" spellcheck="true"># 若有相等元素，则跳过</span>            target<span class="token operator">=</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            cur<span class="token operator">=</span>twoSum<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 若没有满足条件的twoSum，则 不执行下面语句.因为cur为[].</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> cur<span class="token punctuation">:</span>                c<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                all<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">return</span> all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：一个方法团灭nSum问题</title>
      <link href="/2020/07/16/labuladong/di-yi-zhang-yi-ge-fang-fa-tuan-mie-nsum-wen-ti/"/>
      <url>/2020/07/16/labuladong/di-yi-zhang-yi-ge-fang-fa-tuan-mie-nsum-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/nsum" target="_blank" rel="noopener">一个方法团灭 nSum 问题</a></p><h1 id="方法1：利用字典去重的2Sum和3Sum"><a href="#方法1：利用字典去重的2Sum和3Sum" class="headerlink" title="方法1：利用字典去重的2Sum和3Sum"></a>方法1：利用字典去重的2Sum和3Sum</h1><h2 id="2Sum-问题"><a href="#2Sum-问题" class="headerlink" title="2Sum 问题"></a>2Sum 问题</h2><ul><li>利用字典保存遍历过程变量，若满足条件，则返回结果<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token triple-quoted-string string">"""      :type nums: List[int]      :type target: int      :rtype: List[int]      """</span>      dic<span class="token operator">=</span>dict<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> i<span class="token punctuation">,</span>j <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">if</span> target<span class="token operator">-</span>j <span class="token keyword">in</span> dic<span class="token punctuation">:</span>              <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> dic<span class="token punctuation">[</span>target<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span>          dic<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3Sum-问题"><a href="#3Sum-问题" class="headerlink" title="3Sum 问题"></a>3Sum 问题</h2></li><li>在2Sum 的基础上(- 如    <code>[-10,4,4,5,5,6]</code>,对-10 而言，<code>res=[[4,6],[5,5]]</code>)，逐个遍历<code>nums</code> ,求满足target为<code>-nums[i]</code> 的结果</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            dic <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> target <span class="token operator">-</span> j <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>j<span class="token punctuation">,</span> target <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span>                dic<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i            <span class="token comment" spellcheck="true"># 去重，如[[1,2],[1,2],[0,3]] -> [[1,2],[0,3]] (假设target为3)</span>            resAll<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token punctuation">[</span>resAll<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> res <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> resAll<span class="token punctuation">]</span>            <span class="token keyword">return</span> resAll        all <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        nums<span class="token operator">=</span>sorted<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token keyword">continue</span>  <span class="token comment" spellcheck="true"># 若有相等元素，则跳过</span>            target<span class="token operator">=</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            cur<span class="token operator">=</span>twoSum<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 若没有满足条件的twoSum，对结果也没影响.</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> cur<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 对cur中的每组列表都添加当前的nums[i]</span>                c<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                all<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">return</span> all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="方法2：排序后双指针逼近"><a href="#方法2：排序后双指针逼近" class="headerlink" title="方法2：排序后双指针逼近"></a>方法2：排序后双指针逼近</h1><h2 id="2Sum-双指针逼近"><a href="#2Sum-双指针逼近" class="headerlink" title="2Sum 双指针逼近"></a>2Sum 双指针逼近</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type target: int        :rtype: List[int]        """</span>        <span class="token keyword">import</span> copy        nums1<span class="token operator">=</span>copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        nums1<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            cur <span class="token operator">=</span> nums1<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span>            <span class="token keyword">if</span> cur <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> cur <span class="token operator">></span> target<span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>        id1<span class="token operator">=</span>nums<span class="token punctuation">.</span>index<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 使得nums与nums1 的下标相对应</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>id1<span class="token punctuation">)</span>        nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>id1<span class="token punctuation">)</span>        id2<span class="token operator">=</span>nums<span class="token punctuation">.</span>index<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> id2<span class="token operator">>=</span>id1<span class="token punctuation">:</span>            id2<span class="token operator">=</span>id2<span class="token operator">+</span><span class="token number">1</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>id2<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3Sum双指针逼近"><a href="#3Sum双指针逼近" class="headerlink" title="3Sum双指针逼近"></a>3Sum双指针逼近</h2><ul><li><code>sorted(nums)</code>先对列表进行排序, 然后用双指针逼近</li><li>利用twoSum函数返回满足条件的所有列表 <ul><li>如    <code>[-10,4,4,5,5,6]</code>,对-10 而言，<code>res=[[4,6],[5,5]]</code></li><li>设置<code>left</code>，保证<code>nums[l]</code>可以与其左边的元素比较是否相等（<code>right</code>同理）</li><li><code>for i in range(len(nums))</code>  对每一次遍历，就是求满足<code>target</code> 为<code>-nums[i]</code> 的 结果</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[List[int]]        """</span>        <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>                cur <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                left <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                right <span class="token operator">=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                <span class="token keyword">if</span> cur <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> left<span class="token punctuation">:</span> l <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">elif</span> cur <span class="token operator">></span> target<span class="token punctuation">:</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> right<span class="token punctuation">:</span> r <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># 设置left，保证nums[l]可以与其左边的元素比较是否相等（right 同理）</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> left<span class="token punctuation">:</span> l <span class="token operator">+=</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># 一直向右跳，直到不相等</span>                    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> right<span class="token punctuation">:</span> r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>            <span class="token keyword">return</span> res        all <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        nums<span class="token operator">=</span>sorted<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token keyword">continue</span>  <span class="token comment" spellcheck="true"># 若有相等元素，则跳过</span>            target<span class="token operator">=</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            cur<span class="token operator">=</span>twoSum<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 若没有满足条件的twoSum，则 不执行下面语句.因为cur为[].</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> cur<span class="token punctuation">:</span>                c<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                all<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">return</span> all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何判断回文链表</title>
      <link href="/2020/07/13/labuladong/di-si-zhang-ru-he-pan-duan-hui-wen-lian-biao/"/>
      <url>/2020/07/13/labuladong/di-si-zhang-ru-he-pan-duan-hui-wen-lian-biao/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/pan-duan-hui-wen-lian-biao" target="_blank" rel="noopener">如何判断回文链表</a></p><h1 id="方法1：链表转列表，双指针逼近"><a href="#方法1：链表转列表，双指针逼近" class="headerlink" title="方法1：链表转列表，双指针逼近"></a>方法1：链表转列表，双指针逼近</h1><p>将链表转化为列表，然后利用左右双指针技巧，从两端到中间逼近</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: bool        """</span>        <span class="token comment" spellcheck="true"># 转成列表</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> head<span class="token punctuation">:</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            head<span class="token operator">=</span>head<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true"># 左右双指针逼近</span>        l<span class="token operator">=</span><span class="token number">0</span>        r<span class="token operator">=</span>len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> l<span class="token operator">&lt;=</span>r<span class="token punctuation">:</span>            <span class="token keyword">if</span>  stack<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">!=</span>stack<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                l<span class="token operator">+=</span><span class="token number">1</span>                r<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="方法2：反转后半部分链表后，逐个比较节点值"><a href="#方法2：反转后半部分链表后，逐个比较节点值" class="headerlink" title="方法2：反转后半部分链表后，逐个比较节点值"></a>方法2：反转后半部分链表后，逐个比较节点值</h1><p><strong>思路</strong></p><ul><li>边界条件（如[] 或者 [2]）直接返回</li><li>快慢指针找中点</li><li>反转以slow为开头的链表</li><li>只需判断p2存在时，p1是否等于p2</li></ul><p><strong>步骤</strong></p><p>以偶数为例（奇数类似）</p><p>链表：<code>1-&gt;2-&gt;2-&gt;1</code><br>下标：[0] [1] [2] [3]</p><ol><li>快慢指针后，slow指向第二个2(下标为[2])，fast已跳出链表</li><li>此时slow后面的链表为<code>2-&gt;1</code>。反转时，2(下标为[2])指向prev的None,1指向2。最后有<code>None&lt;-2&lt;-1</code>（此时prev在下标[3]处）。（注意：此时前半段中，<strong>下标为[1]的节点2仍然指向下标为[2]的节点2</strong>）</li><li>此时，以head开头的p1为<code>1-&gt;2-&gt;2-&gt;None</code>,以prev开头的p2为<code>None&lt;-2&lt;-1</code>,所以只需判断p2存在时，p1是否等于p2。</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: bool        """</span>        <span class="token comment" spellcheck="true"># 边界条件，直接跳出,如[] 或者 [2]</span>        <span class="token comment" spellcheck="true"># if not head or not head.next: return True</span>        <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token punctuation">(</span>head <span class="token operator">and</span> head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span> <span class="token comment" spellcheck="true"># 必须有括号，and后取其反</span>        <span class="token comment" spellcheck="true"># 快慢指针找中点</span>        slow<span class="token operator">=</span>head        fast<span class="token operator">=</span>head        <span class="token keyword">while</span> fast <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true"># 反转以slow开始的后半部分链表</span>        prev <span class="token operator">=</span> None        cur<span class="token operator">=</span>slow        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>            cur<span class="token punctuation">.</span>next<span class="token punctuation">,</span>prev<span class="token punctuation">,</span>cur<span class="token operator">=</span>prev<span class="token punctuation">,</span>cur<span class="token punctuation">,</span>cur<span class="token punctuation">.</span>next        p1<span class="token operator">=</span>head        p2<span class="token operator">=</span>prev        <span class="token comment" spellcheck="true"># 只需判断p2存在时，p1是否等于p2</span>        <span class="token keyword">while</span> p2<span class="token punctuation">:</span>            <span class="token keyword">if</span> p1<span class="token punctuation">.</span>val<span class="token operator">!=</span>p2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            p1<span class="token operator">=</span>p1<span class="token punctuation">.</span>next            p2<span class="token operator">=</span>p2<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何同时寻找缺失和重复的元素</title>
      <link href="/2020/07/13/labuladong/di-si-zhang-ru-he-tong-shi-xun-zhao-que-shi-he-chong-fu-de-yuan-su/"/>
      <url>/2020/07/13/labuladong/di-si-zhang-ru-he-tong-shi-xun-zhao-que-shi-he-chong-fu-de-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/que-shi-he-zhong-fu-de-yuan-su" target="_blank" rel="noopener">如何同时寻找缺失和重复的元素</a></p><p><a href="https://leetcode-cn.com/problems/set-mismatch/" target="_blank" rel="noopener">645. 错误的集合</a></p><ul><li>利用set去重，并记录重复的元素</li><li>遍历一遍<code>range(1,len(nums)+1)</code>,找到并记录不存在的于set中的元素</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findErrorNums</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[int]        """</span>        se<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> se<span class="token punctuation">:</span>                se<span class="token punctuation">.</span>add<span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 利用set去重</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 顺便记录重复的元素</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> se<span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 找到并记录不存在的于set中的元素</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何寻找缺失的元素</title>
      <link href="/2020/07/13/labuladong/di-si-zhang-ru-he-xun-zhao-que-shi-de-yuan-su/"/>
      <url>/2020/07/13/labuladong/di-si-zhang-ru-he-xun-zhao-que-shi-de-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/xiao-shi-de-yuan-su" target="_blank" rel="noopener">如何寻找缺失的元素</a></p><p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a></p><ul><li>先遍历列表，并加到set中。利用 HashSet 去重</li><li>若元素不在列表中，则表示该元素缺失</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findDisappearedNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[int]        """</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        se<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            se<span class="token punctuation">.</span>add<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> se<span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何判定括号合法性</title>
      <link href="/2020/07/13/labuladong/di-si-zhang-ru-he-pan-ding-gua-hao-he-fa-xing/"/>
      <url>/2020/07/13/labuladong/di-si-zhang-ru-he-pan-ding-gua-hao-he-fa-xing/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/he-fa-kuo-hao-pan-ding" target="_blank" rel="noopener">如何判定括号合法性</a></p><p><strong>解题思路</strong>：遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号（栈顶元素），看是否匹配。</p><p>Krahets的<a href="https://leetcode-cn.com/problems/valid-parentheses/solution/valid-parentheses-fu-zhu-zhan-fa-by-jin407891080/" target="_blank" rel="noopener">极简思路及实现</a></p><blockquote><p><strong>栈 stack 为空： 此时 stack.pop() 操作会报错</strong>；因此，我们采用一个取巧方法，给 stack 赋初值 ?? ，并在哈希表 dic 中建立 key: ‘?’，value:’?’key: ′ ? ′ ，value: ′ ? ′  的对应关系予以配合。</p></blockquote><ul><li>建立哈希表 dic 构建左右括号对应关系：keykey 左括号，valuevalue 右括号</li><li>如果 <code>c</code> 是左括号，则入栈 push</li><li>否则通过哈希表判断括号对应关系，若 stack 栈顶出栈括号 stack.pop() 与当前遍历括号 <code>c</code>不对应，则提前返回 False</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: bool        """</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'('</span><span class="token punctuation">:</span><span class="token string">')'</span><span class="token punctuation">,</span><span class="token string">'{'</span><span class="token punctuation">:</span><span class="token string">'}'</span><span class="token punctuation">,</span><span class="token string">'['</span><span class="token punctuation">:</span><span class="token string">']'</span><span class="token punctuation">,</span><span class="token string">'?'</span><span class="token punctuation">:</span><span class="token string">'?'</span><span class="token punctuation">}</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'?'</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>            <span class="token keyword">elif</span> c<span class="token operator">==</span>dic<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何寻找最长回文子串</title>
      <link href="/2020/07/13/labuladong/di-si-zhang-ru-he-xun-zhao-zui-chang-hui-wen-zi-chuan/"/>
      <url>/2020/07/13/labuladong/di-si-zhang-ru-he-xun-zhao-zui-chang-hui-wen-zi-chuan/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.md" target="_blank" rel="noopener">如何寻找最长回文子串</a></p><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></p><ul><li>回文串的长度可能是奇数也可能是偶数，如果是 abba这种情况，没有一个中心字符。所以可以：<ul><li>找到以 s[i] 为中心的回文串（对奇数回文串），<br>找到以 s[i] 和 s[i+1] 为中心的回文串（对偶数回文串），<br>更新答案</li></ul></li><li>选择最长的回文串，保存在res中</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: str        """</span>        <span class="token keyword">def</span> <span class="token function">palindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 若左右指针没越界，且元素相等，则指针向两边扩散</span>            <span class="token keyword">while</span> l<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> r<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                    l<span class="token operator">-=</span><span class="token number">1</span>                    r<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">return</span> s<span class="token punctuation">[</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token string">""</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            s1<span class="token operator">=</span>palindrome<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span>            s2<span class="token operator">=</span>palindrome<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#这里越界无所谓，因为调用palindrome时已经不满足while条件，可直接跳出</span>            <span class="token comment" spellcheck="true"># 选择最长的回文串保存在res中</span>            res<span class="token operator">=</span>res <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">></span>len<span class="token punctuation">(</span>s1<span class="token punctuation">)</span> <span class="token keyword">else</span> s1            res<span class="token operator">=</span>res <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">></span>len<span class="token punctuation">(</span>s2<span class="token punctuation">)</span> <span class="token keyword">else</span> s2        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何k个一组反转链表</title>
      <link href="/2020/07/13/labuladong/di-si-zhang-ru-he-k-ge-yi-zu-fan-zhuan-lian-biao/"/>
      <url>/2020/07/13/labuladong/di-si-zhang-ru-he-k-ge-yi-zu-fan-zhuan-lian-biao/</url>
      
        <content type="html"><![CDATA[<p>labuladong<a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/k-ge-yi-zu-fan-zhuan-lian-biao" target="_blank" rel="noopener">如何k个一组反转链表</a></p><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a></p><p>利用栈先进后出，反转k个一组的链表</p><ul><li>stack中存放的是ListNode<ul><li>虽然存放在stack中，但ListNode之间的指向关系仍然保留</li></ul></li></ul><p>以 1-&gt;2-&gt;3-&gt;4-&gt;5 为例，</p><ul><li>先在最左边加一个dummy头(-1)便于操作。</li><li>注意：大循环 <code>while cur</code>里面的while n&gt;0 <strong>and cur</strong> 一定要有，确保不够k个Node时n&gt;0，及时跳出。</li><li>第一次while时，stack中存放 [3,2,1],pre产生的结果是： -1-&gt;3-&gt;2-&gt;1 。此时cur 指向4，pre指向3。<code>pre.next=cur</code>后现在的结果是-1-&gt;3-&gt;2-&gt;1-&gt;4-&gt;5</li><li>第二次while时，stack中存放[5,4],但是由于n！=0，直接break出循环（即<code>pre.next=cur</code>不执行）。此时cur已经指向5后面的None，但是现在已经跳出while循环了，<strong>不必理会cur</strong>。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>head<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        dummy<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        dummy<span class="token punctuation">.</span>next<span class="token operator">=</span>head        pre<span class="token operator">=</span>dummy        cur<span class="token operator">=</span>head        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># while True：</span>            n<span class="token operator">=</span>k            <span class="token keyword">while</span> n<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> cur<span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>                cur<span class="token operator">=</span>cur<span class="token punctuation">.</span>next                n<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> stack<span class="token punctuation">:</span>                    pre<span class="token punctuation">.</span>next<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                    pre<span class="token operator">=</span>pre<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>            pre<span class="token punctuation">.</span>next<span class="token operator">=</span>cur        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：如何运用贪心思想玩跳跃游戏</title>
      <link href="/2020/07/12/labuladong/di-si-zhang-ru-he-yun-yong-tan-xin-si-xiang-wan-tiao-yue-you-xi/"/>
      <url>/2020/07/12/labuladong/di-si-zhang-ru-he-yun-yong-tan-xin-si-xiang-wan-tiao-yue-you-xi/</url>
      
        <content type="html"><![CDATA[<p>labuladong <a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/tiao-yue-you-xi" target="_blank" rel="noopener">如何运用贪心思想玩跳跃游戏</a></p><p>有关动态规划的问题，大多是让你求最值的，比如<strong>最长子序列，最小编辑距离，最长公共子串等等等</strong>。</p><p>那么贪心算法作为特殊的动态规划也是一样，也一定是让你求个最值。这道题就是让求：请问通过题目中的跳跃规则，<strong>最多能跳多远</strong>？如果能够越过最后一格，返回 true，否则返回 false。</p><p>两道题都注意，在 <code>for i in range (len(nums)-1)</code>    处就停止，不考虑最后一个元素的下标及元素的大小。因为nums[-1] 不会再用到，若加入，反而会干扰部分结果，产生错误 （如<code>[2,0,0]</code>）。</p><p><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏1</a></p><p><code>farthest</code>表示到达最远距离的下标</p><ul><li>每一步都计算一下从当前位置最远能够跳到哪里，然后和一个全局最优的最远位置 farthest 做对比，通过每一步的最优解，更新全局最优解，这就是贪心。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canJump</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: bool        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token comment" spellcheck="true"># 到达最远距离的下标</span>        farthest<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            farthest<span class="token operator">=</span>max<span class="token punctuation">(</span>farthest<span class="token punctuation">,</span>i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 到达不了</span>            <span class="token keyword">if</span> farthest<span class="token operator">&lt;=</span>i<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> farthest<span class="token operator">>=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏2</a></p><ul><li>我们不需要【递归地】计算出所有选择的具体结果然后比较求最值，而只需要做出那个最有【潜力】，看起来最优的选择即可。</li><li>i 和 end 标记了可以选择的跳跃步数，farthest 标记了所有选择 [i..end] 中能够跳到的最远距离，step记录了跳跃次数。</li><li>当i遍历到end处时，把end更新为更远的farthest，步数+1</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">jump</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        farthest<span class="token punctuation">,</span>end<span class="token punctuation">,</span>step<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            farthest<span class="token operator">=</span>max<span class="token punctuation">(</span>farthest<span class="token punctuation">,</span>i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> i<span class="token operator">==</span>end<span class="token punctuation">:</span>                end<span class="token operator">=</span>farthest                step<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> step<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
